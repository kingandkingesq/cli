#!/usr/bin/env CLI_NAME=cli bash-cli

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND[@]}
    
Summary
    Print a string as a literal bash string.

Description
    Simple strings consisting of letters, numbers, dash, and underbar are
    printed as is. Otherwise, the bash string is harvested from 'declare -p'
    for the value of an array element. So spaces are wrapped in double quoes,
    the 'bell' character is printed as $'\a' and the dollar symbol as "\$".
EOF
}

cli::meta::declare() {
    cli::meta::allow_positional
}

main() {
    ::cli::bash::literal::inline "$@"
}

::cli::bash::literal::inline() {
    local literal="$*"
    
    #echo "if [[ ! \"${literal}\" =~ ^[a-zA-Z_-]* ]]; then"
    if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
        echo "${literal}"
        return 0
    fi

    local ARRAY=( "$*" )
    literal=$(declare -p ARRAY)

    # 0123456789012345678901
    # declare -a ARRAY=([0]="foo")
    literal="${literal:22}"
    literal="${literal:0: -1}"

    echo "${literal}"
}

self_test() {
    ${CLI_COMMAND[@]} -- hello \
        | assert::pipe_eq \
            'hello'

    ${CLI_COMMAND[@]} -- hello world \
        | assert::pipe_eq \
            '"hello world"'

    ${CLI_COMMAND[@]} -- $'\a' \
        | assert::pipe_eq_exact \
            "\$'\\a'"

    ${CLI_COMMAND[@]} -- "\$" \
        | assert::pipe_eq_exact \
            '"\$"'
}
