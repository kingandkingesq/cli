#!/usr/bin/env bash
source $(cli loader)
cli::import_inline cli bash get-type
cli::import_inline cli bash write
cli::import cli_assert

help() {
    cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Serialize a variable into a table.

Description
    Serialize a variable to stdin escaping IFS characters. 
    
    If the variable is declared as a string or integer, then the stream 
    will contain a single record consisting of a single field, the value. 
    
    If the variable is declared as an array, then the stream is will
    contain multipule records, each consisting of a single field, the value.

    If the variable is declared as an associative array, then the stream
    will contain multipule records, each consisting of two fields,
    a key and a value.

Arguments
    --name -n          [Required] : Name of the variable to serialize.
    --multi-value -m       [Flag] : If set, each map value is assumed to contain 
                                    multipule "printf '%q'" escaped values which 
                                    will be serialized as individaul key value 
                                    pairs. Has no effect for other variables types.

Debug Arguments
    --source -s      [Flag] : Source stdin.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.

Example
    Serialize and deserialize an array.
        declare -a ARRAY=( a b c )
        declare -p ARRAY \\
            | ${CLI_COMMAND} --source --name ARRAY
EOF
}

inline() {
    : ${arg_multi_value:=false}

    local -a values
    local -n ref="${arg_name}"
    ::cli::bash::get_type::inline ref | read type REPLY

    case "${type}" in
        'array') 
            for value in "${ref[@]}"; do
                ::cli::bash::write::inline "${value}"
            done 
            ;;
        'map') 
            if $arg_multi_value; then
                for key in "${!ref[@]}"; do
                    eval "values=( ${ref[${key}]} )"
                    for value in "${values[@]}"; do
                        ::cli::bash::write::inline "${key}" "${value}"
                    done
                done
            else
                for key in "${!ref[@]}"; do
                    ::cli::bash::write::inline "${key}" "${ref[${key}]}"
                done
            fi | sort -k1 -k2
            ;;
        *) 
            ::cli::bash::write::inline "${ref}"
    esac
}

main() {
    if $arg_source; then
        source /dev/stdin
    fi

    inline
}

self_test() {
    declare STRING='Hello world!'
    declare -p STRING \
        | cli bash table write --source --name STRING \
        | assert::pipe_eq_exact \
            'Hello\ world!'

    declare -a ARRAY=( '$' $'\t' 'b c' )
    declare -p ARRAY \
        | cli bash table write --source --name ARRAY \
        | assert::pipe_eq_exact \
            '$' $'\\\t' 'b\ c'

    declare -A MAP=( [z]='a b' [a]=z [my key]=$'\ttabbed' )
    declare -p MAP \
        | cli bash table write --source --name MAP \
        | assert::pipe_eq_exact \
            'a z' \
            $'my\ key \\\ttabbed' \
            'z a\ b'

    declare -A MAP=( [z]='a b' )
    declare -p MAP \
        | cli bash table write --multi-value --source --name MAP \
        | assert::pipe_eq_exact \
            'z a' \
            'z b'
}

cli::load "$@"