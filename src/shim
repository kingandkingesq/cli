#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Bind to and invoke a command.

Description
    Bind to and invoke a command. The path to the command is constructed by
    joining a base path with the first non-option arguments. Named arguments and
    positional arguments are passed to the target command.

    The variable CLI_COMMAND is exported to the target command. Its value is
    a space delimited list consisting of 'name' followed by the first non-option 
    arguments to this command. 
    
    CLI_COMMAND serves the same purpose as BASH_COMMAND.

Arguments
    --name    : Name of the root group of the CLI.
    --base    : The absolute path to the root directory of the commands.
    --        : Arguments that conform to [path] [named] [positional].

Global Arguments
    --help -h    [Flag] : Show this message and exit.
    --self-test  [Flag] : Runs a self test over all commands.

Examples
    Use the shim to print help for /usr/bin/base64
        cli shim --name bin --base /usr/bin -- base64 --help

    Use the shim to encode 'Hello World' in base 64
        echo Hello World | cli shim --name bin --base /usr/bin -- base64 -i -

    Print the shim that is included in packed files
        cli shim

    Create a cli 'sayhi' that speaks in english and french
        echo "#"'!'"/usr/bin/env bash" > sayhi
        cli shim >> sayhi
        echo "sayhi::english::speak() { echo Hi; }" >> sayhi
        echo "sayhi::french::speak() { echo Bonjour; }" >> sayhi
        echo "cli::shim sayhi \\\$@" >> sayhi
        chmod a+x sayhi
        ./sayhi english speak
        ./sayhi french speak
EOF
}

# To prevent duplicate code the shim harvests logic from other commands.
# As everything depends on the shim, the shim must harvest and cache this 
# code manually. The harvest and cache logic emulates functionality that
# is later built upon using the shim. That emulation is maintained manually.

# copied from 'loader'
set +m
set -e
set -u
shopt -s lastpipe
shopt -s globstar
shopt -s extglob
shopt -s nullglob

# Build cache path (e.g. '/cli/src/.cli/shim/inline.sh')
# This logic duplicated in 'cli cache path'. It's too hot to harvest.
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_PATH="${BASH_DIR}/.cli/${BASH_NAME}/inline.sh"

# cli::import cli emit inline
# cli::import cli cache put
# cli::import name to_unix
# cli::import bash callstack
# cli::import bash fail
cli::shim::import_inline() {

    # Refresh cache if the shim changed since it was last generated.
    
    # This logic duplicated in 'cli cache test'.
    if [[ ! -f "${CACHE_PATH}" ]] \
        || [[ "${CACHE_PATH}" -ot "${BASH_SOURCE}" ]]; then

        # source inline as ::cli::emit::inline::inline
        cat "${BASH_DIR}/emit/inline" \
            | "${BASH_DIR}/emit/inline" --name ::cli::emit::inline::inline \
            | source /dev/stdin

        # wrap ::cli::emit::inline::inline as cli::shim::inline
        cli::shim::inline() {
            arg_name="::cli::$1::inline" ::cli::emit::inline::inline \
                < "${BASH_DIR}/$2"
        }

        # source 'cli cache put' as ::cli::cache::put::inline
        cli::shim::inline "cache::put" "cache/put" \
            | source /dev/stdin

        # refresh 'inline.sh'
        cat \
            <(cat ${BASH_DIR}/.group | grep 'CLI_REGEX_NAME=' | sed 's/^declare/declare -g/') \
            <(cli::shim::inline "name::to_unix" "name/to_unix") \
            <(cli::shim::inline "bash::callstack" "bash/callstack") \
            <(cli::shim::inline "bash::fail" "bash/fail") \
            | arg_cache=${CACHE_PATH} ::cli::cache::put::inline
    fi

    source "${CACHE_PATH}"
}

cli::fail() {
    arg_message="$@" \
        ::cli::bash::fail::inline
}

cli::import() { return; }
cli::shim::is_command() { test -f "$1" && test -x "$1"; }
cli::shim::is_group() { test -d "$1" && test -x "$1"; }
cli::shim::list() { cli list --dir "$1"; }
cli::shim::call_loader() {
    "${BASH_DIR}/loader"
    exit
}

main() {
    # execute well known commands
    if [[ "${arg_name}" == 'cli' && "$@" == "loader" ]]; then
        cli::shim::call_loader
    fi

    cli::shim::import_inline

    # pull segments from args; logic harvested from cli args tokenzie
    local -a cli_segments=()
    while (( $# > 0 )); do
        if [[ ! "$1" =~ ${CLI_REGEX_NAME} ]]; then
            break;
        fi

        cli_segments+=( "$1" )
        shift
    done

    # convert cli segments to unix directories (e.g. cli name to_unix)
    local -a unix_segments=()
    arg_result=unix_segments \
        ::cli::name::to_unix::inline "${cli_segments[@]}"

    # build unix path (e.g. /git/cli/src/name/to_unix)
    local join=( "${arg_base}" "${unix_segments[@]}" )
    local unix_path="$(IFS=/; echo "${join[*]}")"

    # file
    if cli::shim::is_command "${unix_path}"; then

        case "${1-}" in
            # optimization
            '---type')
                echo 'command' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                local -a cli_path=( "${arg_name}" "${cli_segments[@]}" )
                declare -x CLI_COMMAND="${cli_path[@]}"
                "${unix_path}" "$@"
                ;;

        esac

    # directory
    elif cli::shim::is_group "${unix_path}"; then
     
        case "${1-}" in
            '---type')
                echo 'group' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                cli::shim::list "${unix_path}" ;;
        esac

    # fail
    else
        echo "Command \"${unix_path}\" not found."
        exit 1
    fi
}

self_test() {
    diff \
        <("$0" --name bin --base /usr/bin -- base64 --help) \
        <(/usr/bin/base64 --help)

    diff \
        <("$0" --name usr --base /usr -- bin base64 --help) \
        <(/usr/bin/base64 --help)

    diff \
        <(echo "Hello World!" \
            | "$0" --name bin --base /usr/bin -- base64 -i -) \
        <(echo SGVsbG8gV29ybGQhCg==)

    diff \
        <(echo "Hello World!" \
            | "$0" --name does-not-matter --base /usr -- bin base64 -i -) \
        <(echo SGVsbG8gV29ybGQhCg==)
}

initialize() {  
    
    # declarations
    declare -g arg_help=""
    declare -g arg_base=""
    declare -g arg_name=""
    declare -g arg_self_test=""
    declare -g arg_help=""
    declare -ga arg_=()
    declare -gA arg__=()
    
    # defaults
    arg_self_test=false
    arg_help=false
    
    # assign variables from command line arguments
    while (( $# > 0 )); do
        case "$1" in
            '--help') arg__[arg_help]="true"; arg_help=true ;;
            '--name') arg__[arg_name]="${2:-}"; arg_name="${2:-}"; shift ;;
            '--base') arg__[arg_base]="${2:-}"; arg_base="${2:-}"; shift ;;
            '--self-test') arg__[arg_self_test]="true"; arg_self_test=true ;;
            '-h') arg__[arg_help]="true"; arg_help=true ;;
            '--') shift; arg_=( "$@" ); break ;;
            *)
                echo "Unexpected argument '$1'."
                exit 1
            ;;
        esac
        if (( $# > 0 )); then shift; fi
    done
}

# emulate loader
case ${1-} in
    '---print') cat ${BASH_SOURCE} ;;
    '---which') echo ${BASH_SOURCE} ;;
    '---exports') echo 'nyi' ;;
    '---initialize') echo '/dev/null' ;;
    '---imports') ;;
    *) 
        initialize "$@"

        if ${arg_help}; then help; exit; fi
        if ${arg_self_test}; then self_test; exit; fi

        main "${arg_[@]}" 
    ;;
esac
