#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Bind to and invoke a command.

Description
    Bind to and invoke a command. The path to the command is constructed by
    joining a base path with the first non-option arguments. Positional arguments
    to this command are passed through to the target command.

    The variable CLI_COMMAND is exported to the target command. Its value is
    a space delimited list consisting of 'name' followed by the first non-option 
    arguments to this command. CLI_COMMAND serves the same purpose as BASH_COMMAND.

Arguments
    --name    : Name of the root group of the CLI.
    --base    : The absolute path to the root directory of the unpacked commands.
    --        : Options to pass to the bound command.

Global Arguments
    --help -h    [Flag] : Show this message and exit.
    --self-test  [Flag] : Runs a self test over all commands.

Examples
    Use the shim to print help for /usr/bin/base64
        cli shim --name bin --base /usr/bin -- base64 --help

    Use the shim to encode 'Hello World' in base 64
        echo Hello World | cli shim --name bin --base /usr/bin -- base64 -i -

    Print the shim that is included in packed files
        cli shim

    Create a cli 'sayhi' that speaks in english and french
        echo "#"'!'"/usr/bin/env bash" > sayhi
        cli shim >> sayhi
        echo "sayhi::english::speak() { echo Hi; }" >> sayhi
        echo "sayhi::french::speak() { echo Bonjour; }" >> sayhi
        echo "cli::shim sayhi \\\$@" >> sayhi
        chmod a+x sayhi
        ./sayhi english speak
        ./sayhi french speak
EOF
}

# copied from 'loader'
set +m
set -e
set -u
shopt -s lastpipe
shopt -s globstar
shopt -s extglob
shopt -s nullglob

# To prevent duplicate code the shim harvests logic from other commands.
# As everything depends on the shim, the shim must harvest and cache this 
# code manually. The harvest and cache logic emulates functionality that
# is later built upon using the shim. That emulation is maintained manually.

# Build cache path (e.g. '/cli/src/.cli/shim/inline.sh')
# This logic duplicated in 'cli cache path'. It's too hot to harvest.
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_PATH="${BASH_DIR}/.cli/${BASH_NAME}/inline.sh"

cli::shim::load() {
    # Refresh cache if the shim changed since it was last generated.
    # This logic duplicated in 'cli cache test'.
    if [[ ! -f "${CACHE_PATH}" ]] \
        || [[ "${CACHE_PATH}" -ot "${BASH_SOURCE}" ]]; then
        cli::shim::refresh_cache
    fi

    source "${CACHE_PATH}"
}

cli::shim::refresh_cache() {

    # source inline as ::cli::emit::inline::inline
    cat "${BASH_DIR}/emit/inline" \
        | "${BASH_DIR}/emit/inline" --name ::cli::emit::inline::inline \
        | source /dev/stdin

    cli::shim::inline() {
        arg_name="::cli::$1::inline" ::cli::emit::inline::inline \
            < "${BASH_DIR}/$2"
    }

    # source 'cli cache put' as ::cli::cache::put::inline
    cli::shim::inline "cache::put" "cache/put" \
        | source /dev/stdin

    # refresh 'inline.sh'
    cat \
        <(cat ${BASH_DIR}/.group | grep ^declare | sed 's/^declare/declare -g/') \
        <(cli::shim::inline "args::tokenize" "args/tokenize") \
        <(cli::shim::inline "name::to_unix" "name/to_unix") \
        | arg_cache=${CACHE_PATH} ::cli::cache::put::inline
}

cli::fail() {
    echo "$@" >&2
    exit 1
}

cli::shim::is_command() { test -f "$1" && test -x "$1"; }
cli::shim::is_group() { test -d "$1" && test -x "$1"; }
cli::shim::list() { cli list --dir "$1"; }
cli::shim::known_commands::loader() {
    "${BASH_DIR}/loader"
    exit
}

main() {
    # execute well known commands
    if [[ "${arg_name}" == 'cli' ]]; then
        if [[ "$@" == "loader" ]]; then
            cli::shim::known_commands::loader
        fi
    fi

    cli::shim::load

    # pluck cli names from args (e.g. name to-unix)
    local -a cli_names=()
    arg_result=cli_names \
        ::cli::args::tokenize::inline "$@"

    # add cli name to list of cli names (e.g. cli name to-unix)
    local -a cli_path=( "${arg_name}" "${cli_names[@]}" )

    # convert cli names to unix names (e.g. cli name to_unix)
    local -a unix_names=()
    arg_result=unix_names \
        ::cli::name::to_unix::inline "${cli_names[@]}"

    # build unix path (e.g. /git/cli/src/name/to_unix)
    local join=( "${arg_base}" "${unix_names[@]}" )
    local unix_path="$(IFS=/; echo "${join[*]}")"

    # shift so remaining args are options and positional, if any
    shift ${#cli_names[@]}

    # file
    if cli::shim::is_command "${unix_path}"; then

        case "${1-}" in
            # optimization
            '---type')
                echo 'command' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                declare -x CLI_COMMAND="${cli_path[@]}"
                "${unix_path}" "$@"
                ;;

        esac

    # directory
    elif cli::shim::is_group "${unix_path}"; then
     
        case "${1-}" in
            '---type')
                echo 'group' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                cli::shim::list "${unix_path}" ;;
        esac

    # fail
    else
        echo "Command \"${unix_path}\" not found."
        exit 1
    fi
}

initialize() {
    
    # declarations
    declare -g arg_help=""
    declare -g arg_base=""
    declare -g arg_name=""
    declare -g arg_self_test=""
    declare -g arg_help=""
    declare -ga arg_=()
    declare -gA arg__=()
    
    # defaults
    arg_self_test=false
    arg_help=false
    
    # assign variables from command line arguments
    while (( $# > 0 )); do
        case "$1" in
            '--help') arg__[arg_help]="true"; arg_help=true ;;
            '--name') arg__[arg_name]="${2:-}"; arg_name="${2:-}"; shift ;;
            '--base') arg__[arg_base]="${2:-}"; arg_base="${2:-}"; shift ;;
            '--self-test') arg__[arg_self_test]="true"; arg_self_test=true ;;
            '-h') arg__[arg_help]="true"; arg_help=true ;;
            '--') shift; arg_=( "$@" ); break ;;
            *)
                echo "Unexpected argument '$1'."
                exit 1
            ;;
        esac
        if (( $# > 0 )); then shift; fi
    done
}

# emulate loader
case ${1-} in
    '---print') cat ${BASH_SOURCE} ;;
    '---which') echo ${BASH_SOURCE} ;;
    '---exports') echo 'nyi' ;;
    '---initialize') echo '/dev/null' ;;
    '---imports') ;;
    *) 
        initialize "$@"

        if ${arg_help}; then help; exit; fi
        if ${arg_self_test}; then exit; fi

        main "${arg_[@]}" 
    ;;
esac
