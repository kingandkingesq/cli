#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Bind to and invoke a command.

Arguments
    --dry-run    [Flag] : Print the command that would be called.
    --type              : Type of path. Allowed values: file, function.
                          Default: file.
    --                  : Positional and named arguments.

Global Arguments
    --help -h    [Flag] : Show this message and exit.
    --self-test  [Flag] : Runs a self test over all commands.

Examples
    Use the shim to print help for /usr/bin/base64
        cli shim /usr/bin base64 -h

    Use the shim to encode 'Hello World' in base 64
        echo Hello World | cli shim /usr/bin base64 -i -

    Print the shim that is included in packed files
        cli shim

    Create a cli 'sayhi' that speaks in english and french
        echo "#"'!'"/usr/bin/env bash" > sayhi
        cli shim >> sayhi
        echo "sayhi::english::speak() { echo Hi; }" >> sayhi
        echo "sayhi::french::speak() { echo Bonjour; }" >> sayhi
        echo "cli::shim sayhi \\\$@" >> sayhi
        chmod a+x sayhi
        ./sayhi english speak
        ./sayhi french speak
EOF
}

cli::shim::help() {
    cat << EOF
Command
    $1

Summary
    List available commands and groups.
    
Description
    Operations on a group of commands include listing sub-groups,
    commands, and both.

Arguments
    --list -l               : List commands and groups.
    --commands -c           : List commands.
    --groups -g             : List command groups.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
EOF
}

# support [Params], unify paths + function names + library_name, support relative paths

# copied from 'loader'
set +m
set -e
set -u
shopt -s lastpipe
shopt -s globstar
shopt -s extglob
shopt -s nullglob

cli::shim::main() { 
    local CLI_SHIM_ARG_GLOB="-*"
    local CLI_SHIM_PATH_SEGMENT_GLOB="?([.])+([a-zA-Z0-9-])"

    local path=
    local callsite=

    callsite=$(cli::shim::callsite "$@")
    eval "set ${callsite}"
    path=$1; shift

    # file
    if cli::shim::is_command "${path}"; then

        case "${1-}" in
            # optimization
            '---which')
                echo "${path}" ;; 
            *)
                if ! declare -p CLI_LOADER_IMPORTS_EXPIRATION_PATH >/dev/null 2>&1; then
                    declare -xg CLI_LOADER_IMPORTS_EXPIRATION_PATH="$(mktemp "/tmp/cli.XXXXXX")"
                    trap cli::shim::on_exit EXIT
                fi
                "${path}" "$@"
                ;;

        esac

    # directory
    elif cli::shim::is_group "${path}"; then
        cli::shim::list "${path}"

    # fail
    else
        cli::shim::command_not_found "${path#${dir}}"
    fi
}

# copied from callsite
cli::shim::callsite() {
    declare CLI_CALL_ARG_GLOB="-*"
    declare CLI_CALL_PATH_SEGMENT_GLOB="?([.])+([a-zA-Z0-9-])"

    # use filesystem to resolve command, and first argument is the 
    # base directory where commands are under development
    local delimiter=
    local dir=
    local path=

    # shift path root
    dir=${arg_base}
    path="${dir}"

    # pick a path dilimiter
    delimiter='/'
    if [[ "${arg_type}" == 'function' ]]; then
        delimiter='::'
    fi

    # compose command path by consuming args upto first dash argument 
    while (( $# > 0 )); do

        # stop joining path segments if an argument is found (e.g. --foo)
        if [[ "$1" == $CLI_CALL_ARG_GLOB ]]; then 
            break
        fi

        # ensure uniformity of group names (e.g. foo-bar, not foo_bar)
        if [[ ! "$1" == $CLI_CALL_PATH_SEGMENT_GLOB ]]; then
            echo "Unexpected command name or group '$1' does not match '$CLI_CALL_PATH_SEGMENT_GLOB'."
            exit 1
        fi

        # if path does not end in a delimiter, then add one (e.g. '::' or '/')
        if [[ -n "${path}" && ! "${path}" =~ .*${delimiter}$ ]]; then
            path="${path}${delimiter}"
        fi

        # convert command or group name into file or function name (e.g. foo-bar -> foo_bar)
        path="${path}${1//-/_}"
        shift
    done

    printf '%q' "${path}"
    for i in "$@"; do
        printf ' %q' "${i}"
    done
    echo
}

cli::shim::on_exit() {
    rm "${CLI_LOADER_IMPORTS_EXPIRATION_PATH}"
}

cli::shim::is_command() {
    local path="$1"
    test -f "${path}" && test -x "${path}"
}

cli::shim::is_group() {
    local path="$1"
    test -d "${path}" && test -x "${path}"
}

cli::shim::list() (
    cli list --dir "$1"
)

cli::shim::split() {
    set "${1//${delimiter}/ }"  # replace '::' or '/' with space
    set "${1//_/-}"             # replace '_' with '-'
    echo $1
}

cli::shim::command_not_found() {
    echo "Command '$(cli::shim::split $1)' not found."
    exit 1
}

main() {
    declare -f cli::shim::main
    declare -f cli::shim::split
    declare -f cli::shim::command_not_found

    # these functions generated during packing
    # declare -f cli::shim::is_command
    # declare -f cli::shim::is_group
    # declare -f cli::shim::list
    # declare -g cli::shim::callsite
}


initialize() {
    
    # declarations
    declare -g arg_help=""
    declare -g arg_base=""
    declare -g arg_type=""
    declare -g arg_self_test=""
    declare -g arg_help=""
    declare -ga arg_=()
    declare -gA arg__=()
    
    # defaults
    arg_type="file"
    arg_self_test=false
    arg_help=false
    
    # assign variables from command line arguments
    while (( $# > 0 )); do
        case "$1" in
            '--help') arg__[arg_help]="true"; arg_help=true ;;
            '--base') arg__[arg_base]="${2:-}"; arg_base="${2:-}"; shift ;;
            '--type') arg__[arg_type]="${2:-}"; arg_type="${2:-}"; shift ;;
            '--self-test') arg__[arg_self_test]="true"; arg_self_test=true ;;
            '-h') arg__[arg_help]="true"; arg_help=true ;;
            '--') shift; arg_=( "$@" ); break ;;
            *)
                echo "Unexpected argument '$1'."
                exit 1
            ;;
        esac
        if (( $# > 0 )); then shift; fi
    done

    # allowed values
    case "${arg_type}" in
        'file') ;;
        'function') ;;
        *)
            echo "Unexpected value '${arg_type}' for argument '--type'."
            exit 1
        ;;
    esac
}

# echo "$@" > /dev/stderr
case ${1-} in
    '') main ;;
    '-h') ;& '--help') help ;;
    '--self-test') ;;
    '---print') cat ${BASH_SOURCE} ;;
    '---which') echo ${BASH_SOURCE} ;;
    '---exports') main ;;
    '---initialize') ;;
    '---imports') ;;
    # -*) cli::shim::unexpected_argument "$1" ;;
    *) 
        initialize "$@"
        if (( ${#arg_[0]} > 0)); then set "${arg_[@]}"; fi
        cli::shim::main "$@" 
    ;;
esac

# trash
cli::shim::callsite::hide() (
    local this_path="${BASH_SOURCE}"
    local this_dir="${this_path%/*}"

    # resolve well-known callsites (prevents inifinite recursion)
    local loader="${this_dir}/loader"
    if [[ "${arg_base}/$@" -ef "${loader}" ]]; then
        echo "${loader}"
        return
    fi

    set -- '--base' "${arg_base}" '--' "$@"

    source "${this_dir}/callsite"
)
cli::shim::callsite::hide() {
    local this_path="${BASH_SOURCE}"
    local this_dir="${this_path%/*}"

    # resolve well-known callsites (prevents inifinite recursion)
    local loader="${this_dir}/loader"
    if [[ "${arg_base}/$@" -ef "${loader}" ]]; then
        echo "${loader}"
        return
    fi

    local shim="${this_dir}/shim"
    if [[ "${arg_base}/$1" -ef "${shim}" ]]; then
        shift
        echo "${shim} $@"
        return
    fi

    # echo ${callsite} '--base' "${arg_base}" '--' "$@" > /dev/stderr
    # ${callsite} '--base' "${arg_base}" '--' "$@" > /dev/stderr
    # echo '---' > /dev/stderr

    local callsite="${this_dir}/callsite"
    ${callsite} '--base' "${arg_base}" '--' "$@"
}
