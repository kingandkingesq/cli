#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Bind to and invoke a command.

Arguments
    --dry-run    [Flag] : Print the command that would be called.
    --type              : Type of path. Allowed values: file, function.
                          Default: file.
    --                  : Positional and named arguments.

Global Arguments
    --help -h    [Flag] : Show this message and exit.
    --self-test  [Flag] : Runs a self test over all commands.

Examples
    Use the shim to print help for /usr/bin/base64
        cli shim /usr/bin base64 -h

    Use the shim to encode 'Hello World' in base 64
        echo Hello World | cli shim /usr/bin base64 -i -

    Print the shim that is included in packed files
        cli shim

    Create a cli 'sayhi' that speaks in english and french
        echo "#"'!'"/usr/bin/env bash" > sayhi
        cli shim >> sayhi
        echo "sayhi::english::speak() { echo Hi; }" >> sayhi
        echo "sayhi::french::speak() { echo Bonjour; }" >> sayhi
        echo "cli::shim sayhi \\\$@" >> sayhi
        chmod a+x sayhi
        ./sayhi english speak
        ./sayhi french speak
EOF
}

# copied from 'loader'
set +m
set -e
set -u
shopt -s lastpipe
shopt -s globstar
shopt -s extglob
shopt -s nullglob

# inline 'cli path join' and 'cli positional'
declare CLI_SHIM_SOURCE_PATH="${BASH_SOURCE}"
declare CLI_SHIM_SOURCE_NAME="${CLI_SHIM_SOURCE_PATH##*/}"
declare CLI_SHIM_SOURCE_DIR="${CLI_SHIM_SOURCE_PATH%/*}"
declare CLI_SHIM_CACHE_DIR="${CLI_SHIM_SOURCE_DIR}/.cli/${CLI_SHIM_SOURCE_NAME}"
declare CLI_SHIM_CACHE_INLINE_PATH="${CLI_SHIM_CACHE_DIR}/inline.sh"

# test cache
if [[ ! -f "${CLI_SHIM_CACHE_INLINE_PATH}" ]] \
    || [[ "${CLI_SHIM_CACHE_INLINE_PATH}" -ot "${CLI_SHIM_SOURCE_PATH}" ]]; then

    declare CLI_SHIM_CACHE_INLINE_TEMP_PATH=$(mktemp "/tmp/cache.XXXXXX")

    # ::cli::inline::inline
    cat "${BASH_SOURCE%/*}/emit/inline" \
        | {
            while true; do
                read -r
                if [[ "${REPLY}" == 'main() {' ]]; then
                    echo "::cli::inline::inline() {"
                    while true; do 
                        read -r
                        echo "${REPLY}"
                        if [[ ${REPLY} == '}' ]]; then
                            exit
                        fi
                    done
                fi
            done
        } \
        | source /dev/stdin

    # constants
    inline() {
        arg_name="::cli::$1::inline" \
        arg_path="${CLI_SHIM_SOURCE_DIR}/$2" \
            ::cli::inline::inline \
            >> "${CLI_SHIM_CACHE_INLINE_TEMP_PATH}"
    }

    # cli/path/join -> ::cli::path::join::inline
    inline "path::join" "path/join"

    # cli/positional -> ::cli::positional::inline
    inline "positional" "positional"

    # create cache dir            
    if [[ ! -d "${CLI_SHIM_CACHE_DIR}" ]]; then
        mkdir -p "${CLI_SHIM_CACHE_DIR}"
    fi

    # put cache file
    mv "${CLI_SHIM_CACHE_INLINE_TEMP_PATH}" "${CLI_SHIM_CACHE_INLINE_PATH}"
fi

# source inlined functions
source "${CLI_SHIM_CACHE_INLINE_PATH}"

cli::shim::is_command() { test -f "$1" && test -x "$1"; }
cli::shim::is_group() { test -d "$1" && test -x "$1"; }
cli::shim::list() { cli list --dir "$1"; }

cli::shim::cache::start_time() {
    if ! declare -p CLI_LOADER_IMPORTS_EXPIRATION_PATH >/dev/null 2>&1; then
        declare -xg CLI_LOADER_IMPORTS_EXPIRATION_PATH="$(mktemp "/tmp/cli.XXXXXX")"
        cli::shim::on_exit() { 
            rm "${CLI_LOADER_IMPORTS_EXPIRATION_PATH}"
        }
        trap cli::shim::on_exit EXIT
    fi
}

main() {
    local positional_arg_count=$(::cli::positional::inline "$@")
    local positional_args=( "${@:1:${positional_arg_count}}" )
    local optional_args=( "${@:$(( positional_arg_count + 1 ))}" )
    local cli_path=( "${arg_name}" "${positional_args[@]}" )
    local path=$(arg_delimiter='/' ::cli::path::join::inline "${positional_args[@]}")

    shift ${positional_arg_count}

    # file
    if cli::shim::is_command "${path}"; then

        case "${1-}" in
            # optimization
            '---type')
                echo 'command' ;;
            '---which')
                echo "${path}" ;; 
            *)
                cli::shim::cache::start_time
                
                declare -x CLI_PATH="${cli_path[@]}"

                "${path}" "${optional_args[@]}"
                ;;

        esac

    # directory
    elif cli::shim::is_group "${path}"; then
     
        case "${1-}" in
            '---type')
                echo 'group' ;;
            *)
                cli::shim::list "${path}" ;;
        esac

    # fail
    else
        echo "Command \"${path}\" not found."
        exit 1
    fi
}

initialize() {
    
    # declarations
    declare -g arg_help=""
    declare -g arg_base=""
    declare -g arg_name=""
    declare -g arg_type=""
    declare -g arg_self_test=""
    declare -g arg_help=""
    declare -ga arg_=()
    declare -gA arg__=()
    
    # defaults
    arg_type="file"
    arg_self_test=false
    arg_help=false
    
    # assign variables from command line arguments
    while (( $# > 0 )); do
        case "$1" in
            '--help') arg__[arg_help]="true"; arg_help=true ;;
            '--name') arg__[arg_name]="${2:-}"; arg_name="${2:-}"; shift ;;
            '--base') arg__[arg_base]="${2:-}"; arg_base="${2:-}"; shift ;;
            '--type') arg__[arg_type]="${2:-}"; arg_type="${2:-}"; shift ;;
            '--self-test') arg__[arg_self_test]="true"; arg_self_test=true ;;
            '-h') arg__[arg_help]="true"; arg_help=true ;;
            '--') shift; arg_=( "$@" ); break ;;
            *)
                echo "Unexpected argument '$1'."
                exit 1
            ;;
        esac
        if (( $# > 0 )); then shift; fi
    done

    # allowed values
    case "${arg_type}" in
        'file') ;;
        'function') ;;
        *)
            echo "Unexpected value '${arg_type}' for argument '--type'."
            exit 1
        ;;
    esac
}

# emulate loader
case ${1-} in
    '---print') cat ${BASH_SOURCE} ;;
    '---which') echo ${BASH_SOURCE} ;;
    '---exports') main ;;
    '---initialize') ;;
    '---imports') ;;
    *) 
        initialize "$@"

        if ${arg_help}; then help; exit; fi
        if ${arg_self_test}; then exit; fi

        main "${arg_[@]}" 
    ;;
esac
