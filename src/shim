#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Bind to and invoke a command.

Arguments
    --dry-run    [Flag] : Print the command that would be called.
    --type              : Type of path. Allowed values: file, function.
                          Default: file.
    --                  : Positional and named arguments.

Global Arguments
    --help -h    [Flag] : Show this message and exit.
    --self-test  [Flag] : Runs a self test over all commands.

Examples
    Use the shim to print help for /usr/bin/base64
        cli shim --name bin --base /usr/bin -- base64 --help

    Use the shim to encode 'Hello World' in base 64
        echo Hello World | cli shim --name bin --base /usr/bin -- base64 -i -

    Print the shim that is included in packed files
        cli shim

    Create a cli 'sayhi' that speaks in english and french
        echo "#"'!'"/usr/bin/env bash" > sayhi
        cli shim >> sayhi
        echo "sayhi::english::speak() { echo Hi; }" >> sayhi
        echo "sayhi::french::speak() { echo Bonjour; }" >> sayhi
        echo "cli::shim sayhi \\\$@" >> sayhi
        chmod a+x sayhi
        ./sayhi english speak
        ./sayhi french speak
EOF
}

# copied from 'loader'
set +m
set -e
set -u
shopt -s lastpipe
shopt -s globstar
shopt -s extglob
shopt -s nullglob

# To prevent duplicate code the shim harvests logic from other commands.
# As everything depends on the shim, the shim must harvest and cache this 
# code manually. The harvest and cache logic emulates functionality that
# is later built upon using the shim. That emulation is maintained manually.

# Build cache path (e.g. '/cli/src/.cli/shim/inline.sh')
# This logic duplicated in 'cli cache path'. It's too hot to harvest.
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_PATH="${BASH_DIR}/.cli/${BASH_NAME}/inline.sh"

# Refresh 'inline.sh' if the shim changes since it was last generated.
# This logic duplicated in 'cli cache test'. It's too hot to harvest.
if [[ ! -f "${CACHE_PATH}" ]] \
    || [[ "${CACHE_PATH}" -ot "${BASH_SOURCE}" ]]; then

    # harvest 'cli inline' as ::cli::inline::inline
    cat "${BASH_SOURCE%/*}/emit/inline" \
        | {
            while true; do
                read -r
                if [[ "${REPLY}" == 'main() {' ]]; then
                    echo "::cli::inline::inline() {"
                    while true; do 
                        read -r
                        echo "${REPLY}"
                        if [[ ${REPLY} == '}' ]]; then
                            exit
                        fi
                    done
                fi
            done
        } \
        | source /dev/stdin

    cli::shim::inline() {
        arg_name="::cli::$1::inline" ::cli::inline::inline < "${BASH_DIR}/$2"
    }

    # source 'cli cache put' as ::cli::cache::put::inline
    cli::shim::inline "cache::put" "cache/put" | source /dev/stdin

    # refresh 'inline.sh'
    cat \
        <(cat ${BASH_DIR}/.group | grep ^declare) \
        <(cli::shim::inline "path::join" "path/join") \
        <(cli::shim::inline "args::tokenize" "args/tokenize") \
        <(cli::shim::inline "name::to_unix" "name/to_unix") \
        | arg_cache=${CACHE_PATH} ::cli::cache::put::inline
fi

cli::fail() {
    echo "$@" >&2
    exit 1
}

source "${CACHE_PATH}"

cli::shim::is_command() { test -f "$1" && test -x "$1"; }
cli::shim::is_group() { test -d "$1" && test -x "$1"; }
cli::shim::list() { cli list --dir "$1"; }

cli::shim::cache::start_time() {
    if ! declare -p CLI_LOADER_IMPORTS_EXPIRATION_PATH >/dev/null 2>&1; then
        declare -xg CLI_LOADER_IMPORTS_EXPIRATION_PATH="$(mktemp "/tmp/cli.XXXXXX")"
        cli::shim::on_exit() { 
            rm "${CLI_LOADER_IMPORTS_EXPIRATION_PATH}"
        }
        trap cli::shim::on_exit EXIT
    fi
}

main() {
    # build cli path (e.g. cli dsl tokenize)
    local -a cli_names=()
    arg_result=cli_names \
        ::cli::args::tokenize::inline "$@"
    local -a cli_path=( "${arg_name}" "${cli_names[@]}" )

    # build bash path (e.g. /git/cli/src/dsl/tokenize)
    local -a bash_names=()
    arg_result=bash_names \
        ::cli::name::to_unix::inline "${cli_names[@]}"

    local join=( "${arg_base}" "${bash_names[@]}" )
    local unix_path="$(IFS=/; echo "${join[*]}")"

    # shift so remaining args are options and positional, if any
    shift ${#cli_names[@]}

    # file
    if cli::shim::is_command "${unix_path}"; then

        case "${1-}" in
            # optimization
            '---type')
                echo 'command' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                cli::shim::cache::start_time
                declare -x CLI_COMMAND="${cli_path[@]}"
                "${unix_path}" "$@"
                ;;

        esac

    # directory
    elif cli::shim::is_group "${unix_path}"; then
     
        case "${1-}" in
            '---type')
                echo 'group' ;;
            '---which')
                echo "${unix_path}" ;; 
            *)
                cli::shim::list "${unix_path}" ;;
        esac

    # fail
    else
        echo "Command \"${unix_path}\" not found."
        exit 1
    fi
}

initialize() {
    
    # declarations
    declare -g arg_help=""
    declare -g arg_base=""
    declare -g arg_name=""
    declare -g arg_self_test=""
    declare -g arg_help=""
    declare -ga arg_=()
    declare -gA arg__=()
    
    # defaults
    arg_self_test=false
    arg_help=false
    
    # assign variables from command line arguments
    while (( $# > 0 )); do
        case "$1" in
            '--help') arg__[arg_help]="true"; arg_help=true ;;
            '--name') arg__[arg_name]="${2:-}"; arg_name="${2:-}"; shift ;;
            '--base') arg__[arg_base]="${2:-}"; arg_base="${2:-}"; shift ;;
            '--self-test') arg__[arg_self_test]="true"; arg_self_test=true ;;
            '-h') arg__[arg_help]="true"; arg_help=true ;;
            '--') shift; arg_=( "$@" ); break ;;
            *)
                echo "Unexpected argument '$1'."
                exit 1
            ;;
        esac
        if (( $# > 0 )); then shift; fi
    done
}

# emulate loader
case ${1-} in
    '---print') cat ${BASH_SOURCE} ;;
    '---which') echo ${BASH_SOURCE} ;;
    '---exports') echo 'nyi' ;;
    '---initialize') echo '/dev/null' ;;
    '---imports') ;;
    *) 
        initialize "$@"

        if ${arg_help}; then help; exit; fi
        if ${arg_self_test}; then exit; fi

        main "${arg_[@]}" 
    ;;
esac
