#!/usr/bin/env bash
source $(cli loader)
cli::import cli_assert

help() {
    cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Serialize bash variables, arrays, and assoicative.

Description
    A variable is serialized as a single line, followed by a type 
    discriminator, followed by a value (or  key name then value).

    The descriminators for string, array, and asociative array are
    
        ${VARIABLE_TYPE}
        ${ARRAY_TYPE}
        ${MAP_TYPE}

Arguments
    --source -s      [Flag] : Source declarations from stdin.
    --emit -e        [Flag] : Emit bash source instead of a stream of records.
    --                      : Name of bash variables to serialize.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.

Examples
    Serialize sample bash variables
        cli util serialize -- my_string my_array my_map
EOF
}

# alias for ease of use in help
declare VARIABLE_TYPE='-'
declare ARRAY_TYPE='a'
declare MAP_TYPE='A'

declare my_string='Hello world!'
declare -a my_array=( 'Hello world' $'\ttabbed' $'  indented' '' )
declare -A my_map=( [my key]=$'\tmy tabbed value' )

inline() {
    local VARIABLE_TYPE='-'
    local ARRAY_TYPE='a'
    local MAP_TYPE='A'

    : ${arg_emit:=false}
    : ${arg_source:=false}

    # source; let bash deserialize it
    if ${arg_source}; then
        source /dev/stdin
    fi

    # serialize
    while (( $# > 0 )); do
        local name="$1"
        local -n ref="${name}"
        if [[ -R ref[@] ]]; then
            shift
            continue
        fi

        if ${arg_emit}; then
            declare -p $1

        else
            declare -p $1 | read _ declare_flags _

            case "${declare_flags}" in
                *a*) 
                    for value in "${ref[@]}"; do 
                        printf "%-30s %-3s %q\n" \
                            "${name}" "${ARRAY_TYPE}" "${value}"
                    done 
                    ;;
                *A*) 
                    for key in "${!ref[@]}"; do 
                        printf "%-30s %-3s %-15q %q\n" \
                            "${name}" "${MAP_TYPE}" "${key}" "${ref[${key}]}"
                    done | sort
                    ;;
                *) 
                    printf "%-30s %-3s %q\n" \
                        "${name}" "${VARIABLE_TYPE}" "${ref}" 
                    ;;
            esac
        fi
        shift
    done
}

self_test() {
    ${CLI_COMMAND} -- my_string my_array my_map \
    | assert::pipe_eq_exact \
        "my_string                      -   Hello\\ world\\!" \
        "my_array                       a   Hello\ world" \
        "my_array                       a   \$'\\ttabbed'" \
        "my_array                       a   \\ \\ indented" \
        "my_array                       a   ''" \
        "my_map                         A   my\\ key         \$'\\tmy tabbed value'"

    ${CLI_COMMAND} -e -- my_string my_array my_map \
    | assert::pipe_eq_exact \
        "declare -- my_string=\"Hello world!\"" \
        "declare -a my_array=([0]=\"Hello world\" [1]=\$'\\ttabbed' [2]=\"  indented\" [3]=\"\")" \
        "declare -A my_map=([\"my key\"]=\$'\\tmy tabbed value' )"
}

cli::load "$@"