#!/usr/bin/env bash
source $(cli loader)
cli::import_group
cli::import cli_assert
cli::import cli util serialize
cli::import cli util readset

help() {
    cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Parse the command line into its component parts.

Description
    Parse the command line into an array of path segments, an associative 
    array of named arguments, and a array of positional arguments. For example,
    'bin foo --k0 v0 --flag -gh -- a0' has a path of 'bin foo', named arguments 
    '[k0]=v0 [flag]=true [g]=true [h]=true', and a positional argument 'a0'.
    Named arguments without an explicit value are assigned 'true'.

    Variables names to receive component parts (e.g. those passed as values to
    options 'command', 'named', and 'positional') are  optional. 
    
    Named argument names must be composed of only lowercase letters, numbers,
    and dash, and must start with a lowercase letter.
    
    Metadata variables used during validation of named arguments is either 
    deserialied from stdin (or '--metadata' if specified) into:

        CLI_META_REQUIRED
        CLI_META_DEFAULT_VALUE
        CLI_META_ALIASES
        CLI_META_ALLOWED_VALUES 

    The serialization format is defined by 'cli util serialize'.

    Named arguments may be required by inclusion in the array CLI_META_REQUIRED.
    For example, ( name ).

    Named arguments may have default values supplied in the associative array 
    CLI_META_DEFAULTS. For example, ( [help]=false ).

    Named arguments may have a single letter alias (upper or lower case) supplied 
    by the associative array CLI_META_ALIASES. For example, ( [h]=help ). 

    Named argument values may be constrained to a set supplied as space delimited 
    strings stored in the associative array CLI_META_ALLOWED_VALUES. For example, 
    ( [color]='red yellow green' ). Allowed values must consist of alpha numeric
    characters, dash, or underbar.

Arguments
    --command -c            : Array to store command name. Default: command.
    --named -n              : Associative array to store named arguments. Default: named.
    --positional -p         : Array to store positional arguments. Default: positional.
    --no-metadata -x [Flag] : Skip reading stdin for metadata.
    --                      : Command line arguments.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.

Examples
    Parse 'grp cmd --key value -hg -- a0 a1'.
        ${CLI_COMMAND} -- grp cmd --key value -hg -- a0 a1
EOF
}

inline() {
    local DASH_DASH='--'
    local DASH_ARG_REGEX="^-([^-].*)$"
    local DASH_DASH_ARG_REGEX="^--([^-].*)$"

    local -a _path=()
    local -n ref_path=${arg_command:-_path}

    local -A _named=()
    local -n ref_named=${arg_named:-_named}

    local -a _positional=()
    local -n ref_positional=${arg_positional:-_positional}

    # path
    while (( $# > 0 )); do
        if [[ ! "$1" =~ ${CLI_NAME_REGEX} ]]; then
            break;
        fi

        ref_path+=( "$1" )
        shift
    done

    local key
    local value
    local flags

    # optional
    while (( $# > 0 )); do

        # --
        if [[ "$1" == ${DASH_DASH} ]]; then
            break
        fi

        # aliases
        if [[ "$1" =~ ${DASH_ARG_REGEX} ]]; then
            flags="${BASH_REMATCH[1]}"
            shift

            if [[ ! "${flags}" =~ ${CLI_FLAGS_REGEX} ]]; then
                cli::fail "Unexpected argument \"-${flags}\" does not match regex ${CLI_FLAGS_REGEX}."
            fi

            for (( i=0; i<${#flags}; i++ )); do
                key=${flags:${i}:1}

                # implicit
                if ${arg_no_metadata}; then
                    value=${key}
                
                # explicit
                else
                    value=${CLI_META_ALIASES[$key]-}

                    # trap unknown
                    if [[ -z ${value} ]]; then
                        cli::fail "Unexpected unknown argument \"-${key}\"."
                    fi
                fi

                # substitute
                set -- "${DASH_DASH}${value}" "$@"
            done
            continue
        fi

        # option 
        if [[ "$1" =~ ${DASH_DASH_ARG_REGEX} ]]; then
            key="${BASH_REMATCH[1]}"
            shift

            if [[ ! "${key}" =~ ${CLI_NAME_REGEX} ]]; then
                cli::fail "Unexpected argument \"--${key}\" does not match regex ${CLI_NAME_REGEX}."
            fi

            if ! ${arg_no_metadata} && [[ -z ${CLI_META_DEFAULTS[$key]+set} ]]; then
                cli::fail "Unexpected unknown argument \"--${key}\"."
            fi

            if (( $# == 0 )) \
                || [[ "$1" =~ ${DASH_ARG_REGEX} ]] \
                || [[ "$1" =~ ${DASH_DASH_ARG_REGEX} ]] \
                || [[ "$1" == ${DASH_DASH} ]]; then

                # implicit value
                value=true
            else
                # explicit value
                value="$1"
                shift
            fi

            # trap duplicates
            if [[ -n ${ref_named[$key]+set} ]]; then
                cli::fail "Unexpected duplicate argument \"--${key}\"."
            fi

            # publish
            ref_named+=( [$key]=$value )
            continue
        fi

        cli::fail "Unexpected argument \"$1\"."
    done

    # positional
    if [[ "${1-}" == "${DASH_DASH}" ]]; then
        shift
        ref_positional+=( "$@" )
    fi

    # default values
    for i in ${!CLI_META_DEFAULTS[@]}; do
        if [[ -z ${ref_named[$i]+set} ]]; then
            ref_named+=( [$i]="${CLI_META_DEFAULTS[$i]}" )
        fi
    done

    # required
    for key in "${CLI_META_REQUIRED[@]}"; do
        if [[ -z "${ref_named[$key]-}" ]]; then
            cli::fail "Unexpected empty value for required argument \"--${key}\"."
        fi
    done

    # allowed values
    for key in "${!CLI_META_ALLOWED_VALUES[@]}"; do

        # allowed values keys should have at least been assigned a default value
        value=${ref_named[$key]?Unexpected bad allowed value metadata for \"${key}\".}

        # load allowed values into set
        local -A allowed_values=()
        arg_name=allowed_values ::cli::util::readset::inline \
            < <(printf '%s\n' ${CLI_META_ALLOWED_VALUES[$key]})

        # test set for allowed value
        if ! ${allowed_values[$value]-false}; then
            cli::fail "Unexpected value '${value}' for argument \"${key}\"."
        fi
    done
}

main() {    
    declare -a ${arg_command}
    declare -A ${arg_named}
    declare -a ${arg_positional}

    if ! ${arg_no_metadata}; then
        arg_global=true \
        arg_deserialize=true \
            ::cli::util::serialize::inline
    fi

    inline "$@"

    ::cli::util::serialize::inline \
        ${arg_command} ${arg_named} ${arg_positional}
}

self_test() {
    ${CLI_COMMAND} -x \
    | assert::pipe_eq

    # positional argument delimiter (e.g. --)
    ${CLI_COMMAND} -x -- \
    | assert::pipe_eq

    # default variable names (e.g. command, named, positional)
    ${CLI_COMMAND} -x -- c --k v -- a0 \
    | assert::pipe_records_eq \
        'command a c' \
        'named A k v' \
        'positional a a0'

    # rename (e.g. c, n, p)
    ${CLI_COMMAND} -x -c c -n n -p p -- c --k v -- a0 \
    | assert::pipe_records_eq \
        'c a c' \
        'n A k v' \
        'p a a0'

    # named argument default aliasing (e.g. '-k' -> '--k' )
    ${CLI_COMMAND} -x -- -k v \
    | assert::pipe_records_eq \
        'named A k v' 

    # named argument packed (e.g. '-mn' -> '--m --x' )
    ${CLI_COMMAND} -x -- -mn \
    | assert::pipe_records_eq \
        'named A m true' \
        'named A n true'

    # named argument implicit value (e.g. 'true' )
    ${CLI_COMMAND} -x -- --m -n \
    | assert::pipe_records_eq \
        'named A m true' \
        'named A n true'

    # command arguments
    ${CLI_COMMAND} -x -- g0 g1 cmd \
    | assert::pipe_records_eq \
        'command a g0' \
        'command a g1' \
        'command a cmd'

    # positional arguments
    ${CLI_COMMAND} -x -- -- a0 a1 \
    | assert::pipe_records_eq \
        'positional a a0' \
        'positional a a1'

    # bad names
    assert::fails "${CLI_COMMAND} -x -- -!"
    assert::fails "${CLI_COMMAND} -x -- --!"

    # duplicate named arguments    
    assert::fails "${CLI_COMMAND} -x -- -f -f"
    assert::fails "${CLI_COMMAND} -x -- --f --f"
    assert::fails "${CLI_COMMAND} -x -- --f -f"

    # invalid option (e.g. missing dash before 'k1') 
    assert::fails "${CLI_COMMAND} -x -- --k0 v0 k1"

    local -A CLI_META_DEFAULTS=( [color]='black' )
    local -a CLI_META_REQUIRED=( 'color' )
    local -A CLI_META_ALIASES=( [c]='color' )
    local -A CLI_META_ALLOWED_VALUES=( [color]='black white' )

    meta() {
        ::cli::util::serialize::inline \
            CLI_META_REQUIRED \
            CLI_META_DEFAULTS \
            CLI_META_ALIASES \
            CLI_META_ALLOWED_VALUES
    }

    # default value (e.g. black)
    meta | ${CLI_COMMAND} -- \
        | assert::pipe_records_eq \
        'named A color black'

    # override default value (e.g. white)
    meta | ${CLI_COMMAND} -- --color white \
        | assert::pipe_records_eq \
        'named A color white'

    # override default value (e.g. white)
    meta | ${CLI_COMMAND} -- -c white \
        | assert::pipe_records_eq \
        'named A color white'

    local -A CLI_META_DEFAULTS=( [help]='false' )
    local -a CLI_META_REQUIRED=()
    local -A CLI_META_ALIASES=( [h]='help' )
    local -A CLI_META_ALLOWED_VALUES=( [help]='true false' )

    # add flag (e.g. help is 'false')
    meta | ${CLI_COMMAND} \
        | assert::pipe_records_eq \
        'named A help false'

    # set flag (e.g. '--help' -> help is 'true')
    meta | ${CLI_COMMAND} -- --help \
        | assert::pipe_records_eq \
        'named A help true'

    # set flag via alias (e.g. '-h' -> help is 'true')
    meta | ${CLI_COMMAND} -- -h \
        | assert::pipe_records_eq \
        'named A help true'

    # flag is boolean (e.g. '--help maybe' disallowed)
    meta | assert::fails "${CLI_COMMAND} -- --help maybe"

    local -A CLI_META_DEFAULTS=( [name]='' )
    local -a CLI_META_REQUIRED=( 'name' )
    local -A CLI_META_ALIASES=()
    local -A CLI_META_ALLOWED_VALUES=()

    # provide required named argument (e.g. '--name Bob')
    meta | ${CLI_COMMAND} -- --name Bob \
        | assert::pipe_records_eq \
        'named A name Bob'

    # missing required named argument (e.g. missing '--name')
    meta | assert::fails "${CLI_COMMAND} -m -"
}

cli::load "$@"