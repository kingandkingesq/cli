#!/usr/bin/env bash
help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

set -e
set -u 
set -o pipefail
shopt -s lastpipe

# cache
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_DIR="${BASH_DIR}/.cli/${BASH_NAME}"
declare EXPORTS_PATH="${CACHE_DIR}/exports.sh"
if [[ -f "${EXPORTS_PATH}" ]] \
    && [[ "${EXPORTS_PATH}" -nt "${BASH_SOURCE}" ]]; then
    echo "${EXPORTS_PATH}"
    exit
fi

declare -a CLI_LOADER_IMPORTS=()
: ${CLI_COMMAND:=${BASH_SOURCE##*/}}

cli::loader::import_inline() {
    cat "${BASH_SOURCE%/*}/emit/inline" \
        | {
            while true; do
                read -r
                if [[ "${REPLY}" == 'inline() {' ]]; then
                    echo "::cli::inline::inline() {"
                    while true; do 
                        read -r
                        echo "${REPLY}"
                        if [[ ${REPLY} == '}' ]]; then
                            exit
                        fi
                    done
                fi
            done
        } \
        | source /dev/stdin
            
    inline() {
        arg_name="::cli::$1::inline" \
            ::cli::inline::inline < "${BASH_DIR}/$2" \
            | source /dev/stdin
    }

    inline 'cache::put' 'cache/put'
    inline 'cache::test' 'cache/test'
    inline 'cache::path' 'cache/path'
    inline 'path::join' 'path/join'
    inline 'args::parse' 'args/parse'
    inline 'args::tokenize' 'args/tokenize'
    inline 'args::parse' 'args/parse'
    inline 'reflection::is_function_declared' 'reflection/is_function_declared'
    inline 'reflection::run_as' 'reflection/run_as'
    inline 'util::fail' 'util/fail'
}

cli::fail() {
    arg_message="$@"
        ::cli::util::fail::inline
}

cli::import() {
    CLI_LOADER_IMPORTS+=( "$*" )
}

cli::import_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local group="${segments[@]:0:$(( length - 1 ))}"
    cli::import ${group} .group
}

cli::import_inline() {
    cli::import "$*"
}

cli::loader::cache::load() {
    declare -g CLI_LOADER_COMMAND_PATH="$1"
    declare -g CLI_LOADER_CACHE_DIR="$(arg_path="${CLI_LOADER_COMMAND_PATH}" \
        ::cli::cache::path::inline)"
    declare -g CLI_LOADER_INITIALIZE_PATH="${CLI_LOADER_CACHE_DIR}/initialize.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
    declare -g CLI_LOADER_METADATA_PATH="${CLI_LOADER_CACHE_DIR}/metadata.sh"
}

cli::cache::test() {
    arg_cache="$1" \
    arg_source="${CLI_LOADER_COMMAND_PATH}" \
        ::cli::cache::test::inline
}

cli::loader::cache::exports() {
    if ! cli::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then

        # declarative; e.g. inline
        if arg_name=inline ::cli::reflection::is_function_declared::inline; then
            cli emit inline \
                --name "$(cli path join --delimiter '::' -- ${CLI_COMMAND})::inline" \
                --function 'inline' \
                < "${CLI_LOADER_COMMAND_PATH}"
        
        # procedural; e.g library
        else
            "$0" 
        fi \
        | arg_cache="${CLI_LOADER_EXPORTS_PATH}" \
            ::cli::cache::put::inline
    fi
}

cli::loader::cache::initialize() {

    # initialize hard coded
    if arg_name=initialize ::cli::reflection::is_function_declared::inline; then
        return
    fi

    # test initialize cache 
    if ! cli::cache::test "${CLI_LOADER_INITIALIZE_PATH}"; then
   
        # initialize lazily generated (like JIT)
        "$0" '--help' \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl emit \
            | arg_cache="${CLI_LOADER_INITIALIZE_PATH}" \
                ::cli::cache::put::inline

        "$0" '--help' \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl meta \
            | arg_cache="${CLI_LOADER_METADATA_PATH}" \
                ::cli::cache::put::inline
    fi
}

cli::loader::load::imports() {
    local import_path=
    local exports_path=
    local -a import=()
    local -A imported=()
    local -A base_path=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORTS[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORTS[i]} )

        # if import previously seen, continue
        if ${imported[${import[@]}]-false}; then
            continue
        fi
        imported[${import[@]}]=true

        # if base path not resolved
        if [[ -z "${base_path[$import]-}" ]]; then

            # resolve base path
            base_path[${import}]=$(${import} '---which')

            # if cli still not resolved, fail
            if [[ -z "${base_path[${import}]}" ]]; then
                cli::fail "Failed to resolve import \"${import[@]}\"."
            fi
        fi

        import_path=$(arg_delimiter='/' arg_base=${base_path[${import}]} \
            ::cli::path::join::inline "${import[@]:1}")
        exports_path="$(arg_path=${import_path} \
            ::cli::cache::path::inline)/exports.sh"

        # if import codegen cache stale
        if ! arg_cache="${exports_path}" \
            arg_source="${import_path}" \
            ::cli::cache::test::inline; then

            # refresh import codegen cache
            ${import[@]} '---exports' > /dev/null
        fi
            
        # source codegen
        source "${exports_path}"
    done
}

cli::loader::load::initialize() {
    cli::loader::cache::initialize
    if [[ -f "${CLI_LOADER_INITIALIZE_PATH}" ]]; then
        source "${CLI_LOADER_INITIALIZE_PATH}"
    fi
}

cli::loader::execute() {

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        arg_user="${arg_run_as}" \
        arg_command="$0" \
            ::cli::reflection::run_as::inline "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args

        if arg_name=main ::cli::reflection::is_function_declared::inline; then
            main "${arg_[@]}"

        elif arg_name=inline ::cli::reflection::is_function_declared::inline; then
            inline "${arg_[@]}"

        elif arg_name=export ::cli::reflection::is_function_declared::inline; then
            export
            
        else
            cli::fail "Unexpected missing entry point 'main' or 'export'."
        fi
    fi
}

cli::loader::self_test() {
    self_test
    result=$?
    if ! (( ${result} == 0 )); then
        read line file < <(caller)
        echo "Self-test failed: ${file}"
    fi
    exit ${result}
}

cli::load() {
    declare -Ag CLI_META_DEFAULTS=()
    declare -Ag CLI_META_ALIASES=()
    declare -ag CLI_META_REQUIRED=()
    declare -Ag CLI_META_ALLOWED_VALUES=()

    # implicit imports
    if arg_name=export ::cli::reflection::is_function_declared::inline; then
        CLI_LOADER_IMPORTS+=( \
            'cli emit export' \
            'cli emit initialize' \
        )
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then
        case "$1" in
            '---type')
                echo 'command' ;;
            '---which') 
                echo "${CLI_LOADER_COMMAND_PATH}" ;;
            '---print') 
                cat "${CLI_LOADER_COMMAND_PATH}" ;;
            '---imports')
                for i in "${CLI_LOADER_IMPORTS[@]}"; do echo "${i}"; done ;;
            '---dependencies')
                cli imports -c "${CLI_COMMAND}" ;;
            '---initialize')
                cli::loader::load::imports
                cli::loader::cache::initialize
                if [[ -f "${CLI_LOADER_INITIALIZE_PATH}" ]]; then
                    echo "${CLI_LOADER_INITIALIZE_PATH}"
                fi
                ;;
            '---metadata')
                cli::loader::load::imports
                cli::loader::cache::initialize
                if [[ -f "${CLI_LOADER_METADATA_PATH}" ]]; then
                    echo "${CLI_LOADER_METADATA_PATH}"
                fi
                ;;
            '---dasm')
                "$0" '---metadata' \
                    | read; cat "${REPLY}" \
                    | cli util serialize -s -- \
                        CLI_META_DEFAULT \
                        CLI_META_REQUIRED \
                        CLI_META_ALIASES \
                        CLI_META_ALLOWED_VALUES \
                        CLI_META_IMPLICIT_VALUES \
                        CLI_META_POSITIONAL
                ;;
            '---emit')
                "$0" '---exports' | read; cat "${REPLY}"
                ;;
            '---exports')
                cli::loader::cache::exports
                echo "${CLI_LOADER_EXPORTS_PATH}"
                ;;
            *) cli::fail "Unexpected internal option \"$1\"."
        esac 
        exit
    fi

    cli::loader::load::imports

    for i in "$@"; do
        case "${i}" in
            '--') break ;;
            '-h') ;& '--help')
            help
            exit
        esac
    done
    unset i

    case "${1-}" in
        '--self-test')
            cli::loader::self_test
            exit
        ;;
    esac 

    cli::loader::load::initialize
    cli::loader::execute "$@"
}

main() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    echo 'set -o pipefail'
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    echo "declare -a CLI_LOADER_IMPORTS=()"
    echo ": \${CLI_COMMAND:=\${BASH_SOURCE[1]##*/}}"
    echo

    declare -f cli::fail
    declare -f cli::import
    declare -f cli::import_group
    declare -f cli::import_inline
    declare -f cli::load
    echo

    declare -f cli::loader::execute
    declare -f cli::loader::self_test
    echo

    declare -f ::cli::cache::test::inline
    declare -f ::cli::cache::path::inline
    declare -f ::cli::cache::put::inline
    declare -f ::cli::path::join::inline
    declare -f ::cli::reflection::is_function_declared::inline
    declare -f ::cli::reflection::run_as::inline
    declare -f ::cli::util::fail::inline
    declare -f ::cli::args::tokenize::inline
    declare -f ::cli::args::parse::inline
    echo

    declare -f cli::cache::test
    echo

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::initialize() {

            # hard coded
            if arg_name=initialize ::cli::reflection::is_function_declared::inline; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::initialize
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else

        declare -f cli::loader::cache::load
        declare -f cli::loader::cache::initialize
        declare -f cli::loader::cache::exports
        echo

        declare -f cli::loader::load::imports
        declare -f cli::loader::load::initialize
        echo

        # ${bash_source[0]} is '.cli/exports.sh' which is called by
        # ${bash_source[1]} which is the command itself 
        echo
        echo "cli::loader::cache::load \"\${BASH_SOURCE[1]}\""
  fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) cli::fail "Unexpected argument '$1'." ;;
        esac

        shift
    done
}

cli::loader::import_inline
cli::loader::cache::load ${BASH_SOURCE}

# refresh cache
if (( $# == 0 )); then
    : ${arg_pack:=false}
    main | arg_cache="${CLI_LOADER_EXPORTS_PATH}" \
        ::cli::cache::put::inline
    echo "${CLI_LOADER_EXPORTS_PATH}"
    exit
fi

cli::load "$@"
