#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

cli::reference() {
    if [[ ${CLI_REFLECT:-} == 'true' ]]; then
        echo $@ > /dev/stderr
    fi
}

cli::import() {
    cli::reference "$@"
    CLI_IMPORTS+=( "$*" )
}

# dry run support
cli::dry_run() {
    if [[ "${arg_dry_run:-}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:-}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:-}" == "true" ]]; then set +x; fi
    fi
}

cli::escape_args_then_call_as() {
    local user=$1
    shift

    local -a args
    for i in "$@"; do
        args+=( $(printf %q "${i}") )
    done

    sudo su "${user}" -c "${args[*]}"
}

cli::declare_dirs() {
    declare -g CLI_SOURCE_PATH="$1"
    declare -g CLI_SOURCE_NAME="${CLI_SOURCE_PATH##*/}"
    declare -g CLI_SOURCE_DIR="${CLI_SOURCE_PATH%/*}"
    declare -g CLI_CACHE_DIR="${CLI_SOURCE_DIR}/.cli/${CLI_SOURCE_NAME}"
    declare -g CLI_INITIALIZE_PATH="${CLI_CACHE_DIR}/initialize.sh"
    declare -g CLI_IMPORTS_PATH="${CLI_CACHE_DIR}/imports.sh"
}

cli::cache() {
    local path="$1"
    local temp_path=$(mktemp "$1.XXXXXX")
    
    while read -r; do
        echo "${REPLY}" >> "$temp_path"
    done

    mv "$temp_path" "$path"
}

cli::cached() {

    if [[ ! -f "$1"  ]] || [[ "$1" -ot "${CLI_SOURCE_PATH}" ]]; then
        false
    else
        true
    fi
}

cli::define_initialize() {

    # initialize hard coded
    if declare -F initialize > /dev/null; then

        # cache empty result
        if [[ ! -f "${CLI_INITIALIZE_PATH}" ]]; then
            : > "${CLI_INITIALIZE_PATH}"
        fi

        return
    fi

    # initialize not cached OR cache out of date 
    if ! cli::cached "${CLI_INITIALIZE_PATH}"; then

        # lazily generated (like JIT)
        help \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl emit \
            | cli::cache "${CLI_INITIALIZE_PATH}"
    fi

    source "${CLI_INITIALIZE_PATH}"
}

cli::source_imports() {

    # imports not cached OR cache out of date
    if ! cli::cached "${CLI_IMPORTS_PATH}"; then

        while [[ -n ${CLI_IMPORTS[@]} ]]; do

            # pipe the import into the cache
            ${CLI_IMPORTS[0]}

            # source the import to capture its imports
            source /dev/stdin < <(${CLI_IMPORTS[0]}) 

            # pop this import
            CLI_IMPORTS=( "${CLI_IMPORTS[@]:1}" )

        done | cli::cache "${CLI_IMPORTS_PATH}"
    fi

    source "${CLI_IMPORTS_PATH}"
}

cli::load() {

    # create cache dir
    mkdir -p "${CLI_CACHE_DIR}"

    case "${1-}" in
        '---imports')
            for i in "${CLI_IMPORTS[@]}"; do
                echo "$i"
            done
            exit
        ;;

        # emit initialize generated from help
        '---initialize-path')
            if [[ -f "${CLI_INITIALIZE_PATH}" ]]; then
                if [[ -s "${CLI_INITIALIZE_PATH}" ]]; then
                    echo "${CLI_INITIALIZE_PATH}"
                fi
                exit
            fi
        ;;
    esac 

    cli::source_imports

    # dump help if '-h' or '--help' appear anywhere on the command line
    for i in "$@"; do
        if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then 
            help
            exit
        fi
    done
    unset i

    case "${1-}" in

        # run self test
        '--self-test')
            self_test
            result=$?
            if ! (( ${result} == 0 )); then
                read line file < <(caller)
                echo "Self-test failed: ${file}"
            fi
            exit ${result}
        ;;

    esac 

    cli::define_initialize

    case "${1-}" in
 
        # emit path after population by cli::define_initialize
        '---initialize-path')
            if [[ -s "${CLI_INITIALIZE_PATH}" ]]; then
                echo "${CLI_INITIALIZE_PATH}"
            fi
            exit
        ;;
    esac 

    unset CLI_SOURCE_PATH
    unset CLI_SOURCE_NAME
    unset CLI_SOURCE_DIR
    unset CLI_CACHE_DIR
    unset CLI_INITIALIZE_PATH
    unset CLI_IMPORTS

    cli::execute "$@"
}

cli::execute() {

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args
        main
    fi
}

main() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    # set -o pipefail
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    echo "declare -a CLI_IMPORTS"

    if [[ ${CLI_REFLECT:-} == 'true' ]]; then
        # prevent JIT to prevent capturing libraries used during JIT
        echo "initialize() { return; }"
    fi

    declare -f cli::import
    declare -f cli::dry_run
    declare -f cli::escape_args_then_call_as
    declare -f cli::load
    declare -f cli::execute

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::define_initialize() {

            # hard coded
            if declare -F initialize > /dev/null; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::define_initialize
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else
        declare -f cli::reference
        declare -f cli::define_initialize
        declare -f cli::source_imports
        declare -f cli::declare_dirs
        declare -f cli::cached
        declare -f cli::cache

        echo
        echo "cli::declare_dirs \"\${BASH_SOURCE[1]}\""
  fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) echo "Unexpected argument '$1'."; exit 1 ;;
        esac

        shift
    done
}

set -e
set -u 
declare -a CLI_IMPORTS
cli::declare_dirs ${BASH_SOURCE}

cli::load "$@"