#!/usr/bin/env bash

# loader sourcing itself
if [[ -v CLI_IFS ]]; then
    ::cli::bash::function::is_declared::inline loader_source || cli::assert
    loader_source
    return
fi

# supress background processes from displaying their exit status upon completion.
# see https://mywiki.wooledge.org/BashFAQ/024
set +m

# see https://dougrichardson.us/notes/fail-fast-bash-scripting.html
set -e
shopt -s inherit_errexit

set -u
set -o pipefail

set -E
set -o functrace

# run the last segment of a pipeline in the current execution process, not a subshell.
# see https://mywiki.wooledge.org/BashFAQ/024
shopt -s lastpipe

# If set, the pattern ‘**’ used in a filename expansion context will match all 
# files and zero or more directories and subdirectories. If the pattern is followed 
# by a ‘/’, only directories and subdirectories match.
shopt -s globstar

# If the extglob shell option is enabled using the shopt builtin, 
# several extended pattern matching operators are recognized. 
shopt -s extglob

# If set, Bash allows filename patterns which match 
# no files to expand to a null string, rather than themselves.
shopt -s nullglob

# enables BASH_ARGC and BASH_ARGV
shopt -s extdebug

# optimization
cli::loader::main() {
    if [[ ! "${1-}" == '---exports' ]]; then
        return
    fi

    local exports_path="$(cd $(dirname $0); pwd)/.cli/loader/exports.sh"
    if [[ ! -f "${exports_path}" || "$0" -nt "${exports_path}" ]]; then
        return
    fi

    echo "${exports_path}"
    exit
}
cli::loader::main "$@"
unset -f cli::loader::main

# lock
[[ ! -v CLI_IFS ]] || cli::assert
readonly CLI_IFS="$IFS"
readonly CLI_LOADER_LOCK="${CLI_LOADER_LOCK-/tmp/.cli_lock}"

# debug
declare CLI_STACK_SHOW_PROCESS
declare CLI_STACK_SHOW_HIDDEN

# regex
readonly REGEX_NAME="[a-z.][a-z0-9-]*"
readonly CLI_REGEX_NAME="^${REGEX_NAME}$"
readonly CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"
readonly CLI_REGEX_PROPERTY_ARG="^(${REGEX_NAME})=(.*)$"
readonly CLI_REGEX_BASH_FUNCTION="^[:a-z_][:a-z0-9_]*$"

readonly CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
readonly CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
readonly CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

readonly -A CLI_KNOWN_COMMANDS=(
    ['cli loader']=
    ['cli dsl tokenize']=
    ['cli dsl parse']=
    ['cli dsl meta']=
)

# types
readonly -A CLI_TYPE_CLI_HELP_PARSE=(
    [group]="map_of cli_help_parse_group"
)
readonly -A CLI_TYPE_CLI_HELP_PARSE_GROUP=(
    [alias]="map"
    [type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
readonly -A CLI_TYPE_CLI_META_GROUP=(
    [type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
readonly -A CLI_TYPE_CLI_META=(
    [alias]="map"
    [group]="map_of cli_meta_group"
    #[attributes]="map_of cli_meta_attributes"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTE=(
    [type]="array"
    [blob]="array"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTES=(
    [method]="map_of cli_meta_attribute"
)
readonly -A CLI_TYPE_CLI_TOKENS=(
    [id]="array"
    [identifier]="array"
)
readonly -A CLI_TYPE_CLI_ARGS=(
    [path]="array"
    [first_named]="string"
    [named]="map_of array"
    [positional]="array"
)
readonly -A CLI_TYPE_CLI_BASH_STACK_HIDDEN_ATTRIBUTE=()

# tokens
readonly -a CLI_ARG_TOKEN=(
    [0]="PATH"
    [1]="VALUE"
    [2]="DASH"
    [3]="DASH_DASH"
    [4]="DASH_DASH_DASH"
    [5]="END_OPTIONS"
    [6]="EOF"
)
readonly CLI_ARG_TOKEN_PATH="0"
readonly CLI_ARG_TOKEN_VALUE="1"
readonly CLI_ARG_TOKEN_DASH="2"
readonly CLI_ARG_TOKEN_DASH_DASH="3"
readonly CLI_ARG_TOKEN_DASH_DASH_DASH="4"
readonly CLI_ARG_TOKEN_END_OPTIONS="5"
readonly CLI_ARG_TOKEN_EOF="6"

# productions
readonly -a CLI_ARG_PRODUCTION=(
    [0]="SEGMENT"
    [1]="OPTION"
    [2]="POSITIONAL"
)
readonly CLI_ARG_PRODUCTION_SEGMENT="0"
readonly CLI_ARG_PRODUCTION_OPTION="1"
readonly CLI_ARG_PRODUCTION_POSITIONAL="2"

# attributes
declare -A CLI_META_ATTRIBUTES_METHOD=(
    # ['::cli::bash::stack::call::inline']=0
    # ['::cli::bash::stack::trace::inline']=0
    # ['::cli::stderr::assert::inline']=0
    # ['cli::assert']=0
    
    # ['cli::main']=0
    # ['bash::main']=0
    
    # ['cli::trap::err']=0
)
readonly -a CLI_META_ATTRIBUTES_METHOD_0_TYPE=( 'cli_bash_stack_hidden_attribute' )
readonly -a CLI_META_ATTRIBUTES_METHOD_0_BLOB=()

# globals
declare -A CLI_LOADER_IMPORTED=(
    ["cli .group"]=true
    ["cli path .group"]=true
    ["cli temp .group"]=true
    ["cli cache .group"]=true
    ["cli bash .group"]=true
    ["cli shim .group"]=true
    ["cli set .group"]=true
    ["cli subshell .group"]=true
    ["cli stderr .group"]=true
    ["cli name .group"]=true
)
declare -A CLI_LOADER_SOURCED_PATHS=()

# debug
declare -a CLI_COMMAND_STACK=()

# frame
declare -A CLI_SCOPE=()

# statics
declare -a CLI_IMPORT_CLI_LOADER=()
declare -n CLI_IMPORT='CLI_IMPORT_CLI_LOADER'

# emulate bgen
bgen() {
    cli::bash::declare::type::cli_meta_tables() {
        cli::loader::scope::add $1 CLI_META_TABLES

        declare -Ag \
            "$1_ALIAS" \
            "$1_ALLOW" \
            "$1_DEFAULT" \
            "$1_POSITIONAL" \
            "$1_REGEX" \
            "$1_REQUIRE" \
            "$1_TYPE"
    }
    cli::bash::declare::type::cli_meta_group() {
        cli::loader::scope::add $1 CLI_META_GROUP

        declare -Ag \
            "$1_ALIAS" \
            "$1_DEFAULT" \
            "$1_REGEX" \
            "$1_REQUIRE" \
            "$1_BASH_TYPE" \
            "$1_TYPE"

        declare -g \
            "$1_POSITIONAL"
    }
    cli::bash::declare::type::cli_meta() {
        cli::loader::scope::add $1 CLI_META

        declare -Ag \
            "$1_ALIAS" \
            "$1_GROUP" \
            "$1_BASH_NAME"
    }
    cli::bash::declare::type::cli_meta_attributes() {
        cli::loader::scope::add $1 CLI_META_ATTRIBUTES

        declare -Ag \
            "$1_TYPE" \
            "$1_BLOB"
    }
    cli::bash::declare::type::cli_tokens() {
        cli::loader::scope::add $1 CLI_TOKENS

        declare -ag \
            "$1_ID" \
            "$1_IDENTIFIER"
    }
    cli::bash::declare::type::cli_args() {
        cli::loader::scope::add $1 CLI_ARGS

        declare -g \
            "$1_FIRST_NAMED"

        declare -Ag \
            "$1_NAMED"

        declare -ga \
            "$1_PATH" \
            "$1_POSITIONAL"
    }

    declare -Ag CLI_BGEN_DECLARE=(
        [CLI_TYPE_CLI_META_TABLES]=cli::bash::declare::type::cli_meta_tables
        [CLI_TYPE_CLI_META_GROUP]=cli::bash::declare::type::cli_meta_group
        [CLI_TYPE_CLI_META]=cli::bash::declare::type::cli_meta
        [CLI_TYPE_CLI_META_ATTRIBUTES]=cli::bash::declare::type::cli_meta_attributes
        [CLI_TYPE_CLI_TOKENS]=cli::bash::declare::type::cli_tokens
        [CLI_TYPE_CLI_ARGS]=cli::bash::declare::type::cli_args
    )
}
bgen

inline() {

    ::cli::set::test::inline() {
        local -n SET_REF=${1:?'Missing set'}
        shift 

        local KEY="$*"
        [[ "${KEY}" ]] || cli::assert 'Missing key'
        
        [[ ${SET_REF[${KEY}]+hit} == 'hit' ]]
    }

    ::cli::set::deflower::inline() {
        local -n SET_REF=${1?'Missing set'}
        local KEY=${2?'Missing element value'}

        if ::cli::set::test::inline "$@"; then
            return 1
        fi

        SET_REF[${KEY}]=true
    }

    ::cli::name::to_bash::inline() {
        MAPFILE=()
        while (( $# > 0 )); do
            [[ "$1" =~ ${CLI_REGEX_NAME} ]] || cli::assert \
                "Unexpected cli name \"$1\" does not match regex ${CLI_REGEX_NAME}."

            MAPFILE+=( "${1//[-.]/_}" )
            shift
        done
        REPLY=${MAPFILE[0]}
    }

    ::cli::name::to_inline::inline() {
        ::cli::name::to_bash::inline "$@"
        ::cli::bash::join::inline '::' '' "${MAPFILE[@]}" 'inline'
    }

    ::cli::name::to_main::inline() {
        ::cli::name::to_bash::inline "$@"
        ::cli::bash::join::inline "::" "${MAPFILE[@]}" 'main'
    }

    ::cli::name::to_symbol::inline() {
        ::cli::name::to_bash::inline "$@"
        ::cli::bash::join::inline '_' "${MAPFILE[@]^^}"
    }
        
    ::cli::name::parse::inline() {
        MAPFILE=()
        while [[ "${1-}" =~ ${CLI_REGEX_NAME} ]]; do
            MAPFILE+=( "$1" )
            shift
        done
    }

    ::cli::attribute::is_defined::inline() {
        local target_type=${1-}; shift
        local target=${1-}; shift
        local type=${1-}; shift

        # expand assertion as more target types are needed
        [[ ${target_type} == 'METHOD' ]] || cli::assert

        # target identifies a method (or type, or command, or what-have-you)
        [[ ${target} != 'METHOD' ]] || \
            [[ ${target} =~ ${CLI_REGEX_BASH_NAME} ]] || cli::assert

        local -n targets="CLI_META_ATTRIBUTES_${target_type}"
        local index=${targets[${target}]:-}
        local -n ref="CLI_META_ATTRIBUTES_${target_type}_${index}_TYPE"

        # search the types of attributes decorating the target for a match
        for attribute in "${ref[@]}"; do
            if [[ "${attribute}" == "${type}" ]]; then
                return 0
            fi
        done

        return 1
    }

    ::cli::path::dir::inline() { 
        REPLY="$(dirname $1)"
    }

    ::cli::path::name::inline() { 
        REPLY="${1##*/}"; 
    }

    ::cli::path::make_absolute::inline() {

        if [[ ! "${1-}" ]]; then
            REPLY="${PWD}"

        elif [[ ! "$1" =~ ^/ ]]; then
            REPLY="${PWD}/${1##./}"

        else
            REPLY="$1"
        fi
    }

    ::cli::cache::path::inline() {
        ::cli::path::name::inline "$1"
        local NAME="${REPLY}"

        ::cli::path::dir::inline "$1"
        local DIR="${REPLY}"

        REPLY="${DIR}/.cli/${NAME}"
    }

    ::cli::cache::put::inline() {
        local CACHE="$1"

        ::cli::path::dir::inline "${CACHE}"
        local DIR="${REPLY}"

        mkdir -p "${DIR}"

        ::cli::temp::file::inline
        local TEMP="${REPLY}"

        cat > "${TEMP}"

        mv "${TEMP}" "${CACHE}"

        REPLY="${CACHE}"
    }

    ::cli::cache::test::inline() {
        local CACHE="$1"
        local SOURCE="$2"

        [[ -f "${CACHE}" ]] && [[ "${SOURCE}" -ot "${CACHE}" ]]
    }

    ::cli::stderr::lock::inline() {
        flock -x "${CLI_LOADER_LOCK}" cat
    }

    ::cli::bash::function::list::inline() {
        declare -F \
            | awk '{ print $3 }' \
            | ::cli::bash::filter::glob::inline "$@"
    }
        
    ::cli::bash::filter::glob::inline() {
        while read -r; do
            local FILTER
            for FILTER in "$@"; do
                if [[ "${REPLY}" == ${FILTER} ]]; then
                    echo "${REPLY}"
                    break;
                fi
            done
        done
    }
        
    ::cli::bash::printf::inline() {
        local FORMAT=${1-}
        [[ $"{FORMAT}" ]] || cli::assert 'Missing format.'
        shift

        if (( $# == 0 )); then
            return
        fi

        printf "${FORMAT}" "$@"
    }

    ::cli::bash::log::inline() {
        echo "$@" >&2
    }

    ::cli::bash::which::inline() {
        local NAME="$1"
        shift

        local IFS=:
        local -a DIRS=( ${PATH} )

        for dir in "${DIRS[@]}"; do
            local PROBE="${dir}/${NAME}"
            [[ -f "${PROBE}" && -x "${PROBE}" ]] || continue
            REPLY="${PROBE}"
            return 0
        done

        return 1
    }

    ::cli::bash::return::inline() {
        return ${1-0}
    }

    ::cli::bash::join::inline() {
        local DELIMITER=${1?'Missing delimiter'}
        shift

        REPLY=""
        while (( $# > 0 )); do
            REPLY+="$1"
            shift

            if (( $# > 0 )); then 
                REPLY+="${DELIMITER}"
            fi
        done
    }

    ::cli::bash::stack::call::inline() {
        
        # argument counts by frame
        set -- ${BASH_ARGV[@]}

        # bash stack
        local -i argc=0
        for (( i=0; i<${#FUNCNAME[@]}; i++ )); do
            local -a args=()
            local inline_args=''
            local funcname="${FUNCNAME[$i]}"

            if (( i == ${#FUNCNAME[@]}-1 )); then funcname='bash::main'; fi

            # reverse argv for i-th frame
            for (( j=${BASH_ARGC[$i]}-1; j>=0; j-- )); do
                args+=( "$(::cli::bash::literal::inline "${BASH_ARGV[${j}+${argc}]}")" )
            done

            # pop argc stack for i-th frame
            argc+=${BASH_ARGC[$i]}

            if [[ ! "${CLI_STACK_SHOW_HIDDEN-}" ]] \
                && ::cli::attribute::is_defined::inline \
                    'METHOD' "${funcname}" 'cli_bash_stack_hidden_attribute'; then
                continue
            fi

            # inline args when they won't disturb formatting
            inline_args="${args[@]}"
            if (( ${#inline_args} > 80 )); then
                inline_args=
            else
                args=()
            fi

            printf '%-50s %s:%s\n' \
                "${funcname} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-}

            for arg in "${args[@]}"; do
                echo "${arg}"
            done | sed 's/^/  /'
        done
    }

    ::cli::bash::stack::process::inline() {
        local ARG_START_PID=${1-$$}
        local ARG_END_PID=${2-${CLI_PID-}}

        # load process poset and associated command lines
        local -a pid_parent=()
        local -a pid_cmd=()
        while read pid ppid cmd; do
            pid_parent[${pid}]=${ppid}
            pid_cmd[${pid}]="${cmd}"
        done < <(ps -o pid=,ppid=,args=)

        # subprocess stack
        local pid=${BASHPID}
        local -a subshell=( ${BASHPID} )
        while (( $pid != $$ )); do
            echo "(${pid}) subshell"
            pid=${pid_parent[${pid}]}
        done

        # process stack
        local pid=${ARG_START_PID}
        for (( i=0; ${pid} > 0; i++ )); do

            echo -n "(${pid}) "
            local inline_args=${pid_cmd[${pid}]}
            if (( ${#inline_args} < 80 )); then
                echo "${inline_args}"
            else
                echo "${inline_args}" \
                    | sed -e $'s/--/\\\n  --/g'
            fi

            if (( ${pid} == ${ARG_END_PID-0} )); then break; fi
            pid=${pid_parent[${pid}]-0}
        done
    }

    ::cli::bash::stack::trace::inline() {
        ::cli::bash::stack::call::inline
        if [[ -n "${CLI_STACK_SHOW_PROCESS-}" ]]; then
            ::cli::bash::stack::process::inline
        fi
    }

    ::cli::bash::function::is_declared::inline() {
        declare -F "${1-}" > /dev/null
    }

    ::cli::bash::literal::inline() {
        local literal="$*"
        
        #echo "if [[ ! \"${literal}\" =~ ^[a-zA-Z_-]* ]]; then"
        if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
            echo "${literal}"
            return 0
        fi

        local ARRAY=( "$*" )
        literal=$(declare -p ARRAY)

        # 0123456789012345678901
        # declare -a ARRAY=([0]="foo")
        literal="${literal:22}"
        literal="${literal:0: -1}"

        echo "${literal}"
    }

    ::cli::bash::emit::inline() {
        for name in "$@"; do
            if [[ "${name}" =~ ^.*[*]$ ]]; then
                for match in $(eval "echo \${!${name}}"); do
                    # do not recurse! test -v arr=() is false
                    declare -p ${match}
                done
            elif [[ -v "${name}" ]]; then
                declare -p "${name}"
            else
                # declare -a arr=()
                for match in $(eval "echo \${!${name}*}"); do
                    if [[ "${match}" == "${name}" ]]; then
                        declare -p "${name}"
                    fi
                done
            fi
        done
    }

    ::cli::bash::variable::list::inline() {

        local NAME
        for NAME in "$@"; do

            if [[ ! "${NAME}" ]]; then
                continue

            elif [[ "${NAME}" =~ ^.*[*]$ ]]; then

                local MATCH
                for MATCH in $(eval "echo \${!${NAME}}"); do
                    # do not recurse! test -v arr=() is false
                    echo "${MATCH}"
                done

            elif [[ -v "${NAME}" ]]; then
                echo "${NAME}"

            else
                # declare -a arr=()
                local MATCH
                for MATCH in $(eval "echo \${!${NAME}*}"); do
                    if [[ "${MATCH}" == "${NAME}" ]]; then
                        echo "${NAME}"
                    fi
                done
            fi
        done | sort
    }
        
    ::cli::bash::variable::emit::inline() {
        ::cli::bash::variable::list::inline "$@" \
            | while read; do declare -p ${REPLY}; done
    }

    ::cli::bash::array::pop::inline() {
        (( $# > 0 )) || cli::assert 'Stack empty.'
        MAPFILE=( ${@:1:$((${#@}-1))} )
    }

    ::cli::bash::map::copy::inline() {
        local SOURCE_MAP=${1-}
        [[ "${SOURCE_MAP}" ]] || cli::assert 'Missing source map.'
        shift

        local TARGET_MAP=${1-}
        [[ "${TARGET_MAP}" ]] || cli::assert 'Missing target map.'
        shift

        local -n SOURCE_REF=${SOURCE_MAP}
        local -n TARGET_REF=${TARGET_MAP}

        while (( $# > 0 )); do
            local KEY=$1
            shift

            if ! ::cli::set::test::inline ${SOURCE_MAP} ${KEY}; then
                continue
            fi

            TARGET_REF[${KEY}]="${SOURCE_REF[${KEY}]}"
        done
    }

    ::cli::subshell::on_exit::inline() {
        local -ga "CLI_SUBSHELL_ON_EXIT_${BASHPID}+=()"
        local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID}

        if (( ${#CLI_SUBSHELL_ON_EXIT[@]} == 0 )); then
            cli::subshell::on_exit::trap() {
                local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID}
                for delegate in ${CLI_SUBSHELL_ON_EXIT[@]}; do
                    ${delegate}
                done
            }
            trap cli::subshell::on_exit::trap EXIT
        fi

        CLI_SUBSHELL_ON_EXIT+=( "$@" )
    }
        
    ::cli::temp::remove::inline() {

        local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}

        # unlink files/directories
        for FILE in "$@"; do
            if ! ${CLI_SUBSHELL_TEMP_FILE_BASHPID[${FILE}]-}; then
                continue
            fi
            
            unset "CLI_SUBSHELL_TEMP_FILE_BASHPID[${FILE}]"

            if [[ ! -a "${FILE}" ]]; then
                :
            elif [[ -d "${FILE}" ]]; then
                rm -f -r "${FILE}"
                rm -f -r "${FILE}"
            else
                rm -f "${FILE}"
            fi
        done
    }

    ::cli::temp::file::inline() {

        # create and return a temporary file
        local TEMP_FILE=$(mktemp "${1-"${TMPDIR:-/tmp/}"}cli-XXXXXXXX")

        # record the temporary file 
        declare -gA "CLI_SUBSHELL_TEMP_FILE_${BASHPID}+=()"
        local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}

        # cleanup
        if (( ${#CLI_SUBSHELL_TEMP_FILE_BASHPID[@]} == 0 )); then
            ::cli::temp::file::on_exit() {

                # unlink files/directories
                local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
                ::cli::temp::remove::inline "${!CLI_SUBSHELL_TEMP_FILE_BASHPID[@]}"
            }

            ::cli::subshell::on_exit::inline \
                ::cli::temp::file::on_exit
        fi

        CLI_SUBSHELL_TEMP_FILE_BASHPID+=( ["${TEMP_FILE}"]='true' )
        REPLY="${TEMP_FILE}"
    }

    ::cli::temp::dir::inline() {
        ::cli::temp::file::inline "$@"
        rm -f "${REPLY}"
        mkdir "${REPLY}"
    }

    ::cli::temp::fifo::inline() {
        ::cli::temp::file::inline "$@"
        rm -f "${REPLY}"
        mkfifo "${REPLY}"
    }

    ::cli::subshell::signal_group::inline() {
        local SIGNAL=${1-'SIGINT'}
        read PID < <(ps -p ${BASHPID} -o pgid=)
        kill -${SIGNAL} -${PID}
    }

    ::cli::stderr::cat::inline() {

        # create a temporary file
        ::cli::temp::file::inline

        # write to file instead of stderr so generator can take lock
        cat > "${REPLY}"

        # lock and copy file to stderr
        cat "${REPLY}" \
            | ::cli::stderr::lock::inline >&2 

        # cleanup
        rm "${REPLY}"
    }

    ::cli::stderr::dump::inline() {

        # copy stdin to stderr
        ::cli::stderr::cat::inline

        # issue control-c
        ::cli::subshell::signal_group::inline
    }

    ::cli::stderr::assert::inline() {
        if (( $# == 0 )); then 
            set 'Condition failed'
        fi

        {
            echo "ASSERT FAILED:" "$*"
            ::cli::bash::stack::trace::inline \
                | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }

    ::cli::stderr::fail::inline() {
        echo "$*" \
            | ::cli::stderr::dump::inline
    }

    ::cli::stderr::on_err::inline() {
        local -a CLI_PIPESTATUS=( "${PIPESTATUS[@]}" )
        local CLI_TRAP_EXIT_CODE=${1-'?'}
        local BPID="${BASHPID}"

        # only dump if we are exiting after the trap; e.g. errexit is set (set -e)
        #   -e  Exit immediately if a command exits with a non-zero status.
        if [[ ! $- =~ e ]]; then
            return
        fi

        {
            echo -n "TRAP ERR: exit=${CLI_TRAP_EXIT_CODE}"
            if (( ${#CLI_PIPESTATUS[@]} > 1 )); then
                echo -n ", pipe=[$(cli::join ',' "${CLI_PIPESTATUS[@]}")]"
            fi
            echo ", bpid=${BPID}, pid=$$"
            echo "BASH_COMMAND ERR: ${BASH_COMMAND}"

            ::cli::bash::stack::trace::inline | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }

    ::cli::shim::source::inline() {
        local NAME="$1"
        local SHIM_ROOT_DIR_NAME="CLI_SHIM_ROOT_DIR_${NAME^^}"

        if [[ ! -v "${SHIM_ROOT_DIR_NAME}" ]]; then
                
            # resolve the path to the shim by searching PATH
            ::cli::bash::which::inline "$1" || return 1
            local SHIM_PATH="${REPLY}"
            
            # source the shim
            source "${SHIM_PATH}"

            # verify shim published the path to the root of its commands
            [[ -v "${SHIM_ROOT_DIR_NAME}" ]] \
                || cli::assert "Shim '$1' failed to define ${SHIM_ROOT_DIR_NAME}."

            # verify the shim published a function of the same name.
            ::cli::bash::function::is_declared::inline "${NAME}" \
                || cli::assert "Shim '$1' failed to define function ${NAME}."
        fi
    }

    ::cli::shim::which::inline() {
        local NAME="$1"
        shift

        ::cli::shim::source::inline "${NAME}" \
            || return 1

        local -n SHIM_ROOT_DIR_REF="CLI_SHIM_ROOT_DIR_${NAME^^}"
        [[ "${SHIM_ROOT_DIR_REF-}" ]] || cli::assert

        local IFS=/
        REPLY="${SHIM_ROOT_DIR_REF}/$*"
    }

    ::cli::shim::shebang::inline() {

        # CLI_NAME
        [[ "${CLI_NAME}" ]] \
            || cli::assert "Shebang failed to declare 'CLI_NAME'." 

        # SHIM_ROOT_DIR_REF
        ::cli::shim::source::inline "${CLI_NAME}" \
            || cli::assert "Shebang failed to find shim for cli '${CLI_NAME}'."
        local -n SHIM_ROOT_DIR_REF="CLI_SHIM_ROOT_DIR_${CLI_NAME^^}"

        # SOURCE_PATH
        ::cli::path::make_absolute::inline "$1"
        local SOURCE_PATH="${REPLY}"
        shift

        # REL_PATH
        local REL_PATH="${SOURCE_PATH##"${SHIM_ROOT_DIR_REF}/"}"
        (( ${#REL_PATH} < ${#SOURCE_PATH} )) \
            || cli::assert "Source path '${SOURCE_PATH}' is not a subpath of '${SHIM_ROOT_DIR_REF}'." 

        # COMMAND
        local IFS=/
        local -a COMMAND=( ${CLI_NAME} ${REL_PATH} )
        IFS=${CLI_IFS}

        set "${COMMAND[@]}" "$@"

        # epilog
        unset REL_PATH
        unset SOURCE_PATH
        unset COMMAND
        unset -n SHIM_ROOT_DIR_REF

        # post conditions
        [[ -v CLI_NAME ]] || cli::assert

        "$@" 
    }
}
inline

# public
cli::export() {
    cli::loader::emit::variables "$@"
    cli::loader::emit::functions "$@"
}

cli::help() {
    echo
    echo 'Global Arguments'
    echo '    --help -h        [Flag] : Show this message and exit.'
    echo '    --self-test      [Flag] : Runs a self test.'
}

cli::import() {
    (( $# > 0 )) || cli::assert 'Missing import.'
    
    CLI_IMPORT+=( "$*" )

    ::cli::shim::source::inline "$1" \
        || cli::assert "Failed to find shim '$1' for import of '$*'."

    "$@" ---import
}

# loader library
cli::loader::emit::functions() {
    cli::loader::function::list "$@" \
        | while read; do 
            declare -f "${REPLY}"
        done
}

cli::loader::emit::variables() {
    local DECLARE FLAGS VALUE

    cli::loader::variable::list "$@" \
        | while read DECLARE FLAGS VALUE; do
            echo "declare ${FLAGS}g ${VALUE}" 
        done
}

cli::loader::emit::imports() {
    ::cli::bash::printf::inline 'cli::import %s\n' "$@"
}

cli::loader::function::list() {
    local GLOB

    for i in "$@"; do 
        GLOB+="${i}::"
    done
    GLOB+='*'

    ::cli::bash::function::list::inline "${GLOB}"
}

cli::loader::variable::list() {
    local -u GLOB

    for i in "$@"; do 
        GLOB+="${i^^}_"; 
    done

    cli::dump "${GLOB}*"
}

cli::loader::cache::bgen() {

    # allow hard coded metadata of logic that is itself necessary to parse help
    ! ::cli::bash::function::is_declared::inline cli::meta::declare \
        || cli::assert 'Custom metadata deprecated'

    [[ ! "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata should have not been declared outside of cli::meta::declare."

    # test cache 
    # cli::log "BGEN ${CLI_COMMAND[@]} -> ${CLI_LOADER_BGEN_PATH}"
    if ! ::cli::cache::test::inline "${CLI_LOADER_BGEN_PATH}"; then

        # generate (like ngen)
        cli::loader::dsl::bgen \
            | ::cli::cache::put::inline "${CLI_LOADER_BGEN_PATH}"
    fi
}

cli::loader::cache::path() {
    ::cli::cache::path::inline "${CLI_SOURCE}"
    REPLY="${REPLY}/$1"
}

cli::loader::cache::test() {
    cli::loader::cache::path "$@"
    ::cli::cache::test::inline "${REPLY}" "${CLI_SOURCE}"
}

# loader core
cli::loader::import_parent() {
    local command=( "${CLI_COMMAND[@]}" )

    # no hierarchy
    if (( ${#command[@]} < 2 )); then 
        return
    fi

    # group
    if [[ "${command[@]: -1}" == '.group' ]]; then

        # root has no parent command; (e.g. 'cli .group')
        if (( ${#command[@]} == 2 )); then 
            return
        fi

        # slice off '.group'; (e.g. 'cli util .group' => 'cli util')
        command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" )
    fi

    # slice off last command and append '.group'
    command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" '.group' )

    # check no variables exist that should be imported with this group
    ::cli::bash::array::pop::inline "${command[@]}"

    if ::cli::set::test::inline CLI_LOADER_IMPORTED "${command[*]}"; then
        return
    fi

    if ! diff <( cli::export "${MAPFILE[@]}" ) - < /dev/null > /dev/null; then
        echo "Attempt to import '${command[@]}' but variables already defined:" >&2
        cli::export "${MAPFILE[@]}" | sed 's/^/  /' >&2
        cli::assert "${MAPFILE[@]}"
    fi

    # import parent
    # echo "${CLI_COMMAND[@]} -> ${command[@]}" >&2
    "${command[@]}" ---import >&2
}

cli::loader::backpatch() {

    ::cli::name::to_inline::inline "${CLI_COMMAND[@]}"
    set "${REPLY}"

    ::cli::bash::function::is_declared::inline "$1" \
        || cli::assert "No stub '$1' found to backpatch."

    # unset stub
    unset -f "$1"

    # backpatch stub
    cli::loader::source::exports

    ::cli::bash::function::is_declared::inline "$1" \
        || cli::assert "Failed to backpatch stub '$1'."
}

cli::loader::import() {

    if ! ::cli::set::deflower::inline CLI_LOADER_IMPORTED "${CLI_COMMAND[*]}"; then
        return
    fi

    # loader
    [[ ! "${CLI_COMMAND[@]}" == 'cli loader' ]] \
        || cli::assert 'Importing the loader is disallowed.'

    cli::loader::import_parent

    ::cli::name::to_inline::inline "${CLI_COMMAND[@]}"
    local FUNCTION=${REPLY}

    # skip if inline function already imported
    if ::cli::bash::function::is_declared::inline "${FUNCTION}"; then

        # this happens when:
        #   1. the loader declares functions it is also importing which it does 
        #       because the loader cannot load it's own dependencies.
        #   2. two libraries A and B both import inline function I and
        #       A emits the thunk for I and then B goes to emit the same thunk for I
        #   3. recursive calls of an inline function
        return
    fi

    # get import type (e.g. command, inline, ...)
    ${CLI_COMMAND[@]} ---type > /dev/null
    local TYPE="${REPLY}"

    # emit inline stub
    if [[ "${TYPE}" == 'inline' ]]; then
        eval "${FUNCTION}() { ${CLI_COMMAND[@]} ---backpatch; ${FUNCTION} \"\$@\"; }"
        ::cli::bash::function::is_declared::inline "${FUNCTION}" || cli::assert
        return
    fi

    # standard 
    if [[ -f "${CLI_SOURCE}" ]]; then

        # source the import!
        cli::loader::source::exports

    # missing-group
    else
        [[ "${CLI_TYPE}" == 'group' ]] || cli::assert
    fi
}

cli::loader::source::exports() {

    if ! cli::loader::cache::test 'exports.sh'; then 
        ${CLI_COMMAND[@]} ---exports > /dev/null
    fi

    cli::loader::cache::path 'exports.sh'
    cli::loader::source "${REPLY}"
}

cli::loader::source() {
    ::cli::path::make_absolute::inline "$1"
    set "${REPLY}"

    if ! ::cli::set::deflower::inline CLI_LOADER_SOURCED_PATHS "$1"; then
        return
    fi

    [[ -f "$1" ]] || cli::assert "File missing. Cannot source path '$1'."
    source "$1"
}

cli::loader::shim() {

    # error handling should work before doing anything
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---assert')
                    cli::assert ;;
                '---subshell-assert')
                    ( cli::assert ) ;;
                '---err')
                    err() { return 1; }; err ;;
                '---subshell-err')
                    err() { return 1; }; ( err; ) ;;
                *)
                    break ;;
            esac
            return
        done
    fi

    # CLI_NAME
    [[ -v CLI_NAME ]] || cli::assert "Shim failed to define CLI_NAME."
    set "${CLI_NAME}" "$@"

    # CLI_COMMAND
    ::cli::name::parse::inline "$@"
    local -a CLI_COMMAND=( "${MAPFILE[@]}" )
    shift ${#CLI_COMMAND[@]}
    [[ "${CLI_COMMAND}" == "${CLI_NAME}" ]] || cli::assert

    # CLI_SOURCE
    ::cli::shim::which::inline "${CLI_COMMAND[@]}" \
        || cli::assert "Failed to find shim for '${CLI_COMMAND[@]}'."
    local CLI_SOURCE="${REPLY}"

    # CLI_META
    ::cli::name::to_symbol::inline "${CLI_COMMAND[@]}"
    local CLI_META="CLI_META_${REPLY}"

    # CLI_TYPE
    local CLI_TYPE=command
    if [[ "${CLI_COMMAND[@]: -1}" == '.group' ]]; then
        CLI_TYPE=group
        [[ ! -f "${CLI_SOURCE}" || -x "${CLI_SOURCE}" ]] \
            || cli::assert "Source file '${CLI_SOURCE}' for command '${CLI_COMMAND[*]}' is not executable."
    else
        [[ -f "${CLI_SOURCE}" ]] \
            || cli::assert "Source file '${CLI_SOURCE}' for command '${CLI_COMMAND[*]}' does not exist."

        [[ -x "${CLI_SOURCE}" ]] \
            || cli::assert "Source file '${CLI_SOURCE}' for command '${CLI_COMMAND[*]}' is not executable."
    fi

    # CLI_FUNCTION_MAIN
    ::cli::name::to_main::inline "${CLI_COMMAND[@]}"
    local CLI_FUNCTION_MAIN="${REPLY}"

    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---print') 
                    cat "${CLI_SOURCE}" ;;
                '---which') 
                    echo "${CLI_SOURCE}" ;;
                '---import')
                    cli::loader::import ;;
                '---backpatch')
                    cli::loader::backpatch ;;
                *)
                    break ;;
            esac
            return
        done
    fi

    # CLI_IMPORT_MY_FOO_COMMAND
    ::cli::name::to_symbol::inline "${CLI_COMMAND[@]}"
    local REF="CLI_IMPORT_${REPLY}"
    declare -a "${REF}=()"
    local -n CLI_IMPORT=${REF}

    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---exports')
                    if ! cli::loader::cache::test 'exports.sh'; then 
                        break
                    fi
                    echo "${REPLY}" ;;
                '---type')
                    if ! cli::loader::cache::test 'type.sh'; then
                        if ! [[ ${CLI_COMMAND[@]: -1} == '.group' ]]; then
                            break
                        fi
                        ::cli::cache::put::inline "${REPLY}" <<< 'group'
                    fi
                    read < "${REPLY}"
                    echo "${REPLY}" ;;
                *)
                    break ;;
            esac
            return
        done
    fi

    cli::main::thunk "$@"
}

cli::main::thunk() {
    
    # optimization; skip creating subshell if we are the root
    if (( ${#CLI_COMMAND_STACK[@]} == 0 )); then
        cli::main::prolog "$@"
        return
    fi

    # skip creating subshell if we are invoking an inline function
    if [[ "${1-}" == '---' ]] \
        || [[ "${1-}" == '---reply' ]] \
        || [[ "${1-}" == '---mapfile' ]]; then
        cli::main::prolog "$@"
        return
    fi

    ( cli::main::prolog "$@" )
}

cli::main::prolog() {

    # $0
    BASH_ARGV0="${CLI_SOURCE}"

    # reset bash variables
    IFS="${CLI_IFS}"

    # establish frame
    # local -A CLI_SCOPE=(
    #     [CLI_NAME]='string'
    #     [CLI_COMMAND]='array'
    #     [CLI_IMPORT]='array'
    # )

    # stack
    local -a CLI_COMMAND_STACK=( "${CLI_COMMAND_STACK[@]}" "${CLI_COMMAND[*]}" )

    cli::main::source "$@"
}

cli::main::source() {
    cli::loader::import_parent

    # unset -f help
    # unset -f self_test

    # source the code!
    cli::loader::source "${CLI_SOURCE}"

    # update CLI_TYPE if the source is an inline function
    ::cli::name::to_inline::inline "${CLI_COMMAND[@]}"
    if ::cli::bash::function::is_declared::inline ${REPLY}; then
        CLI_TYPE=inline
        local CLI_FUNCTION_INLINE="${REPLY}"
    
        if ! ::cli::bash::function::is_declared::inline 'main'; then
            main() { ${CLI_FUNCTION_INLINE} "$@"; }
        fi
    fi

    # imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---type')
                    ! cli::loader::cache::test 'type.sh' || cli::assert
                    ::cli::cache::put::inline "${REPLY}" <<< ${CLI_TYPE}
                    echo "${CLI_TYPE}" ;;
                '---exports')
                    ! cli::loader::cache::test 'exports.sh' || cli::assert
                    cli::main \
                        | ::cli::cache::put::inline "${REPLY}"
                    echo "${REPLY}" ;;
                '---dependencies')
                    cli imports -c "${CLI_COMMAND[@]}" ;;
                *) break ;;
            esac 
            return
        done
    fi

    cli::main "$@"
}

cli::main::help() {

    # -h anywhere (except after --) prints help and exits
    while (( $# > 0 )); do
        case "$1" in
            '--') 
                break ;;
            '-h') ;& '--help')
                ::cli::bash::function::is_declared::inline 'help' \
                    || cli::assert "Unexpected missing 'help' in '${CLI_COMMAND[@]}'."
                help 
                cli::help
                return ;;
        esac
        shift
    done

    return 1
}

cli::main() {
    
    [[ -v CLI_NAME ]] || cli::assert
    [[ -v CLI_TYPE ]] || cli::assert
    [[ -v CLI_COMMAND ]] || cli::assert

    # help
    if cli::main::help "$@"; then
        return
    fi

    # imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---imports')
                    for i in "${CLI_IMPORT[@]}"; do echo "${i}"; done ;;
                *) break ;;
            esac 
            return
        done
    fi

    # self test
    if [[ "${1-}" == '--self-test' ]]; then
        ::cli::bash::function::is_declared::inline 'self_test' \
            || cli::assert "Unexpected missing 'self_test' in '${CLI_COMMAND[@]}'."
        self_test
        return
    fi

    # inline
    if [[ "${CLI_TYPE}" == 'inline' ]]; then
        cli::main::inline "$@"

    # group
    elif [[ "${CLI_TYPE}" == 'group' ]]; then
        cli::main::group "$@"

    # command
    else
        [[ "${CLI_TYPE}" == 'command' ]] || cli::assert
        cli::main::command "$@"
    fi
}

cli::main::group() {
    [[ "${CLI_COMMAND[@]: -1}" == '.group' ]] || cli::assert

    (( $# == 0 )) \
        || cli::assert "Unexpected arguments passed to '${CLI_COMMAND[*]}': $@"

    if cli::loader::cache::test 'exports.sh'; then 
        cat "${REPLY}"
        return
    fi

    ::cli::bash::function::is_declared::inline main \
        || cli::assert "Command '${CLI_COMMAND[@]}' missing entrypoint 'main'."

    main "$@"
}

cli::main::inline() {
    [[ "${CLI_FUNCTION_INLINE}" ]] || cli::assert

    # well-known options that require imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---function')
                    declare -f ${CLI_FUNCTION_INLINE} ;;
                '---source')
                    shift
                    source /dev/stdin
                    if [[ "${1-}" == ---* ]]; then continue; else break; fi ;;
                '---reply')
                    shift
                    cli::main::inline -- "$@"
                    echo "${REPLY-}" ;;
                '---mapfile')
                    shift
                    cli::main::inline -- "$@"
                    for REPLY in "${MAPFILE[@]}"; do
                        echo "${REPLY-}" 
                    done ;;
                '---pipe')
                    shift
                    while read -a MAPFILE; do cli::main::inline -- "$@" "${MAPFILE[@]}"; done ;;
                '---') 
                    break ;;
                *) cli::assert "Unexpected unknown internal option \"$1\" for command '${CLI_COMMAND[*]}'."
            esac 
            return
        done
    fi

    if (( $# > 0 )); then
        if [[ "${1-}" == '--' ]] \
            || [[ "${1-}" == '---' ]]; then
            shift
        fi

        if ::cli::bash::function::is_declared::inline ${CLI_FUNCTION_MAIN}; then
            ${CLI_FUNCTION_MAIN} "$@"
        else
            ${CLI_FUNCTION_INLINE} "$@"
        fi

        return
    fi

    # emit dependencies and function
    cli::loader::emit::imports "${CLI_IMPORT[@]}"
    declare -f ${CLI_FUNCTION_INLINE}
}

cli::main::command::load() {
    if cli::loader::cache::test 'meta.sh'; then
        cli::loader::source "${REPLY}"
        return
    fi
    local META_SH="${REPLY}"
    
    cli::loader::cache::path 'help'
    mkdir -p "${REPLY}"

    local HELP="${REPLY}/help"
    local TOKENIZE="${REPLY}/tokenize"
    local PARSE="${REPLY}/parse"
    local META="${REPLY}/meta"
    local LOAD="${REPLY}/load"

    if [[ -f "${HELP}" ]] && diff "${HELP}" <( cli::main -h ) > /dev/null; then
        cli::loader::source "${META_SH}"
        return
    fi

    cli::main -h > "${HELP}"
    cli dsl tokenize < "${HELP}" > "${TOKENIZE}"
    cli dsl parse < "${TOKENIZE}" > "${PARSE}"
    cli dsl meta < "${PARSE}" > "${META}"
    cli dsl load -- < "${META}" > "${LOAD}"

    local ARG_SCOPE=CLI_SCOPE

    ARG_TYPE='cli_meta'
        ::cli::core::variable::declare::inline ${CLI_META}

    ::cli::core::variable::read::inline ${CLI_META} < "${LOAD}"

    ::cli::core::emit::global::inline ${CLI_META} > "${META_SH}"
}

cli::main::command() {

    # parsing
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---tokenize')
                    cli::loader::dsl::tokenize ;;
                '---parse')
                    cli::loader::dsl::parse ;;
                '---meta')
                    cli::loader::dsl::meta ;;
                '---load')
                    cli::loader::dsl::load ;;
                '---bgen')
                    cli::loader::dsl::bgen ;;
                '---wire')
                    cli::loader::dsl::wire ;;
                '---wire-bash')
                    cli::loader::dsl::wire_bash ;;
                *) break ;;
            esac 
            return
        done
    fi

    # bgen metadata
    # cli::loader::cache::bgen
    # if [[ -f "${CLI_LOADER_BGEN_PATH-}" ]]; then
    #     source "${CLI_LOADER_BGEN_PATH}"
    # fi

    # well-known options that require loaded metadata
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---env')
                    declare -p ;;
                '---import')
                    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
                        echo "${CLI_LOADER_BGEN_PATH}"
                    fi
                    ;;
                *) break ;;
            esac 
            return
        done
    fi

    if ::cli::set::test::inline CLI_KNOWN_COMMANDS "${CLI_COMMAND[*]}"; then
        cli::main::command::known "$@"
        return
    fi

    cli::main::command::load

    ARG_SCOPE=CLI_SCOPE \
        ::cli::dispatch::parse::inline "$@"
    local CLI_META_GROUP=${REPLY}

    # declare locals for group
    local -A CLI_SCOPE_LAST=()
    local -n CLI_META_GROUP_TYPE=${CLI_META_GROUP}_TYPE
    for REPLY in ${!CLI_META_GROUP_TYPE[@]}; do

        # variable name
        local NAME=${REPLY}
        ::cli::name::to_symbol::inline ${NAME}
        local VARIABLE="ARG_${REPLY}"

        # variable flags
        local TYPE="${CLI_META_GROUP_TYPE[${NAME}]}"
        ::cli::core::type::to_bash::inline ${TYPE}
        local FLAGS="${REPLY}"

        # declare variable
        local -${FLAGS} ${VARIABLE}
        
        # prolog
        CLI_SCOPE_LAST[${VARIABLE}]=CLI_SCOPE[${VARIABLE}]
        CLI_SCOPE[${VARIABLE}]="${TYPE}"

        # initialize variable
        if ::cli::set::test::inline REPLY_CLI_PARSE_ARGS_NAMED ${NAME}; then
            local -n VARIABLE_REF=${VARIABLE}
            local -n VALUE_REF="REPLY_CLI_PARSE_ARGS_NAMED_${REPLY_CLI_PARSE_ARGS_NAMED[${NAME}]}"
            case ${TYPE} in
                'array') VARIABLE_REF=( "${VALUE_REF[@]}" ) ;;
                'map')
                    local PAIR
                    for PAIR in "${VALUE_REF[@]}"; do
                        VARIABLE_REF[${PAIR%%=*}]="${PAIR#*=}"
                    done
                    ;;
                *) VARIABLE_REF="${VALUE_REF}" ;;
            esac
        else
            # default value
            ARG_SCOPE=CLI_SCOPE \
                ::cli::core::variable::initialize::inline ${VARIABLE}
        fi

        # declare -p ${VARIABLE} >&2
    done
    unset TYPE NAME VARIABLE FLAGS PAIR
    unset -n VARIABLE_REF VALUE_REF

    # cli::dump 'REPLY_CLI_PARSE_ARGS_*' >&2

    cli::main::command::dispatch "${REPLY_CLI_PARSE_ARGS_POSITIONAL[@]}"

    # epilog
    for REPLY in ${!CLI_SCOPE_LAST[@]}; do
        CLI_SCOPE[${REPLY}]=CLI_SCOPE_LAST[${REPLY}]
    done
}

cli::main::command::known() {
    ARG_HELP=false
    ARG_SELF_TEST=false
    CLI_ARGS_POSITIONAL=( "$@" )

    cli::main::command::dispatch "$@"
}

cli::main::command::dispatch() {

    # well-known options that require loaded arguments
    while [[ "${1-}" == ---* ]]; do
        case "$1" in
            '---args-tokenize')
                cli::write CLI_TOKENS ;;
            '---args-load')
                cli::write CLI_ARGS ;;
            '---args')
                cli::dump 'ARG_*' ;;
            '---cli')
                cli::dump 'CLI_*' ;;
            '---read')
                shift
                while read -a REPLY; do ${CLI_FUNCTION_MAIN} "$@" "${REPLY[@]}"; done ;;
            *) cli::fail "Unexpected unknown internal option \"$1\"."
        esac 
        return
    done

    # well known features
    if [[ -n "${ARG_RUN_AS-}" ]] \
        && [[ ! "${ARG_RUN_AS}" == "$(whoami)" ]]; then
        arg_user="${ARG_RUN_AS}" \
        arg_command="$0" \
            ::cli::run_as::inline "$@"
        return
    fi

    ::cli::bash::function::is_declared::inline ${CLI_FUNCTION_MAIN} \
        || cli::assert "Command '${CLI_COMMAND[@]}' missing entrypoint '${CLI_FUNCTION_MAIN}'."
    ${CLI_FUNCTION_MAIN} "$@"
}

cli::dump() {
    ::cli::bash::variable::emit::inline "$@"
}

cli::loader::dsl::tokenize() { cli::main -h | cli dsl tokenize; }
cli::loader::dsl::parse() { cli::loader::dsl::tokenize | cli dsl parse; }
cli::loader::dsl::meta() { cli::loader::dsl::parse | cli dsl meta; }
cli::loader::dsl::load() { cli::loader::dsl::meta | cli dsl load --; }
cli::loader::dsl::bgen() { cli::loader::dsl::load -- | cli dsl bgen; }
cli::loader::dsl::wire() { cli::loader::dsl::load -- | cli core wire load -- CLI_META cli_meta | sort -u; }
cli::loader::dsl::wire_bash() { cli::loader::dsl::wire | cli core wire read | sort -u; }

loader_source() {

    alias_inline_import() {
        local COMMAND="$1"
        local ALIAS="${2-}"

        if [[ ! "${ALIAS}" ]]; then
            ::cli::name::to_bash::inline ${COMMAND}
            ::cli::bash::join::inline '::' "${MAPFILE[@]}"
            ALIAS="${REPLY}" 
        fi

        ::cli::name::to_inline::inline ${COMMAND}
        eval "${ALIAS}() { ${REPLY} \"\$@\"; }"
    }

    diff_import_then_export_as() {
        local COMMAND="$1"
        shift
        
        local ALIAS="$1"
        shift

        diff_import "${COMMAND}" "$@"
        alias_inline_import "${COMMAND}" "${ALIAS}"
    }

    diff_import_then_export() {
        diff_import "$@"
        alias_inline_import "$1"
    }

    diff_import() {
        cli::import $1

        if [[ -n "${CLI_LOADER_IMPORT_DISABLE-}" ]]; then
            while (( $# > 0 )); do 
                CLI_LOADER_IMPORTED[$1]=true
                shift
            done

            return
        fi

        local COMMAND="$1"
        shift

        # capture existing function
        ::cli::name::to_inline::inline ${COMMAND}
        FQN="${REPLY}"

        ::cli::bash::function::is_declared::inline ${FQN} \
            || cli::assert "Expected ${FQN} to be inlined into loader."
        local EXISTING_FUNCTION=$(
            cli::loader::emit::imports "$@"
            declare -f ${FQN}
        )

        # assert exiting function matches inlined function
        # echo "${COMMAND}" >&2
        local DIFF=$(diff <(echo "${EXISTING_FUNCTION}") $(${COMMAND} ---exports) || true)
        # echo "${COMMAND}" >&2

        if [[ -n "${DIFF}" ]]; then

            ::cli::shim::which::inline ${COMMAND}
            echo "EXISTING_FUNCTION != INLINE_FUNCTION, FQN=${FQN}, ${REPLY}"
            echo "to disable check declare -x CLI_LOADER_IMPORT_DISABLE=1"
            
            echo "---diff---"
            echo "${DIFF}"

            echo "---existing---"
            echo "${EXISTING_FUNCTION}"

            # capture inline function    
            echo "---inline---"
            local INLINE_FUNCTION
            INLINE_FUNCTION=$(${COMMAND}) \
                || cli::assert "Expected command '${COMMAND}' to export inline function."
            echo "${INLINE_FUNCTION}"
            exit 1
        fi >&2
    }

    # these functions pre-imported because the import logic itself depends on them
    diff_import 'cli set test'
    diff_import 'cli set deflower' \
        'cli set test'

    diff_import_then_export 'cli path name'
    diff_import_then_export 'cli path dir'
    diff_import_then_export 'cli path make-absolute'

    diff_import 'cli subshell signal-group'
    diff_import 'cli subshell on-exit'

    diff_import_then_export 'cli temp remove'
    diff_import_then_export 'cli temp file' \
        'cli temp remove' \
        'cli subshell on-exit'
    diff_import_then_export 'cli temp dir' \
        'cli temp file'

    diff_import_then_export 'cli temp fifo' \
        'cli temp file'

    diff_import_then_export 'cli cache test'
    diff_import_then_export 'cli cache path' \
        'cli path dir' \
        'cli path name'
    diff_import_then_export 'cli cache put' \
        'cli path dir' \
        'cli temp file'

    diff_import_then_export_as 'cli stderr lock' 'cli::lock'
    diff_import 'cli stderr cat' \
        'cli stderr lock' \
        'cli temp file'
    diff_import 'cli stderr dump' \
        'cli stderr cat' \
        'cli subshell signal-group'
    diff_import_then_export_as 'cli stderr assert' 'cli::assert' \
        'cli stderr dump' \
        'cli bash stack trace'
    diff_import_then_export_as 'cli stderr fail' 'cli::fail' \
        'cli stderr dump'
    diff_import 'cli stderr on-err' \
        'cli stderr dump' \
        'cli bash stack trace'

    diff_import 'cli bash array pop'
    diff_import 'cli bash map copy' \
        'cli set test'
    
    diff_import 'cli bash filter glob'
    diff_import 'cli bash function list' \
        'cli bash filter glob'
    diff_import_then_export_as 'cli bash which' 'cli::which'
    diff_import_then_export_as 'cli bash log' 'cli::log'
    diff_import 'cli bash printf'
    diff_import_then_export_as 'cli bash return' 'cli::return'
    diff_import_then_export_as 'cli bash join' 'cli::join'
    diff_import_then_export_as 'cli bash literal' 'cli::literal'
    diff_import 'cli bash function is-declared'

    diff_import 'cli name parse'
    diff_import_then_export 'cli name to-bash'
    diff_import 'cli name to-inline' \
        'cli name to-bash' \
        'cli bash join'
    diff_import 'cli name to-main' \
        'cli name to-bash' \
        'cli bash join'
    diff_import_then_export 'cli name to-symbol' \
        'cli name to-bash' \
        'cli bash join'

    diff_import_then_export 'cli attribute is-defined'
    diff_import_then_export_as 'cli bash stack call' 'cli::stacktrace' \
        'cli bash literal' \
        'cli attribute is-defined'
    diff_import 'cli bash stack process'
    diff_import 'cli bash stack trace' \
        'cli bash stack process' \
        'cli bash stack call'

    diff_import 'cli shim source' \
        'cli bash which' \
        'cli bash function is-declared'
    diff_import 'cli shim which' \
        'cli shim source'
    diff_import_then_export_as 'cli shim shebang' 'cli::shebang' \
        'cli path make-absolute' \
        'cli path name' \
        'cli shim source'

    # cli::import cli bash array pop
    diff_import 'cli bash variable list'
    diff_import 'cli bash variable emit' \
        'cli bash variable list'

    cli::import cli core variable declare
    cli::import cli core variable read
    cli::import cli core emit global

    cli::import cli dispatch parse

    # cli::import cli run-as

    # cli::import cli core type is-builtin
    # cli::import cli core type is-modified
    # cli::import cli core type is-scaler
    # cli::import cli core type is-user-defined
    # cli::import cli core type unmodified
    # cli::import cli core type unmodify
    
    # cli::import cli core variable declare

    # cli::import cli core declare
    # cli::import cli core load
    # cli::import cli core save
    # cli::import cli core write

    # cli::import cli args tokenize
    # cli::import cli args parse
    # cli::import cli args initialize
    # cli::import cli args emit

    # cli::import cli name to-bash
    # cli::import cli core struct emit

    cli::loader::main() {
        echo "set -$-"
        echo

        declare -p CLI_IFS
        echo

        shopt -p | sort -k2 -k3
        echo

        #cli::loader::emit::variables cli | sort -k4
        {
            (
                CLI_LOADER_SOURCED_PATHS=()
                CLI_COMMAND_STACK=()
                CLI_SCOPE=()

                declare -p CLI_LOADER_SOURCED_PATHS
                declare -p CLI_COMMAND_STACK
                declare -p CLI_SCOPE
            )
            declare -p CLI_LOADER_IMPORTED
            declare -p CLI_LOADER_LOCK

            cli::loader::emit::variables cli regex
            cli::loader::emit::variables cli known
            cli::loader::emit::variables cli type
            cli::loader::emit::variables cli bgen
            cli::loader::emit::variables cli arg
            cli::loader::emit::variables cli meta attributes

        } | sort -k2 -k3
        echo

        echo '# cli core'
        cli::export cli core
        echo

        echo '# TOC of cli::*'
        cli::loader::function::list cli | sed 's/^/# /'
        echo 

        cli::loader::emit::functions cli
        echo

        declare -f cli
        declare -f loader_source
        echo

        (( ${#CLI_IMPORT_CLI_LOADER[@]} > 0 )) || cli::assert

        printf '%s\n' "${CLI_IMPORT_CLI_LOADER[@]}" \
            | sort -u \
            | mapfile -t
        printf '# cli::import %s\n' "${MAPFILE[@]}"
        echo

        for import in "${MAPFILE[@]}"; do
            ::cli::name::to_inline::inline ${import}
            echo "${REPLY}" 
        done | mapfile -t
        # printf '# %s\n' "${MAPFILE[@]}"
        # echo

        printf '%s\n' "${MAPFILE[@]}" \
            | while read; do eval "declare -f ${REPLY}"; done

        trap -p
        echo
    }

    self_test() {
        local -A disabled=(
            ['cli subshell signal-group']=true
            ['cli stderr dump']=true
            ['cli stderr assert']=true
            ['cli stderr fail']=true
            ['cli bash stack call']=true
            ['cli bash stack process']=true
            ['cli bash stack trace']=true
            ['cli core declare']=true
            ['cli core load']=true
            ['cli core save']=true
            ['cli core write']=true
            ['cli args tokenize']=true
            ['cli args parse']=true
            ['cli args initialize']=true
            ['cli args emit']=true
        )

        for i in "${CLI_IMPORT_CLI_LOADER[@]}"; do
            if ::cli::set::test::inline disabled "$i"; then continue; fi
            echo $i
            $i --self-test
        done

        echo -- disabled --
        printf '%s\n' "${!disabled[@]}" | sort
        
    }
}

cli::initialize() {

    # ${bash_source[1]} '.cli/loader/exports.sh'
    # ${bash_source[2]} the command itself
    declare -g CLI_LOADER_COMMAND_PATH="${BASH_SOURCE[1]}"
    ::cli::cache::path::inline "${CLI_LOADER_COMMAND_PATH}"
    declare -g CLI_LOADER_CACHE_DIR="${REPLY}"

    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
}

trap '::cli::stderr::on_err::inline $?' ERR

cli::assert() {
    ::cli::stderr::assert::inline "$@"
}

cli::initialize

# shim
source "$( cd $(dirname ${BASH_SOURCE}); cd ..; pwd)/cli"
::cli::bash::function::is_declared::inline 'cli' || cli::assert
[[ -v CLI_SHIM_ROOT_DIR_CLI ]] || cli::assert

cli loader "$@"
