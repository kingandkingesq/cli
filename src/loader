#!/usr/bin/env bash
help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

set -e
set -u 
set -o pipefail
shopt -s lastpipe

declare CLI_LOADER_DIR="${BASH_SOURCE%/*}"

cli::loader::is_declared() {
    if declare -F "$1" > /dev/null; then true; else false; fi
}

cli::loader::escape_args_then_call_as() {
    local user=$1
    shift

    local -a args
    for i in "$@"; do
        args+=( $(printf %q "${i}") )
    done

    sudo su "${user}" -c "${args[*]}"
}

cli::loader::dry_run() {
    if [[ "${arg_dry_run:-}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:-}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:-}" == "true" ]]; then set +x; fi
    fi
}

cli::loader::cache::load() {
    declare -g CLI_LOADER_SOURCE_PATH="$1"
    declare -g CLI_LOADER_SOURCE_NAME="${CLI_LOADER_SOURCE_PATH##*/}"
    declare -g CLI_LOADER_SOURCE_DIR="${CLI_LOADER_SOURCE_PATH%/*}"
    declare -g CLI_LOADER_CACHE_DIR="${CLI_LOADER_SOURCE_DIR}/.cli/${CLI_LOADER_SOURCE_NAME}"

    declare -g CLI_LOADER_INITIALIZE_PATH="${CLI_LOADER_CACHE_DIR}/initialize.sh"
    declare -g CLI_LOADER_BINDINGS_PATH="${CLI_LOADER_CACHE_DIR}/bindings.sh"
    declare -g CLI_LOADER_IMPORTS_SOURCE_PATH="${CLI_LOADER_CACHE_DIR}/imports.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"

    if [[ ! -d "${CLI_LOADER_CACHE_DIR}" ]]; then
        mkdir -p "${CLI_LOADER_CACHE_DIR}"
    fi
}

cli::import() {
    CLI_LOADER_IMPORTS+=( "$*" )
}

cli::import_group() {
    cli::import ${CLI_DIR} .group
}

cli::loader::cache::put() {
    arg_cache="$1" \
        ::cli::cache::put::inline
}

cli::loader::cache::test() {
    arg_cache="$1" \
    arg_source="${CLI_LOADER_SOURCE_PATH}" \
        ::cli::cache::test::inline
}

cli::loader::cache::exports() {
    if ! cli::loader::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then
        "$0" | cli::loader::cache::put "${CLI_LOADER_EXPORTS_PATH}"
    fi
}

cli::loader::cache::initialize() {

    # initialize hard coded
    if cli::loader::is_declared initialize; then

        # cache empty result
        if [[ ! -f "${CLI_LOADER_INITIALIZE_PATH}" ]]; then
            : > "${CLI_LOADER_INITIALIZE_PATH}"
        fi

    # initialize not cached OR cache out of date 
    elif ! cli::loader::cache::test "${CLI_LOADER_INITIALIZE_PATH}"; then

        # lazily generated (like JIT)
        "$0" '--help' \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl emit \
            | cli::loader::cache::put "${CLI_LOADER_INITIALIZE_PATH}"
    fi
}

cli::loader::cache::test::bindings() {
    local cached=true
    local path=

    # deserialize bindings
    source "${CLI_LOADER_BINDINGS_PATH}"

    for import in "${!bindings[@]}"; do
        path=${bindings["$import"]}

        # if an import is newer than the cache, then the cache is stale OR
        # if an import does not resolve to the cached path, then the cache is stale
        if [[ "${path}" -nt "${CLI_LOADER_BINDINGS_PATH}" ]] ||
            [[ ! "$(${import} ---which)" == "${path}" ]]; then
            cached=false
            break
        fi
    done

    ${cached}
}

cli::loader::cache::bindings() {
    local -A bindings=()
    local import
    local path

    while [[ -n ${CLI_LOADER_IMPORTS[@]} ]]; do
        import="${CLI_LOADER_IMPORTS[0]}"

        # capture the mappting from import to path
        path=$(${import} '---which')
        bindings+=( [${import}]="${path}" )

        # capture transitivie imports by executing 
        # the source generated by the import
        ${path} ---exports \
            | source /dev/stdin

        # pop this import
        CLI_LOADER_IMPORTS=( "${CLI_LOADER_IMPORTS[@]:1}" )
    done 
        
    # serialize mapping of imports to paths
    declare -p bindings
}

cli::loader::cache::imports() {
    local import
    local path
    local -A bindings

    # if source has been refreshed since the cli was executed, the cache is ok
    if declare -p CLI_LOADER_IMPORTS_EXPIRATION_PATH >/dev/null 2>&1; then
        if [[ "${CLI_LOADER_IMPORTS_EXPIRATION_PATH}" -ot \
              "${CLI_LOADER_IMPORTS_SOURCE_PATH}" ]]; then
              return
        fi
    fi

    if cli::loader::cache::test "${CLI_LOADER_BINDINGS_PATH}" &&
        cli::loader::cache::test::bindings; then

        touch "${CLI_LOADER_BINDINGS_PATH}"
        touch "${CLI_LOADER_IMPORTS_SOURCE_PATH}"
        return
    fi

    # generate and read cached bindings (e.g. map from inports to paths)
    cli::loader::cache::bindings \
        | source /dev/stdin

    for import in "${!bindings[@]}"; do
        path="${bindings["${import}"]}"

        # emit library
        echo \#
        echo \# ${import} '->' "${path}"
        echo \#
        ${path}
        echo
    done \
        | cli::loader::cache::put "${CLI_LOADER_IMPORTS_SOURCE_PATH}"

    # cache the bindings *after* updating the imports to prevent 
    # a race between checking the cache and updating the cache
    declare -p bindings > "${CLI_LOADER_BINDINGS_PATH}"
}

cli::loader::source::imports() {
    cli::loader::cache::imports
    source "${CLI_LOADER_IMPORTS_SOURCE_PATH}"
}

cli::loader::source::initialize() {
    cli::loader::cache::initialize
    source "${CLI_LOADER_INITIALIZE_PATH}"
}

cli::loader::execute() {

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::loader::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args

        if cli::loader::is_declared main; then
            main "${arg_[@]}"

        elif cli::loader::is_declared export; then
            export
            
        else
            echo "Unexpected missing entry point 'main' or 'export'."
            exit 1
        fi
    fi
}

cli::loader::self_test() {
    self_test
    result=$?
    if ! (( ${result} == 0 )); then
        read line file < <(caller)
        echo "Self-test failed: ${file}"
    fi
    exit ${result}
}

cli::load() {

     if cli::loader::is_declared export; then
        CLI_LOADER_IMPORTS+=( \
            'cli emit export' \
            'cli emit initialize' \
        )
    fi

    case "${1-}" in
        '---inline')
            cli emit inline \
                --name "$(cli path join --delimiter '::' -- ${CLI_PATH})::inline" \
                --path "${CLI_LOADER_SOURCE_PATH}"
            exit
            ;;
        '---which') 
            echo "${CLI_LOADER_SOURCE_PATH}"
            exit
            ;;
        '---print') 
            cat "${CLI_LOADER_SOURCE_PATH}"
            exit
            ;;
        '---imports')
            cli::loader::cache::imports
            source "${CLI_LOADER_BINDINGS_PATH}"
            for i in "${!bindings[@]}"; do echo "${i} -> ${bindings[$i]}"; done
            exit
            ;;
        '---initialize')
            cli::loader::source::imports
            cli::loader::cache::initialize
            cat "${CLI_LOADER_INITIALIZE_PATH}"
            exit
            ;;
        '---exports')
            cli::loader::cache::exports
            cat "${CLI_LOADER_EXPORTS_PATH}"
            exit
            ;;
    esac 

    cli::loader::source::imports

    for i in "$@"; do
        case "${i}" in
            '--') break ;;
            '-h') ;& '--help')
            help
            exit
        esac
    done
    unset i

    case "${1-}" in
        '--self-test')
            cli::loader::self_test
            exit
        ;;
    esac 

    cli::loader::source::initialize
    cli::loader::execute "$@"
}

main() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    echo 'set -o pipefail'
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    echo "declare -a CLI_LOADER_IMPORTS"

    declare -f cli::import
    declare -f cli::import_group
    declare -f cli::load

    declare -f cli::loader::dry_run
    declare -f cli::loader::escape_args_then_call_as
    declare -f cli::loader::execute
    declare -f cli::loader::self_test

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::initialize() {

            # hard coded
            if declare -F initialize > /dev/null; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::initialize
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else

        declare -f cli::loader::cache::test
        declare -f cli::loader::cache::put

        declare -f cli::loader::is_declared
        declare -f cli::loader::cache::load
        declare -f cli::loader::cache::test::bindings
        declare -f cli::loader::cache::initialize
        declare -f cli::loader::cache::imports
        declare -f cli::loader::cache::exports
        declare -f cli::loader::cache::bindings
        declare -f cli::loader::source::imports
        declare -f cli::loader::source::initialize

        declare -f ::cli::cache::put::inline
        declare -f ::cli::cache::test::inline

        echo
        echo "cli::loader::cache::load \"\${BASH_SOURCE[1]}\""
  fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) echo "Unexpected argument '$1'."; exit 1 ;;
        esac

        shift
    done
}

declare -a CLI_LOADER_IMPORTS
cli::loader::cache::load ${BASH_SOURCE}

cat "${BASH_SOURCE%/*}/emit/inline" \
    | {
        while true; do
            read -r
            if [[ "${REPLY}" == 'main() {' ]]; then
                echo "::cli::inline::inline() {"
                while true; do 
                    read -r
                    echo "${REPLY}"
                    if [[ ${REPLY} == '}' ]]; then
                        exit
                    fi
                done
            fi
        done
    } \
    | source /dev/stdin
        
inline() {
    arg_name="::cli::$1::inline" \
    arg_path="${CLI_LOADER_DIR}/$2" \
        ::cli::inline::inline \
        | source /dev/stdin
}

inline 'cache::put' 'cache/put'
inline 'cache::test' 'cache/test'

if (( $# == 0 )); then
    if ! cli::loader::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then
        : ${arg_pack:=false}
        main | cli::loader::cache::put "${CLI_LOADER_EXPORTS_PATH}"
    fi
    echo "${CLI_LOADER_EXPORTS_PATH}"
    exit
fi

cli::load "$@"
