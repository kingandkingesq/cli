#!/usr/bin/env bash
help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::main'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

set -e
set -u 
set -o pipefail
shopt -s lastpipe

# cache
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_DIR="${BASH_DIR}/.cli/${BASH_NAME}"
declare EXPORTS_PATH="${CACHE_DIR}/exports.sh"
if [[ -f "${EXPORTS_PATH}" ]] \
    && [[ "${EXPORTS_PATH}" -nt "${BASH_SOURCE}" ]]; then
    echo "${EXPORTS_PATH}"
    exit
fi

declare CLI_REGEX_NAME="^[a-z.][a-z0-9-]*$"
declare CLI_REGEX_FLAGS="^[a-z]+$"
declare CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"

declare CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
declare CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
declare CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
declare CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
declare CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

declare -A CLI_TYPE_CLI_META=( \
    [require]="map" \
    [default]="map" \
    [regex]="map" \
    [positional]="boolean" \
    [implicit_value]="map" \
    [alias]="map" \
    [allow]="map_of map" \
    [type]="map" \
)
declare -A CLI_TYPE_CLI_META_TABLES=(
    [require]="map_of map" \
    [default]="map_of map" \
    [regex]="map_of map" \
    [positional]="map_of boolean" \
    [implicit_value]="map_of map" \
    [alias]="map_of map" \
    [allow]="map_of map_of map" \
    [type]="map_of map" \
)
declare -A CLI_TYPE_CLI_ARGS=( \
    [path]="array" \
    [named]="map" \
    [positional]="array" \
)
: ${CLI_COMMAND:=${BASH_SOURCE##*/}}


cli::loader::inline() {
    : ${arg_name?'Unexpected lack of inline function name.'}
    : ${arg_function:='inline'}

    (
        local -a imports=()

        # disable loader
        cli() { echo '/dev/null'; }
        cli::main() { return; }
        cli::import() { return; }
        cli::import_group() { return; }
        cli::import_parent_group() { return; }

        # capture imports upon which the inlined function depends
        cli::import_inline() {
            imports+=( "$*" )
        }

        # source file
        source '/dev/stdin'

        # emit dependencies
        if (( ${#imports[@]} > 0 )); then
            printf 'cli::import %s\n' "${imports[@]}"
        fi

        # emit and rename function
        declare -f ${arg_function} | { 
            read
            echo "${arg_name} ()"
            cat
        }
    )
}

cli::loader::import_inline() {
    inline() {
        arg_name="::cli::$1::inline" \
            cli::loader::inline < "${BASH_DIR}/$2" \
            | source /dev/stdin
    }

    inline 'bash::emit' 'bash/emit'
    inline 'bash::write' 'bash/write'
    inline 'bash::callstack' 'bash/callstack'
    inline 'bash::fail' 'bash/fail'
    inline 'bash::is_function_declared' 'bash/is-function-declared'

    inline 'core::declare' 'core/declare'
    inline 'core::load' 'core/load'
    inline 'core::save' 'core/save'
    inline 'core::write' 'core/write'

    inline 'core::variable::declare' 'core/variable/declare'
    inline 'core::variable::initialize' 'core/variable/initialize'
    inline 'core::variable::put' 'core/variable/put'

    inline 'core::struct::define' 'core/struct/define'
    inline 'core::struct::define_field' 'core/struct/define-field'
    inline 'core::struct::emit' 'core/struct/emit'
   
    inline 'core::type::is_builtin' 'core/type/is-builtin'
    inline 'core::type::is_modified' 'core/type/is-modified'
    inline 'core::type::is_scaler' 'core/type/is-scaler'
    inline 'core::type::is_user_defined' 'core/type/is-user-defined'
    inline 'core::type::unmodify' 'core/type/unmodify'

    inline 'cache::put' 'cache/put'
    inline 'cache::test' 'cache/test'
    inline 'cache::path' 'cache/path'

    inline 'name::to_bash' 'name/to-bash'

    inline 'path::join' 'path/join'

    inline 'args::parse' 'args/parse'
    inline 'args::tokenize' 'args/tokenize'
    inline 'args::emit' 'args/emit'

    inline 'run_as' 'run-as'
}

# debug
cli::trap() {
    if (( $? == 0 )); then return; fi
    ::cli::bash::callstack::inline \
        | sed 's/^/    /' >&2
}

cli::dump() {
    ::cli::bash::emit::inline "$@"
}

cli::assert() {
    if ! eval "$1"; then
        cli::fail "Failed assert '$1'."
    fi
}

cli::fail() {
    arg_message="$@" \
        ::cli::bash::fail::inline
}

cli::check::condition() {
    if ! eval "$1"; then
        cli::fail "${@:2}"
    fi
}

cli::check::regex() {
    if [[ ! "$1" =~ $2 ]]; then
        cli::fail "${@:3}" "'$1' does not match regex '$2'."
    fi
}

# import
cli::import() {
    CLI_LOADER_IMPORTS+=( "$*" )
}

cli::import_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local group="${segments[@]:0:$(( length - 1 ))}"
    cli::import ${group} .group
}

cli::import_parent_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local parent_group="${segments[@]:0:$(( length - 2 ))}"
    cli::import ${parent_group} .group
}

cli::import_inline() {
    cli::import "$*"
}

# export
cli::export::functions() {
    local glob

    for i in "$@"; do 
        glob+="${i}::"
    done

    while read keyword flags name; do
        if [[ "${name}" == ${glob}* ]]; then
            declare -f "${name}"
        fi
    done < <(declare -F)
}

cli::export::variable() {
    while (( $# > 0 )); do
        declare -p "$1" \
            | sed 's/^declare/declare -g/'
        shift
    done
}

cli::export::variables() {
    local -u glob

    for i in "$@"; do 
        glob+="${i}_"; 
    done

    for i in $(eval echo "\${!${glob}@}"); do
        cli::export::variable "${i}"
    done
}

cli::export::variable::merge() {
    cli::export::variable "$@" \
        | sed 's/=/+=/'
}

cli::export() {
    cli::export::variables "$@"
    cli::export::functions "$@"
}

cli::export::import() {
    echo "cli::import $@"
}

cli::export::import_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local group="${segments[@]:0:$(( length - 1 ))}"
    echo "cli::import ${group} .group"
}

cli::export::import_parent_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local parent_group="${segments[@]:0:$(( length - 2 ))}"
    echo "cli::import ${parent_group} .group"
}

# core
cli::define() {
    arg_name=${1:-${CLI_STRUCT_DEFAULT_NAME}} \
        ::cli::core::struct::define::inline
}

cli::define_field() {
    arg_type="$1" \
    arg_name="$2" \
    arg_struct=${3:-${CLI_STRUCT_DEFAULT_NAME}} \
        ::cli::core::struct::define_field::inline
}

cli::declare() {
    arg_type="${1:-${CLI_STRUCT_DEFAULT_NAME}}" \
    arg_name="${2:-${CLI_STRUCT_DEFAULT_VARIABLE}}" \
    arg_read=false \
    arg_print=false \
        ::cli::core::declare::inline
}

cli::put() {
    arg_name="${1:-${CLI_STRUCT_DEFAULT_VARIABLE}}" \
    arg_read=false \
    arg_print=false \
    arg_type= \
        ::cli::core::declare::inline "${@:2}"
}

cli::print() {
    arg_name="${1:-${CLI_STRUCT_DEFAULT_VARIABLE}}" \
    arg_read=false \
    arg_print=true \
    arg_type= \
        ::cli::core::declare::inline
}

cli::read() {
    arg_name="${1:-${CLI_STRUCT_DEFAULT_VARIABLE}}" \
    arg_read=true \
    arg_print=false \
    arg_type= \
        ::cli::core::declare::inline
}

cli::write() {
    arg_name="${1:-${CLI_STRUCT_DEFAULT_VARIABLE}}" \
    arg_type="${2:-}" \
        ::cli::core::write::inline
}

cli::save() {
    arg_dir="${1-}" \
        ::cli::core::save::inline
}

cli::load() {
    arg_dir="${1-}" \
        ::cli::core::load::inline
}

#cache
cli::loader::cache::load() {
    declare -g CLI_LOADER_COMMAND_PATH="$1"
    declare -g CLI_LOADER_CACHE_DIR="$(arg_path="${CLI_LOADER_COMMAND_PATH}" \
        ::cli::cache::path::inline)"
    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
    declare -g CLI_LOADER_METADATA_PATH="${CLI_LOADER_CACHE_DIR}/metadata.sh"
}

cli::cache::test() {
    arg_cache="$1" \
    arg_source="${CLI_LOADER_COMMAND_PATH}" \
        ::cli::cache::test::inline
}

cli::loader::cache::exports() {
    if ! cli::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then
        # declarative; e.g. inline
        if arg_name=inline ::cli::bash::is_function_declared::inline; then
            arg_name="$(cli path join --delimiter '::' -- ${CLI_COMMAND})::inline" \
            arg_function='inline' \
                cli::loader::inline \
                < "${CLI_LOADER_COMMAND_PATH}"
        
        # procedural; e.g library
        else
            "$0" 
        fi \
        | arg_cache="${CLI_LOADER_EXPORTS_PATH}" \
            ::cli::cache::put::inline
    fi
}

cli::loader::cache::bgen() {
    # hard coded
    if [[ -n ${CLI_SCOPE[CLI_META]+set} ]]; then
        return 
    fi

    # test cache 
    if ! cli::cache::test "${CLI_LOADER_BGEN_PATH}"; then

        # generate (like ngen)
        "$0" '--help' \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl meta \
            | cli dsl bgen --print \
            | arg_cache="${CLI_LOADER_BGEN_PATH}" \
                ::cli::cache::put::inline
    fi
}

cli::loader::load::imports() {
    local import_path=
    local exports_path=
    local -a import=()
    local -A imported=()
    local -A base_path=()
    local -a export_paths=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORTS[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORTS[i]} )

        # if import previously seen, continue
        if ${imported[${import[@]}]-false}; then
            continue
        fi
        imported[${import[@]}]=true

        # if base path not resolved
        if [[ -z "${base_path[$import]-}" ]]; then

            # resolve base path
            base_path[${import}]=$(${import} '---which')

            # if cli still not resolved, fail
            if [[ -z "${base_path[${import}]}" ]]; then
                cli::fail "Failed to resolve import \"${import[@]}\"."
            fi
        fi

        import_path=$(arg_delimiter='/' arg_base=${base_path[${import}]} \
            ::cli::path::join::inline "${import[@]:1}")
        exports_path="$(arg_path=${import_path} \
            ::cli::cache::path::inline)/exports.sh"

        # if import codegen cache stale
        if ! arg_cache="${exports_path}" \
            arg_source="${import_path}" \
                ::cli::cache::test::inline; then

            # refresh import codegen cache
            ${import[@]} '---exports' > /dev/null
        fi

        # source the exports to gather imports only (ignore declare)
        declare() { return; }
        source "${exports_path}"
        unset declare

        export_paths+=( "${exports_path}" )
    done

    # source exports in reverse order so that dependencies are sourced first
    for (( i=1; i<=${#export_paths[@]}; i++ )); do
        export_path="${export_paths[@]: -$i:1}"
        source "${export_path}"
    done

    # manual imports
    if arg_name=import ::cli::bash::is_function_declared::inline; then
        import
    fi
}

cli::loader::initialize() {
    cli::assert "[[ -n \"\${CLI_SCOPE[CLI_META]+set}\" ]]"

    cli::declare cli_args CLI_ARGS

    arg_args=CLI_ARGS \
        ::cli::args::tokenize::inline "$@"
    
    arg_args=CLI_ARGS \
    arg_meta=CLI_META \
        ::cli::args::parse::inline
    
    arg_prefix='arg' \
    arg_args=CLI_ARGS \
        ::cli::args::emit::inline
}

cli::loader::execute() {

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )

    # explict initialize() overrides declarative 'help' based initialize
    if arg_name=initialize ::cli::bash::is_function_declared::inline; then
        initialize "$@"
    else
        cli::loader::initialize "$@"
    fi

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        arg_user="${arg_run_as}" \
        arg_command="$0" \
            ::cli::run_as::inline "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args

        if arg_name=main ::cli::bash::is_function_declared::inline; then
            main "${arg_[@]}"

        elif arg_name=inline ::cli::bash::is_function_declared::inline; then
            inline "${arg_[@]}"

        elif arg_name=export ::cli::bash::is_function_declared::inline; then
            export
            
        else
            cli::fail "Unexpected missing entry point 'main' or 'export'."
        fi
    fi
}

cli::loader::self_test() {
    set +e
    (set -e; self_test)
    result=$?
    set -e

    if ! (( ${result} == 0 )); then
        read line subroutine file < <(caller 1)
        echo "Self-test for '${file}' failed with '${result}'."
    fi

    cli::trap() { return; }
    exit ${result}
}

cli::main() {

    # well-known options
    if [[ "${1-}" == ---* ]]; then
        case "$1" in
            '---type')
                echo 'command' ;;
            '---which') 
                echo "${CLI_LOADER_COMMAND_PATH}" ;;
            '---print') 
                cat "${CLI_LOADER_COMMAND_PATH}" ;;
            '---imports')
                for i in "${CLI_LOADER_IMPORTS[@]}"; do echo "${i}"; done ;;
            '---dependencies')
                cli imports -c "${CLI_COMMAND}" ;;
            '---load')
                "$0" '---bgen' | read; cat "${REPLY}" ;;
            '---emit')
                "$0" '---exports' | read; cat "${REPLY}" ;;
            '---exports')
                cli::loader::cache::exports
                echo "${CLI_LOADER_EXPORTS_PATH}"
                ;;
            *) 
                cli::loader::load::imports
                case "$1" in
                    '---bgen')
                        cli::loader::cache::bgen
                        if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
                            echo "${CLI_LOADER_BGEN_PATH}"
                        fi
                        ;;
                    '---tokenize')
                        help | cli dsl tokenize ;;
                    '---parse')
                        help | cli dsl tokenize | cli dsl parse ;;
                    '---meta')
                        help | cli dsl tokenize | cli dsl parse | cli dsl meta ;;
                    '---foo')
                        help | cli dsl tokenize | cli dsl parse | cli dsl meta | cli dsl bgen ;;
                    *) cli::fail "Unexpected internal option \"$1\"."
                esac 
            esac 
        exit
    fi

    cli::loader::load::imports

    # help and self-test
    for i in "$@"; do
        case "${i}" in
            '--') 
                break ;;
            '-h') ;& '--help')
                help; exit ;;
            '--self-test')
                cli::loader::self_test; exit ;;
        esac
    done
    unset i

    cli::loader::cache::bgen
    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
        source "${CLI_LOADER_BGEN_PATH}"
    fi

    cli::loader::execute "$@"
}

main() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    echo 'set -o pipefail'
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 

    # enables BASH_ARGC and BASH_ARGV
    echo 'shopt -s extdebug'
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    echo "declare -A CLI_SCOPE=()"
    echo "declare -a CLI_LOADER_IMPORTS=()"
    echo ": \${CLI_COMMAND:=\${BASH_SOURCE[1]##*/}}"
    echo
    echo "trap cli::trap EXIT"
    echo

    declare -p CLI_REGEX_NAME
    declare -p CLI_REGEX_FLAGS
    declare -p CLI_REGEX_BASH_NAME
    echo

    declare -p CLI_REGEX_VARIABLE_NAME
    declare -p CLI_REGEX_STRUCT_NAME
    declare -p CLI_REGEX_STRUCT_FIELD_NAME
    declare -p CLI_REGEX_TYPE_NAME
    declare -p CLI_REGEX_GLOBAL_NAME
    echo

    declare -p CLI_TYPE_CLI_META
    declare -p CLI_TYPE_CLI_META_TABLES
    declare -p CLI_TYPE_CLI_ARGS
    echo

    declare -f cli::trap
    declare -f cli::fail
    declare -f cli::check::condition
    declare -f cli::check::regex
    declare -f cli::assert
    declare -f cli::dump
    declare -f cli::main
    echo

    declare -f cli::export
    declare -f cli::export::import
    declare -f cli::export::import_group
    declare -f cli::export::import_parent_group
    declare -f cli::export::variable
    declare -f cli::export::variable::merge
    declare -f cli::export::variables
    declare -f cli::export::functions
    echo

    declare -f cli::import
    declare -f cli::import_group
    declare -f cli::import_parent_group
    declare -f cli::import_inline
    echo

    declare -f cli::define
    declare -f cli::define_field
    declare -f cli::declare
    declare -f cli::print
    declare -f cli::read
    declare -f cli::write
    declare -f cli::put
    declare -f cli::save
    declare -f cli::load
    echo

    declare -f cli::loader::execute
    declare -f cli::loader::self_test
    echo

    declare -f ::cli::core::declare::inline
    declare -f ::cli::core::load::inline
    declare -f ::cli::core::save::inline
    declare -f ::cli::core::write::inline
    echo

    declare -f ::cli::core::variable::declare::inline
    declare -f ::cli::core::variable::initialize::inline
    declare -f ::cli::core::variable::put::inline
    echo

    declare -f ::cli::core::struct::define::inline
    declare -f ::cli::core::struct::define_field::inline
    declare -f ::cli::core::struct::emit::inline
    echo

    declare -f ::cli::core::type::is_builtin::inline
    declare -f ::cli::core::type::is_modified::inline
    declare -f ::cli::core::type::is_scaler::inline
    declare -f ::cli::core::type::is_user_defined::inline
    declare -f ::cli::core::type::unmodify::inline
    echo

    declare -f ::cli::name::to_bash::inline
    echo

    declare -f ::cli::run_as::inline
    echo

    declare -f ::cli::args::tokenize::inline
    declare -f ::cli::args::parse::inline
    declare -f ::cli::args::emit::inline
    echo

    declare -f ::cli::path::join::inline
    echo
    
    declare -f ::cli::cache::test::inline
    declare -f ::cli::cache::path::inline
    declare -f ::cli::cache::put::inline
    echo
    
    declare -f ::cli::bash::emit::inline
    declare -f ::cli::bash::write::inline
    declare -f ::cli::bash::fail::inline
    declare -f ::cli::bash::callstack::inline
    declare -f ::cli::bash::is_function_declared::inline
    echo

    declare -f cli::cache::test
    echo

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::bgen() {

            # hard coded
            if [[ -n ${CLI_SCOPE[CLI_META]+set} ]]; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::bgen
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else

        declare -f cli::loader::cache::load
        declare -f cli::loader::cache::bgen
        declare -f cli::loader::cache::exports
        echo

        declare -f cli::loader::load::imports
        declare -f cli::loader::initialize
        declare -f cli::loader::inline
        echo

        # ${bash_source[0]} is '.cli/exports.sh' which is called by
        # ${bash_source[1]} which is the command itself 
        echo
        echo "cli::loader::cache::load \"\${BASH_SOURCE[1]}\""
  fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) cli::fail "Unexpected argument '$1'." ;;
        esac

        shift
    done
}

self_test() {
    diff \
        <(arg_name=say_hi \
            cli::loader::inline \
            <<< "source \$(cli loader); inline() { echo 'hi'; }; cli::main") \
        <(echo $'say_hi ()\n{ \n    echo \'hi\'\n}')
}

declare -A CLI_SCOPE=()
declare -a CLI_LOADER_IMPORTS=()
cli::loader::import_inline
CLI_LOADER_IMPORTS=()

cli::loader::cache::load ${BASH_SOURCE}

# common case
if (( $# == 0 )); then
    : ${arg_pack:=false}
    main | arg_cache="${CLI_LOADER_EXPORTS_PATH}" \
        ::cli::cache::put::inline
    echo "${CLI_LOADER_EXPORTS_PATH}"
    exit
fi

cli::main "$@"
