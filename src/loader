#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli

Summary
    The shim.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

# supress background processes from displaying their exit status upon completion.
# see https://mywiki.wooledge.org/BashFAQ/024
set +m

# see https://dougrichardson.us/notes/fail-fast-bash-scripting.html
set -e
shopt -s inherit_errexit

set -u
set -o pipefail

set -E
set -o functrace

# run the last segment of a pipeline in the current execution process, not a subshell.
# see https://mywiki.wooledge.org/BashFAQ/024
shopt -s lastpipe

# If set, the pattern ‘**’ used in a filename expansion context will match all 
# files and zero or more directories and subdirectories. If the pattern is followed 
# by a ‘/’, only directories and subdirectories match.
shopt -s globstar

# If the extglob shell option is enabled using the shopt builtin, 
# several extended pattern matching operators are recognized. 
shopt -s extglob

# If set, Bash allows filename patterns which match 
# no files to expand to a null string, rather than themselves.
shopt -s nullglob

# enables BASH_ARGC and BASH_ARGV
shopt -s extdebug

# optimization
main() {
    if [[ ! "${1-}" == '---exports' ]]; then
        return
    fi

    local exports_path="$(cd $(dirname $0); pwd)/.cli/loader/exports.sh"
    if [[ ! -f "${exports_path}" || "$0" -nt "${exports_path}" ]]; then
        return
    fi

    echo "${exports_path}"
    exit
}
main "$@"
unset main

# lock
readonly CLI_IFS="$IFS"
readonly CLI_LOCK_FILE="${CLI_LOCK_FILE-/tmp/.cli_lock}"

# debug
declare CLI_STACK_SHOW_PROCESS
declare CLI_STACK_SHOW_HIDDEN

# regex
readonly REGEX_NAME="[a-z.][a-z0-9-]*"
readonly CLI_REGEX_NAME="^${REGEX_NAME}$"
readonly CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"
readonly CLI_REGEX_PROPERTY_ARG="^(${REGEX_NAME})=(.*)$"
readonly CLI_REGEX_BASH_FUNCTION="^[:a-z_][:a-z0-9_]*$"

readonly CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
readonly CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
readonly CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

# types
readonly -A CLI_TYPE_CLI_META_TABLES=(
    # TODO: remove?
    [alias]="map"
    [type]="map_of map"
    [require]="map_of map"
    [default]="map_of map"
    [regex]="map_of map"
    [allow]="map_of map_of map"
    [positional]="map_of boolean" \
)
readonly -A CLI_TYPE_CLI_META_GROUP=(
    [type]="map"
    [bash_type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
readonly -A CLI_TYPE_CLI_META=(
    [alias]="map"
    [bash_name]="map"
    [group]="map_of cli_meta_group"
    #[attributes]="map_of cli_meta_attributes"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTE=(
    [type]="array"
    [blob]="array"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTES=(
    [method]="map_of cli_meta_attribute"
)
readonly -A CLI_TYPE_CLI_TOKENS=(
    [id]="array"
    [identifier]="array"
)
readonly -A CLI_TYPE_CLI_ARGS=(
    [path]="array"
    [first_named]="string"
    [named]="map_of array"
    [positional]="array"
)
readonly -A CLI_TYPE_CLI_BASH_STACK_HIDDEN_ATTRIBUTE=()

# tokens
readonly -a CLI_ARG_TOKEN=(
    [0]="PATH"
    [1]="VALUE"
    [2]="DASH"
    [3]="DASH_DASH"
    [4]="DASH_DASH_DASH"
    [5]="END_OPTIONS"
    [6]="EOF"
)
readonly CLI_ARG_TOKEN_PATH="0"
readonly CLI_ARG_TOKEN_VALUE="1"
readonly CLI_ARG_TOKEN_DASH="2"
readonly CLI_ARG_TOKEN_DASH_DASH="3"
readonly CLI_ARG_TOKEN_DASH_DASH_DASH="4"
readonly CLI_ARG_TOKEN_END_OPTIONS="5"
readonly CLI_ARG_TOKEN_EOF="6"

# productions
readonly -a CLI_ARG_PRODUCTION=(
    [0]="SEGMENT"
    [1]="OPTION"
    [2]="POSITIONAL"
)
readonly CLI_ARG_PRODUCTION_SEGMENT="0"
readonly CLI_ARG_PRODUCTION_OPTION="1"
readonly CLI_ARG_PRODUCTION_POSITIONAL="2"

# attributes
declare -A CLI_META_ATTRIBUTES_METHOD=(
    ['::cli::bash::stack::call::inline']=0
    ['::cli::bash::stack::trace::inline']=0
    ['::cli::stderr::assert::inline']=0
    ['cli::assert']=0
    
    ['cli::main']=0
    ['cli::loader::shim']=0
    ['bash::main']=0

    # ['cli::trap::err']=0
)
readonly -a CLI_META_ATTRIBUTES_METHOD_0_TYPE=( 'cli_bash_stack_hidden_attribute' )
readonly -a CLI_META_ATTRIBUTES_METHOD_0_BLOB=()

# globals
declare -a CLI_LOADER_IMPORT=()
declare -A CLI_LOADER_IMPORTED=()
declare -A CLI_LOADER_SOURCED=()
declare -a CLI_LOADER_SOURCED_PATHS=()

# frame
declare -A CLI_SCOPE=(
    [CLI_IMPORT]='array'
)
declare -a CLI_IMPORT=()

# emulate bgen
bgen() {
    cli::bash::declare::type::cli_meta_tables() {
        cli::core::scope::add $1 CLI_META_TABLES

        cli::bash::declare \
            map $1_ALIAS \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_POSITIONAL \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_TYPE
    }
    cli::bash::declare::type::cli_meta_group() {
        cli::core::scope::add $1 CLI_META_GROUP

        cli::bash::declare \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_BASH_TYPE \
            map $1_TYPE \
            boolean $1_POSITIONAL
    }
    cli::bash::declare::type::cli_meta() {
        cli::core::scope::add $1 CLI_META

        cli::bash::declare \
            map $1_ALIAS \
            map $1_GROUP \
            map $1_BASH_NAME
    }
    cli::bash::declare::type::cli_meta_attributes() {
        cli::core::scope::add $1 CLI_META_ATTRIBUTES

        cli::bash::declare \
            map $1_TYPE \
            map $1_BLOB
    }
    cli::bash::declare::type::cli_tokens() {
        cli::core::scope::add $1 CLI_TOKENS

        cli::bash::declare \
            array $1_ID \
            array $1_IDENTIFIER
    }
    cli::bash::declare::type::cli_args() {
        cli::core::scope::add $1 CLI_ARGS

        cli::bash::declare \
            string $1_FIRST_NAMED \
            map $1_NAMED \
            array $1_PATH \
            array $1_POSITIONAL
    }

    declare -Ag CLI_BGEN_DECLARE=(
        [CLI_TYPE_CLI_META_TABLES]=cli::bash::declare::type::cli_meta_tables
        [CLI_TYPE_CLI_META_GROUP]=cli::bash::declare::type::cli_meta_group
        [CLI_TYPE_CLI_META]=cli::bash::declare::type::cli_meta
        [CLI_TYPE_CLI_META_ATTRIBUTES]=cli::bash::declare::type::cli_meta_attributes
        [CLI_TYPE_CLI_TOKENS]=cli::bash::declare::type::cli_tokens
        [CLI_TYPE_CLI_ARGS]=cli::bash::declare::type::cli_args
    )
}
bgen

import() {

    ::cli::attribute::is_defined::inline() {
        local target_type=${1-}; shift
        local target=${1-}; shift
        local type=${1-}; shift

        # expand assertion as more target types are needed
        [[ ${target_type} == 'METHOD' ]] || cli::assert

        # target identifies a method (or type, or command, or what-have-you)
        [[ ${target} != 'METHOD' ]] || \
            [[ ${target} =~ ${CLI_REGEX_BASH_NAME} ]] || cli::assert

        local -n targets="CLI_META_ATTRIBUTES_${target_type}"
        local index=${targets[${target}]:-}
        local -n ref="CLI_META_ATTRIBUTES_${target_type}_${index}_TYPE"

        # search the types of attributes decorating the target for a match
        for attribute in "${ref[@]}"; do
            if [[ "${attribute}" == "${type}" ]]; then
                return 0
            fi
        done

        return 1
    }

    ::cli::path::dir::inline() { 
        local -n REPLY_REF=$1
        REPLY_REF="$(dirname $2)"
    }

    ::cli::path::name::inline() { 
        local -n REPLY_REF=$1
        REPLY_REF="${2##*/}"; 
    }

    ::cli::path::make_absolute::inline() {
        local -n REPLY_REF=$1
        shift

        if [[ ! "${1-}" ]]; then
            REPLY_REF="${PWD}"

        elif [[ ! "$1" =~ ^/ ]]; then
            REPLY_REF="${PWD}/${1##./}"

        else
            REPLY_REF="$1"
        fi
    }

    ::cli::cache::path::inline() {
        local -n REPLY_REF=$1
        shift

        local name
        ::cli::path::name::inline name "$1"

        local dir
        ::cli::path::dir::inline dir "$1"

        REPLY_REF="${dir}/.cli/${name}"
    }

    ::cli::cache::put::inline() {
        local CACHE="$1"

        local DIR
        ::cli::path::dir::inline DIR "${CACHE}"
        mkdir -p "${DIR}"

        local TEMP
        ::cli::temp::file::inline TEMP
        cat > "${TEMP}"

        mv "${TEMP}" "${CACHE}"
    }

    ::cli::cache::test::inline() {
        local CACHE="$1"
        local SOURCE="$2"

        [[ -f "${CACHE}" ]] && [[ "${SOURCE}" -ot "${CACHE}" ]]
    }

    ::cli::stderr::lock::inline() {
        flock -x "${CLI_LOCK_FILE}" cat
    }

    ::cli::bash::log::inline() {
        echo "$@" >&2
    }

    ::cli::bash::which::inline() {
        local -n PATH_REF=$1
        shift

        local NAME="$1"
        shift

        local IFS=:
        local -a DIRS=( ${PATH} )

        for dir in "${DIRS[@]}"; do
            local PROBE="${dir}/${NAME}"
            [[ -f "${PROBE}" && -x "${PROBE}" ]] || continue
            PATH_REF="${PROBE}"
            return 0
        done

        return 1
    }

    ::cli::bash::return::inline() {
        return ${1-0}
    }

    ::cli::bash::join::inline() {
        local delimiter=${1?'Missing delimiter'}
        shift

        local -a segment=()
        while (( $# > 0 )); do
            segment+=( "$1" )
            shift
            if (( $# == 0 )); then break; fi
            segment+=( "${delimiter}" )
        done

        printf %s "${segment[@]}"
        echo
    }

    ::cli::bash::stack::call::inline() {
        
        # argument counts by frame
        set -- ${BASH_ARGV[@]}

        # bash stack
        local -i argc=0
        for (( i=0; i<${#FUNCNAME[@]}; i++ )); do
            local -a args=()
            local inline_args=''
            local funcname="${FUNCNAME[$i]}"

            if (( i == ${#FUNCNAME[@]}-1 )); then funcname='bash::main'; fi

            # reverse argv for i-th frame
            for (( j=${BASH_ARGC[$i]}-1; j>=0; j-- )); do
                args+=( "$(::cli::bash::literal::inline "${BASH_ARGV[${j}+${argc}]}")" )
            done

            # pop argc stack for i-th frame
            argc+=${BASH_ARGC[$i]}

            if [[ ! "${CLI_STACK_SHOW_HIDDEN-}" ]] \
                && ::cli::attribute::is_defined::inline \
                    'METHOD' "${funcname}" 'cli_bash_stack_hidden_attribute'; then
                continue
            fi

            # inline args when they won't disturb formatting
            inline_args="${args[@]}"
            if (( ${#inline_args} > 80 )); then
                inline_args=
            else
                args=()
            fi

            printf '%-50s %s:%s\n' \
                "${funcname} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-}

            for arg in "${args[@]}"; do
                echo "${arg}"
            done | sed 's/^/  /'
        done
    }

    ::cli::bash::stack::process::inline() {
        local ARG_START_PID=${1-$$}
        local ARG_END_PID=${2-${CLI_PID-}}

        # load process poset and associated command lines
        local -a pid_parent=()
        local -a pid_cmd=()
        while read pid ppid cmd; do
            pid_parent[${pid}]=${ppid}
            pid_cmd[${pid}]="${cmd}"
        done < <(ps -o pid=,ppid=,args=)

        # subprocess stack
        local pid=${BASHPID}
        local -a subshell=( ${BASHPID} )
        while (( $pid != $$ )); do
            echo "(${pid}) subshell"
            pid=${pid_parent[${pid}]}
        done

        # process stack
        local pid=${ARG_START_PID}
        for (( i=0; ${pid} > 0; i++ )); do

            echo -n "(${pid}) "
            local inline_args=${pid_cmd[${pid}]}
            if (( ${#inline_args} < 80 )); then
                echo "${inline_args}"
            else
                echo "${inline_args}" \
                    | sed -e $'s/--/\\\n  --/g'
            fi

            if (( ${pid} == ${ARG_END_PID-0} )); then break; fi
            pid=${pid_parent[${pid}]-0}
        done
    }

    ::cli::bash::stack::trace::inline() {
        ::cli::bash::stack::call::inline
        if [[ -n "${CLI_STACK_SHOW_PROCESS-}" ]]; then
            ::cli::bash::stack::process::inline
        fi
    }

    ::cli::bash::is_function_declared::inline() {
        if declare -F "${1-}" > /dev/null; then 
            true
        else 
            false
        fi
    }

    ::cli::bash::literal::inline() {
        local literal="$*"
        
        #echo "if [[ ! \"${literal}\" =~ ^[a-zA-Z_-]* ]]; then"
        if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
            echo "${literal}"
            return 0
        fi

        local ARRAY=( "$*" )
        literal=$(declare -p ARRAY)

        # 0123456789012345678901
        # declare -a ARRAY=([0]="foo")
        literal="${literal:22}"
        literal="${literal:0: -1}"

        echo "${literal}"
    }

    ::cli::bash::emit::inline() {
        for name in "$@"; do
            if [[ "${name}" =~ ^.*[*]$ ]]; then
                ::cli::bash::emit::inline $(eval "echo \${!${name}}")
            elif [[ -v "${name}" ]]; then
                declare -p "${name}"
            fi
        done
    }

    ::cli::bash::initialize::inline() {
        ::cli::bash::declare::inline "$@"

        while (( $# > 0 )); do

            local ARG_TYPE=$1
            shift

            local ARG_NAME=$1
            shift

            local -n ref=${ARG_NAME}
            case ${ARG_TYPE} in
                'integer') ref=0 ;;
                'array') ;&
                'map') ref=() ;;
                'boolean') ref='false' ;;
                'string') ref='' ;;
            esac
        done
    }

    ::cli::subshell::on_exit::inline() {
        local -ga "CLI_SUBSHELL_ON_EXIT_${BASHPID}+=()"
        local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID}

        if (( ${#CLI_SUBSHELL_ON_EXIT[@]} == 0 )); then
            cli::subshell::on_exit::trap() {
                local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID}
                for delegate in ${CLI_SUBSHELL_ON_EXIT[@]}; do
                    ${delegate}
                done
            }
            trap cli::subshell::on_exit::trap EXIT
        fi

        CLI_SUBSHELL_ON_EXIT+=( "$@" )
    }
        
    ::cli::temp::remove::inline() {

        local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}

        # unlink files/directories
        for FILE in "$@"; do
            if ! ${CLI_SUBSHELL_TEMP_FILE_BASHPID["${FILE}"]-}; then
                continue
            fi
            
            unset CLI_SUBSHELL_TEMP_FILE_BASHPID["${FILE}"]

            if [[ ! -a "${FILE}" ]]; then
                :
            elif [[ -d "${FILE}" ]]; then
                rm -f -r "${FILE}"
                rm -f -r "${FILE}"
            else
                rm -f "${FILE}"
            fi
        done
    }

    ::cli::temp::file::inline() {

        # create and return a temporary file
        local -n REPLY_REF=${1-'REPLY'}
        REPLY_REF=$(mktemp "${2-"${TMPDIR:-/tmp/}"}cli-XXXXXXXX")

        # record the temporary file 
        declare -gA "CLI_SUBSHELL_TEMP_FILE_${BASHPID}+=()"
        local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}

        # cleanup
        if (( ${#CLI_SUBSHELL_TEMP_FILE_BASHPID[@]} == 0 )); then
            ::cli::temp::file::on_exit() {

                # unlink files/directories
                local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
                ::cli::temp::remove::inline "${!CLI_SUBSHELL_TEMP_FILE_BASHPID[@]}"
            }

            ::cli::subshell::on_exit::inline \
                ::cli::temp::file::on_exit
        fi

        CLI_SUBSHELL_TEMP_FILE_BASHPID+=( ["${REPLY_REF}"]='true' )
    }

    ::cli::temp::dir::inline() {
        declare -n REPLY_REF=${1-'REPLY'}
        ::cli::temp::file::inline "$@"
        rm -f "${REPLY_REF}"
        mkdir "${REPLY_REF}"
    }

    ::cli::temp::fifo::inline() {
        declare -n REPLY_REF=${1-'REPLY'}
        ::cli::temp::file::inline "$@"
        rm -f "${REPLY_REF}"
        mkfifo "${REPLY_REF}"
    }

    ::cli::subshell::signal_group::inline() {
        local SIGNAL=${1-'SIGINT'}
        read PID < <(ps -p ${BASHPID} -o pgid=)
        kill -${SIGNAL} -${PID}
    }

    ::cli::stderr::cat::inline() {

        # create a temporary file
        ::cli::temp::file::inline

        # write to file instead of stderr so generator can take lock
        cat > "${REPLY}"

        # lock and copy file to stderr
        cat "${REPLY}" \
            | ::cli::stderr::lock::inline >&2 

        # cleanup
        rm "${REPLY}"
    }

    ::cli::stderr::dump::inline() {

        # copy stdin to stderr
        ::cli::stderr::cat::inline

        # issue control-c
        ::cli::subshell::signal_group::inline
    }

    ::cli::stderr::assert::inline() {
        if (( $# == 0 )); then 
            set 'Condition failed'
        fi

        {
            echo "ASSERT FAILED:" "$*"
            ::cli::bash::stack::trace::inline \
                | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }

    ::cli::stderr::fail::inline() {
        echo "$*" \
            | ::cli::stderr::dump::inline
    }

    ::cli::stderr::on_err::inline() {
        local -a CLI_PIPESTATUS=( "${PIPESTATUS[@]}" )
        local CLI_TRAP_EXIT_CODE=${1-'?'}
        local BPID="${BASHPID}"

        # only dump if we are exiting after the trap; e.g. errexit is set (set -e)
        #   -e  Exit immediately if a command exits with a non-zero status.
        if [[ ! $- =~ e ]]; then
            return
        fi

        {
            echo -n "TRAP ERR: exit=${CLI_TRAP_EXIT_CODE}"
            if (( ${#CLI_PIPESTATUS[@]} > 1 )); then
                echo -n ", pipe=[$(cli::join ',' "${CLI_PIPESTATUS[@]}")]"
            fi
            echo ", bpid=${BPID}, pid=$$"
            echo "BASH_COMMAND ERR: ${BASH_COMMAND}"

            ::cli::bash::stack::trace::inline | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }

    ::cli::shim::source::inline() {
        local NAME="$1"
        local SHIM_ROOT_DIR_NAME="CLI_SHIM_ROOT_DIR_${NAME^^}"

        if [[ ! -v "${SHIM_ROOT_DIR_NAME}" ]]; then
                
            local SHIM_PATH

            # resolve the path to the shim by searching PATH
            ::cli::bash::which::inline SHIM_PATH "$1" \
                || return 1
            
            # source the shim
            source "${SHIM_PATH}"

            # verify shim published the path to the root of its commands
            [[ -v "${SHIM_ROOT_DIR_NAME}" ]] \
                || cli::assert "Shim '$1' failed to define ${SHIM_ROOT_DIR_NAME}."

            # verify the shim published a function of the same name.
            ::cli::bash::is_function_declared::inline "${NAME}" \
                || cli::assert "Shim '$1' failed to define function ${NAME}."
        fi
    }

    ::cli::shim::which::inline() {
        local -n REPLY_REF=$1
        shift

        local NAME="$1"
        shift

        ::cli::shim::source::inline "${NAME}" \
            || return 1

        local -n SHIM_ROOT_DIR_REF="CLI_SHIM_ROOT_DIR_${NAME^^}"
        [[ "${SHIM_ROOT_DIR_REF-}" ]] || cli::assert

        local IFS=/
        REPLY_REF="${SHIM_ROOT_DIR_REF}/$*"
    }

    ::cli::shim::shebang::inline() {    
        [[ "${CLI_NAME}" ]] \
            || cli::assert "Shebang failed to declare 'CLI_NAME'." 

        ::cli::shim::source::inline "${CLI_NAME}" \
            || cli::assert "Shebang failed to find shim for cli '${CLI_NAME}'."

        local -n SHIM_ROOT_DIR_REF="CLI_SHIM_ROOT_DIR_${CLI_NAME^^}"

        local SOURCE_PATH
        ::cli::path::make_absolute::inline SOURCE_PATH "$1"
        shift

        local REL_PATH="${SOURCE_PATH##"${SHIM_ROOT_DIR_REF}/"}"
        (( ${#REL_PATH} < ${#SOURCE_PATH} )) \
            || cli::assert "Source path '${SOURCE_PATH}' is not a subpath of '${SHIM_ROOT_DIR_REF}'." 

        local IFS=/
        local -a CLI_COMMAND=( ${CLI_NAME} ${REL_PATH} )
        IFS=${CLI_IFS}

        ${CLI_COMMAND[@]} "$@" 
    }
}
import

declare_export() {

    cli::export::inline_function() {
        local name='::'
        for part in "${CLI_COMMAND[@]}"; do
            name+="${part//-/_}::"
        done
        name+='inline'

        cli::is_function_declared ${name} \
            || cli::assert "Expected '$0' to define 'main' or '${name}'."

        if [[ "${1-}" == '---' ]]; then
            shift
            ${name} "$@"
            return
        fi

        if (( ${#CLI_IMPORT[@]} > 0 )); then
            cli::loader::print::import "${CLI_IMPORT[@]}"
        fi

        declare -f ${name}
    }

    cli::export::functions::print() {
        local glob

        for i in "$@"; do 
            glob+="${i}::"
        done

        while read keyword flags name; do
            if [[ "${name}" == ${glob}* ]]; then
                echo "${name}"
            fi
        done < <(declare -F)
    }

    cli::export::functions() {
        cli::export::functions::print "$@" \
            | while read; do declare -f "${REPLY}"; done
    }

    cli::export::variable() {
        while (( $# > 0 )); do
            declare -p "$1" #| sed 's/^declare -/declare -g/'
            shift
        done
    }

    cli::export::variables() {
        local -u glob

        for i in "$@"; do 
            glob+="${i}_"; 
        done

        for i in $(eval echo "\${!${glob}@}"); do
            cli::export::variable "${i}"
        done
    }

    cli::export::variable::merge() {
        cli::export::variable "$@" \
            | sed 's/=/+=/'
    }

    cli::export() {
        cli::export::variables "$@"
        cli::export::functions "$@"
    }

    cli::export::import() {
        echo "cli::import $@"
    }
}
declare_export

declare_import() {
    cli::import::default() {
        cli::core::scope::add \
            CLI_META CLI_META

        cli::bash::declare \
            map CLI_META_BASH_NAME \
            map CLI_META_ALIAS \
            map CLI_META_GROUP \
            map CLI_META_GROUP_0_ALLOW \
            map CLI_META_GROUP_0_DEFAULT \
            map CLI_META_GROUP_0_REGEX \
            map CLI_META_GROUP_0_REQUIRE \
            map CLI_META_GROUP_0_TYPE \
            boolean CLI_META_GROUP_0_POSITIONAL

        CLI_META_BASH_NAME=(
            [help]="help"
            [self-test]="self_test"
        )
        CLI_META_ALIAS=(
            [h]="help" 
        )
        CLI_META_GROUP=(
            ["*"]="0" 
        )
        CLI_META_GROUP_0_TYPE=(
            [help]="boolean"
            [self-test]="boolean"
        )
    }

    cli::loader::import() {
        if ${CLI_LOADER_IMPORTED[ "$*" ]-false}; then
            return
        fi

        cli::import::parent "$*"

        CLI_LOADER_IMPORT+=( "$*" )
        CLI_LOADER_IMPORTED[ "$*" ]=true
    }

    cli::import() {
        CLI_IMPORT+=( "$*" )
        cli::loader::import "$*"
    }

    cli::import::parent() {

        local command=( "$@" )

        # no hierarchy
        if (( ${#command[@]} < 2 )); then return; fi

        # group
        if [[ "${command[@]: -1}" == '.group' ]]; then

            # root has no parent command; (e.g. 'cli .group')
            if (( ${#command[@]} == 2 )); then return; fi

            # slice off '.group'; (e.g. 'cli util .group' => 'cli util')
            command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" )
        fi

        # slice off last command and append '.group'
        command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" '.group' )

        # import ancestors
        cli::import::parent "${command[@]}"

        # import parent
        cli::loader::import "${command[@]}"
    }
}
declare_import

declare_core() {
    cli::core::scope::add() { CLI_SCOPE[$1]="$2"; }

    # Arguments when --print-struct
    #     --print-struct -s    [Flag] : Print structs
    #     --                          : Struct names

    # Arguments when --print
    #     --print -p           [Flag] : Print variables
    #     --                          : Variable names

    # Arguments when --type
    #     --type -t                   : Name of type
    #     --name -n        [Optional] : Name of variable
    #     --field -f     [Properties] : Fields of type
    #     --                          : Value

    cli::declare() {
        : ${1?}
        : ${2?}

        arg_type="$1" \
        arg_name="$2" \
        arg_read=false \
        arg_print=false \
            ::cli::core::declare::inline
    }

    cli::put() {
        : ${1:?}

        arg_name="$1" \
        arg_read=false \
        arg_print=false \
        arg_type= \
            ::cli::core::declare::inline "${@:2}"
    }

    cli::print() {
        : ${1:?}

        arg_name="$1" \
        arg_read=false \
        arg_print=true \
        arg_type= \
            ::cli::core::declare::inline
    }

    cli::read() {
        : ${1:?}

        arg_name="$1" \
        arg_read=true \
        arg_print=false \
        arg_type= \
            ::cli::core::declare::inline
    }

    cli::write() {
        : ${1:?}

        arg_name="$1" \
        arg_type="${2:-}" \
            ::cli::core::write::inline
    }

    cli::save() {
        arg_dir="${1-}" \
            ::cli::core::save::inline
    }

    cli::load() {
        arg_dir="${1-}" \
            ::cli::core::load::inline
    }
}
declare_core

# loader
cli::loader::to_bash() {
    local -n ARRAY_REF=$1
    shift

    while (( $# > 0 )); do
        [[ "$1" =~ ${CLI_REGEX_NAME} ]] || cli::assert \
            "Unexpected cli name \"$1\" does not match regex ${CLI_REGEX_NAME}."

        ARRAY_REF+=( "${1//[-.]/_}" )
        shift
    done
}

cli::loader::to_inline() {
    local -a BASH_NAMES=()
    cli::loader::to_bash BASH_NAMES "$@"

    ::cli::bash::join::inline '::' '' "${BASH_NAMES[@]}" 'inline'
}

cli::loader::inline() (

    # known case; 'cli loader' itself is not an inline command
    [[ ! "$@" == 'cli loader' ]] || exit 1

    local path="$("$@" ---which)"
    local fqn=$(cli::loader::to_inline "$@")

    local -a CLI_IMPORT=()
    local -a CLI_COMMAND=( $@ )

    # unset any pre-imported definition
    unset -f ${fqn}

    # capture imports upon which the inlined function depends
    cli::import() {
        CLI_IMPORT+=( "$*" )
    }

    # source file
    source "${path}"

    # emit nothing if no inlined function discovered
    ::cli::bash::is_function_declared::inline ${fqn} || exit 1

    # emit dependencies
    cli::loader::print::import "${CLI_IMPORT[@]}"

    # emit function
    declare -f ${fqn}
)

cli::loader::print::import() {
    if (( $# > 0 )); then
        printf 'cli::import %s\n' "$@"
    fi
}

cli::loader::exports() {

    # well known; if the command is 'cli loader', simply call main
    if [[ "$@" == 'cli loader' ]]; then
        main

    # declarative; print inline function
    elif ! cli::loader::inline "$@"; then

        # procedural; execute main generate content
        "$@" 
    fi
}

cli::loader::cache::exports() {
    local -n GENERATED_PATH_REF="$1"
    shift

    local SOURCE_PATH
    ::cli::shim::which::inline SOURCE_PATH "$@" \
        || cli::assert "Failed to find shim import '$@'."


    if [[ ! -f "${SOURCE_PATH}" ]]; then

        # ignore missing .group imports
        if [[ "${@: -1}" == ".group" ]]; then
            GENERATED_PATH_REF=/dev/null
            return
        fi

        cli::assert "Source file '${SOURCE_PATH}' for import '$@' does not exist."
    fi

    [[ -x "${SOURCE_PATH}" ]] \
        || cli::assert "Source file '${SOURCE_PATH}' for import '$@' is not executable."

    local CACHE_DIR=
    ::cli::cache::path::inline CACHE_DIR "${SOURCE_PATH}"

    GENERATED_PATH_REF="${CACHE_DIR}/exports.sh"

    if ! ::cli::cache::test::inline "${GENERATED_PATH_REF}" "${SOURCE_PATH}"; then
        cli::loader::exports "$@" \
            | ::cli::cache::put::inline "${GENERATED_PATH_REF}"
    fi
}

cli::loader::cache::bgen() {

    # allow hard coded metadata of logic that is itself necessary to parse help
    if cli::is_function_declared cli::meta::declare; then
        cli::import::default
        cli::meta::declare
        return
    fi

    [[ ! "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata should have not been declared outside of cli::meta::declare."

    # test cache 
    # cli::log "BGEN ${CLI_COMMAND[@]} -> ${CLI_LOADER_BGEN_PATH}"
    if ! ::cli::cache::test::inline "${CLI_LOADER_BGEN_PATH}"; then

        # generate (like ngen)
        cli::loader::dsl::bgen \
            | ::cli::cache::put::inline "${CLI_LOADER_BGEN_PATH}"
    fi
}

cli::source() {
    if (( $# > 0 )); then
        CLI_LOADER_IMPORT+=("$*");
    fi

    local exports_path=
    local -a import=()
    local -a export_paths=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORT[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORT[i]} )

        # if import previously seen, continue
        if [[ ! ${CLI_LOADER_SOURCED[${import[@]}]-false} ]]; then
            continue
        fi
        CLI_LOADER_SOURCED[${import[@]}]=true

        # TODO: inline shim; e.g. if import is 'cli ...', then use shim to 
        # resolve unix path, then define function cli() that caches that 
        # result; e.g. cli() { ~/git/cli/src/cli/"$1/.../$n" "${@:n+1}"; }

        # refresh import codegen cache
        local exports_path
        cli::loader::cache::exports exports_path "${import[@]}"

        # source the exports to gather imports only (ignore declare)
        declare() { return; }
        source "${exports_path}"
        unset declare

        export_paths+=( "${exports_path}" )
    done

    # source exports in reverse order so that dependencies are sourced first
    for (( i=1; i<=${#export_paths[@]}; i++ )); do
        export_path="${export_paths[@]: -$i:1}"
        CLI_LOADER_SOURCED_PATHS+=( "${export_path}" )
        source "${export_path}"
    done
}

cli::loader::initialize() {
    
    # somehow the metadata should have been declared
    [[ "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata missing. Add cli::meta::declare?"

    # to test 'cli args' logic itself hard code logic here to skip 'cli args' 
    # logic if there is ...

    # cli::print CLI_META > /dev/stderr

    #  ... a single parameter group { 'help' 'self-test' } and ...
    # declare -p CLI_META_GROUP_0_TYPE > /dev/stderr
    if (( ${#CLI_META_GROUP[@]} == 1 )) && \
        (( ${#CLI_META_GROUP_0_TYPE[@]} == 2 )); then

        # ... no named parameters
        if (( $# == 0 )); then
            ARG_HELP=false
            ARG_SELF_TEST=false
            return
        fi

        # ... or only positional parameters
        if [[ "$1" == '--' ]] && ${CLI_META_GROUP_0_POSITIONAL}; then
            shift
            ARG_HELP=false
            ARG_SELF_TEST=false
            CLI_ARGS_POSITIONAL=( "$@" )
            return
        fi
    fi

    cli::declare cli_tokens CLI_TOKENS
    cli::declare cli_args CLI_ARGS

    ARG_TOKENS=CLI_TOKENS \
        ::cli::args::tokenize::inline "$@"
    # for i in "${!CLI_TOKENS_ID[@]}"; do
    #     cli::log ${CLI_ARG_TOKEN[CLI_TOKENS_ID[$i]]} "${CLI_TOKENS_IDENTIFIER[$i]-}"
    # done

    ARG_ARGS=CLI_ARGS \
    ARG_TOKENS=CLI_TOKENS \
    ARG_ALIAS=CLI_META_ALIAS \
        ::cli::args::parse::inline
    # cli::write CLI_ARGS > /dev/stderr

    # determine the group id from the first named argument
    local meta_group_id=0
    if [[ -z "${CLI_META_GROUP['*']+set}" ]]; then

        if [[ ${CLI_ARGS_FIRST_NAMED} == '' ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND[@]}'." \
                "Instead no named arguments were passed."
        fi

        if [[ ! -n ${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]+set} ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND[@]}'." \
                "Instead '${CLI_ARGS_FIRST_NAMED}' was passed as the first named argument."
        fi

        meta_group_id=${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]}
    fi

    local CLI_META_GROUP_N="CLI_META_GROUP_${meta_group_id}"
    local CLI_META_GROUP_N_TYPE="${CLI_META_GROUP_N}_TYPE"
    local CLI_TYPE_GROUP_TYPE_N="CLI_GROUP_${meta_group_id}"

    ARG_ARGS=CLI_ARGS \
    ARG_META="${CLI_META_GROUP_N}" \
        ::cli::args::initialize::inline
    # cli::write CLI_ARGS

    _ARG_PREFIX='ARG' \
    _ARG_TYPE="${CLI_TYPE_GROUP_TYPE_N}" \
    _ARG_META="${CLI_META_GROUP_N_TYPE}" \
    _ARG_ARGS=CLI_ARGS \
    _ARG_BASH_NAME=CLI_META_BASH_NAME \
        ::cli::args::emit::inline
    # cli::dump 'ARG_*'

    # cli::fail '--- CALLED ARG TOKENIZE ---'
}

cli::loader::dsl::tokenize() { help | cli dsl tokenize; }
cli::loader::dsl::parse() { cli::loader::dsl::tokenize | cli dsl parse; }
cli::loader::dsl::meta() { cli::loader::dsl::parse | cli dsl meta; }
cli::loader::dsl::load() { cli::loader::dsl::meta | cli dsl load; }
cli::loader::dsl::bgen() { cli::loader::dsl::load | cli dsl bgen; }
cli::loader::dsl::wire() { cli::loader::dsl::load | cli core wire load -- CLI_META cli_meta | sort -u; }
cli::loader::dsl::wire_bash() { cli::loader::dsl::wire | cli core wire read | sort -u; }

cli::loader::shim() {

    # CLI_NAME
    [[ ${CLI_NAME-} ]] \
        || cli::assert "Shim failed to set CLI_NAME."

    # CLI_COMMAND
    local -a CLI_COMMAND=( "${CLI_NAME}" )
    while [[ "${1-}" =~ ${CLI_REGEX_NAME} ]]; do
        CLI_COMMAND+=( "$1" )
        shift
    done

    # BASH_ARGV0
    ::cli::shim::which::inline BASH_ARGV0 "${CLI_COMMAND[@]}" \
        || cli::assert "Failed to find shim for '${CLI_COMMAND[@]}'."

    [[ -f "$0" ]] \
        || cli::assert "Source file '$0' for command '${CLI_COMMAND[@]}' does not exist."

    [[ -x "$0" ]] \
        || cli::assert "Source file '$0' for command '${CLI_COMMAND[@]}' is not executable."

    # optimization; skip creating subshell if we are the root
    if (( $$ == ${BASHPID} )); then 
        cli::main "$@"
        return
    fi

    ( cli::main "$@" )
}

cli::main() {

    # initialize global variables
    declare -a CLI_LOADER_IMPORT+=()
    declare -A CLI_LOADER_IMPORTED+=()
    declare -A CLI_LOADER_SOURCED+=()
    declare -a CLI_LOADER_SOURCED_PATHS+=()

    # reset bash variables
    IFS="${CLI_IFS}"

    # establish frame
    declare -a CLI_IMPORT=()
    [[ -v CLI_NAME ]] || cli::assert "Shim failed to define CLI_NAME."
    [[ -v CLI_COMMAND ]] || cli::assert "Shim failed to define CLI_COMMAND."
    [[ "${CLI_COMMAND}" == "${CLI_NAME}" ]] || cli::assert
    declare -A CLI_SCOPE=(
        [CLI_NAME]='string'
        [CLI_COMMAND]='array'
        [CLI_IMPORT]='array'
    )

    # error testing
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---assert')
                    cli::assert ;;
                '---subshell-assert')
                    ( cli::assert ) ;;
                '---err')
                    err() { return 1; }; err ;;
                '---subshell-err')
                    err() { return 1; }; ( err; ) ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---eval')
                    shift; eval "${1-}" ;;
                '---noop') ;;
                '---command')
                    echo "${CLI_COMMAND[@]}" ;;
                '---env')
                    declare -p ;;
                '---which') 
                    echo "$0" ;;
                '---print') 
                    cat "$0" ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    if [[ "${CLI_COMMAND[@]}" == 'cli loader' ]]; then
        loader_source
    else
        cli::import::parent "${CLI_COMMAND[@]}"
        source "$0"
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---imports')
                    for i in "${CLI_LOADER_IMPORT[@]}"; do echo "${i}"; done ;;
                '---dependencies')
                    cli imports -c "${CLI_COMMAND[@]}" ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    cli::source

    # help
    for i in "$@"; do
        case "${i}" in
            '--') 
                break ;;
            '--self-test')
                self_test; exit ;;
            '-h') ;& '--help')
                help; exit ;;
        esac
    done
    unset i

    # well-known options that require imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---exports')
                    local EXPORT_PATH
                    cli::loader::cache::exports EXPORT_PATH ${CLI_COMMAND[@]}
                    echo "${EXPORT_PATH}" ;;
                '---inline')
                    cat $(${CLI_COMMAND[@]} ---exports) ;;
                '---tokenize')
                    cli::loader::dsl::tokenize ;;
                '---parse')
                    cli::loader::dsl::parse ;;
                '---meta')
                    cli::loader::dsl::meta ;;
                '---load')
                    cli::loader::dsl::load ;;
                '---bgen')
                    cli::loader::dsl::bgen ;;
                '---wire')
                    cli::loader::dsl::wire ;;
                '---wire-bash')
                    cli::loader::dsl::wire_bash ;;
                '---')
                    cli::export::inline_function "$@" ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # bgen metadata
    cli::loader::cache::bgen
    if [[ -f "${CLI_LOADER_BGEN_PATH-}" ]]; then
        source "${CLI_LOADER_BGEN_PATH}"
    fi

    # well-known options that require loaded metadata
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---import')
                    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
                        echo "${CLI_LOADER_BGEN_PATH}"
                    fi
                    ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # initialize ARG_* variables
    cli::loader::initialize "$@"

    # well-known options that require loaded arguments
    while [[ "${1-}" == ---* ]]; do
        case "$1" in
            '---args-tokenize')
                cli::write CLI_TOKENS ;;
            '---args-load')
                cli::write CLI_ARGS ;;
            '---args')
                cli::dump 'ARG_*' ;;
            '---cli')
                cli::dump 'CLI_*' ;;
            '---source')
                shift; source "$1"; shift
                continue ;;
            '---read')
                shift
                while read -a REPLY; do main "$@" "${REPLY[@]}"; done ;;
            *) cli::fail "Unexpected unknown internal option \"$1\"."
        esac 
        exit
    done

    # well known features
    if [[ -n "${ARG_RUN_AS-}" ]] && [[ ! "${ARG_RUN_AS}" == "$(whoami)" ]]; then
        arg_user="${ARG_RUN_AS}" \
        arg_command="$0" \
            ::cli::run_as::inline "$@"
        return
    fi

    # hide bash entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['bash::main']=0 )

    # hide cli entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['cli::main']=0 )

    main "${CLI_ARGS_POSITIONAL[@]}"
}

loader_source() {

    alias_inline_import() {
        local COMMAND="$1"
        local ALIAS="${2-$(::cli::bash::join::inline '::' ${COMMAND})}"

        local TARGET=$(cli::loader::to_inline ${COMMAND})
        eval "${ALIAS}() { ${TARGET} \"\$@\"; }"
    }

    diff_import_then_export_as() {
        local COMMAND="$1"
        shift
        
        local ALIAS="$1"
        shift

        diff_import "${COMMAND}" "$@"
        alias_inline_import "${COMMAND}" "${ALIAS}"
    }

    diff_import_then_export() {
        diff_import "$@"
        alias_inline_import "$1"
    }

    diff_import() {
        cli::loader::import "$1"

        if [[ -n "${CLI_LOADER_IMPORT_DISABLE-}" ]]; then
            diff_import "$@"
        fi

        local COMMAND="$1"
        shift

        # capture inline function    
        local INLINE_FUNCTION
        INLINE_FUNCTION=$(cli::loader::inline ${COMMAND}) \
            || ::cli::stderr::assert::inline "Expected command '${COMMAND}' to export inline function."

        # capture existing function
        local FQN=$(cli::loader::to_inline ${COMMAND})
        ::cli::bash::is_function_declared::inline ${FQN} \
            || ::cli::stderr::assert::inline "Expected ${FQN} to be inlined into loader."
        local EXISTING_FUNCTION=$(
            cli::loader::print::import "$@"
            declare -f ${FQN}
        )

        # assert exiting function matches inlined function
        local DIFF=$(diff <(echo "${EXISTING_FUNCTION}") <(echo "${INLINE_FUNCTION}") || true)
        if [[ -n "${DIFF}" ]]; then
            echo "EXISTING_FUNCTION != INLINE_FUNCTION, FQN=${FQN}"
            echo "to disable check declare -x CLI_LOADER_IMPORT_DISABLE=1"
            echo "${DIFF}"
            exit 1
        fi > /dev/stderr
    }

    # these functions pre-imported because the import logic itself depends on them.
    # the effect of importing pre-imported functions is to ensure the copies here
    # match the source copies. 
    diff_import_then_export 'cli path name'
    diff_import_then_export 'cli path dir'
    diff_import_then_export 'cli path make-absolute'

    diff_import 'cli subshell signal-group'
    diff_import 'cli subshell on-exit'

    diff_import_then_export 'cli temp remove'
    diff_import_then_export 'cli temp file' \
        'cli temp remove' \
        'cli subshell on-exit'
    diff_import_then_export 'cli temp dir' \
        'cli temp file'
    diff_import_then_export 'cli temp fifo' \
        'cli temp file'

    diff_import_then_export 'cli cache test'
    diff_import_then_export 'cli cache path' \
        'cli path dir' \
        'cli path name'
    diff_import_then_export 'cli cache put' \
        'cli path dir' \
        'cli temp file'

    diff_import_then_export_as 'cli stderr lock' 'cli::lock'
    diff_import 'cli stderr cat' \
        'cli stderr lock' \
        'cli temp file'
    diff_import 'cli stderr dump' \
        'cli stderr cat' \
        'cli subshell signal-group'
    diff_import_then_export_as 'cli stderr assert' 'cli::assert' \
        'cli stderr dump' \
        'cli bash stack trace'
    diff_import_then_export_as 'cli stderr fail' 'cli::fail' \
        'cli stderr dump'
    diff_import 'cli stderr on-err' \
        'cli stderr dump' \
        'cli bash stack trace'

    diff_import_then_export_as 'cli bash which' 'cli::which'
    diff_import_then_export_as 'cli bash log' 'cli::log'
    diff_import_then_export_as 'cli bash return' 'cli::return'
    diff_import_then_export_as 'cli bash join' 'cli::join'
    diff_import_then_export_as 'cli bash literal' 'cli::literal'
    diff_import_then_export_as 'cli bash emit' 'cli::dump'
    diff_import_then_export_as 'cli bash is-function-declared' 'cli::is_function_declared'

    diff_import_then_export 'cli attribute is-defined'
    diff_import_then_export_as 'cli bash stack call' 'cli::stacktrace' \
        'cli bash literal' \
        'cli attribute is-defined'
    diff_import 'cli bash stack process'
    diff_import 'cli bash stack trace' \
        'cli bash stack process' \
        'cli bash stack call'

    diff_import_then_export_as 'cli bash initialize' 'cli::bash::declare' \
        'cli bash declare'

    diff_import 'cli shim source' \
        'cli bash which' \
        'cli bash is-function-declared'
    diff_import 'cli shim which' \
        'cli shim source'
    diff_import_then_export_as 'cli shim shebang' 'cli::shebang' \
        'cli path make-absolute' \
        'cli path name' \
        'cli shim source'

    cli::import cli run-as

    cli::import cli core declare
    cli::import cli core load
    cli::import cli core save
    cli::import cli core write

    cli::import cli args tokenize
    cli::import cli args parse
    cli::import cli args initialize
    cli::import cli args emit

    # cli::import cli name to-bash
    # cli::import cli core struct emit

    cli::meta::declare() {
        :
    }

    main() {
        # echo MAIN >&2
        # ::cli::bash::stack::trace::inline | sed 's/^/  /' >&2

        echo "set -$-"
        echo

        declare -p CLI_IFS
        echo

        cat <<-EOF 
			shopt -s inherit_errexit
			shopt -s lastpipe
			shopt -s globstar
			shopt -s extglob
			shopt -s nullglob
			shopt -s extdebug
			EOF
        echo

        #cli::export::variables cli | sort -k4
        {
            # declare -p CLI_SHIM_ROOT_DIR_CLI

            declare -p CLI_LOADER_IMPORT
            declare -p CLI_LOADER_IMPORTED
            declare -p CLI_LOADER_SOURCED
            declare -p CLI_LOADER_SOURCED_PATHS

            declare -p CLI_SCOPE
            declare -p CLI_IMPORT

            # declare -p CLI_LOCK_FILE
            cli::export::variables cli lock

            cli::export::variables cli regex

            cli::export::variables cli type

            # declare -p CLI_BGEN_DECLARE
            cli::export::variables cli bgen

            cli::export::variables cli arg

            # cli::export::variables cli meta attributes | sed 's/^/# /'
            cli::export::variables cli meta attributes
        } | sort -k3

        cli::export::functions::print cli | sed 's/^/# /'
        echo 

        cli::export::functions cli
        echo

        echo "main() { cli::export::inline_function \"\$@\"; }"
        echo "help() { echo \"Unexpected missing 'help' in '\$0'.\"; }"
        echo "self_test() { cli::assert \"Command '\$0' missing self_test.\"; }"
        echo

        declare -f cli
        declare -f loader_source
        echo

        local ARG_PACK=false
        if ${ARG_PACK}; then
            cli::import() { 
                local name=$*
                echo "${name// /::}::source"
            }

            cli::loader::cache::bgen() {

                # hard coded
                if [[ -n ${CLI_SCOPE[CLI_META]+set} ]]; then
                    return
                fi

                # generated (ala ngen)
                ${FUNCNAME[2]}::cache::bgen
            }

            cli() {
                # intercept and ignore 'cli loader' calls
                if [[ "${1-}" == 'loader' ]]; then return; fi
                ( unset cli; cli "$@"; )
            }
        else
            :
            # declare -f cli::loader::cache::bgen
            # declare -f cli::loader::cache::exports
            # echo

            # declare -f cli::source
            # echo

            # declare -f cli::loader::initialize
            # declare -f cli::loader::inline
            # declare -f cli::loader::print::import
            # echo
        fi

        printf '%s\n' "${CLI_LOADER_IMPORT[@]}" \
            | sort -u \
            | mapfile -t CLI_LOADER_DEPENDENCIES
        printf '# %s\n' "${CLI_LOADER_DEPENDENCIES[@]}"
        echo

        for import in "${CLI_LOADER_DEPENDENCIES[@]}"; do
            cli::loader::to_inline ${import}
        done | mapfile -t CLI_LOADER_INLINES
        printf '# %s\n' "${CLI_LOADER_INLINES[@]}"
        echo

        printf '%s\n' "${CLI_LOADER_INLINES[@]}" \
            | while read; do eval "declare -f ${REPLY}"; done

        trap -p
        echo
    }

    self_test() { :; }
}

cli::initialize() {

    # ${bash_source[1]} '.cli/loader/exports.sh'
    # ${bash_source[2]} the command itself
    declare -g CLI_LOADER_COMMAND_PATH="${BASH_SOURCE[1]}"
    declare -g CLI_LOADER_CACHE_DIR
    ::cli::cache::path::inline CLI_LOADER_CACHE_DIR "${CLI_LOADER_COMMAND_PATH}"

    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
}

trap '::cli::stderr::on_err::inline $?' ERR

cli::initialize

# shim
source "$( cd $(dirname ${BASH_SOURCE}); cd ..; pwd)/cli"

cli loader "$@"
# ps -al >&2
# exit 1