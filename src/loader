#!/usr/bin/env bash
help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

set -e
set -u 
set -o pipefail
shopt -s lastpipe

declare CLI_LOADER_DIR="${BASH_SOURCE%/*}"

cli::loader::is_declared() {
    if declare -F "$1" > /dev/null; then true; else false; fi
}

cli::loader::escape_args_then_call_as() {
    local user=$1
    shift

    local -a args
    for i in "$@"; do
        args+=( $(printf %q "${i}") )
    done

    sudo su "${user}" -c "${args[*]}"
}

cli::loader::dry_run() {
    if [[ "${arg_dry_run:-}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:-}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:-}" == "true" ]]; then set +x; fi
    fi
}

cli::loader::cache::load() {
    declare -g CLI_LOADER_SOURCE_PATH="$1"
    declare -g CLI_LOADER_SOURCE_NAME="${CLI_LOADER_SOURCE_PATH##*/}"
    declare -g CLI_LOADER_SOURCE_DIR="${CLI_LOADER_SOURCE_PATH%/*}"
    
    declare -g CLI_LOADER_CACHE_DIR="${CLI_LOADER_SOURCE_DIR}/.cli/${CLI_LOADER_SOURCE_NAME}"
    if [[ ! -d "${CLI_LOADER_CACHE_DIR}" ]]; then
        mkdir -p "${CLI_LOADER_CACHE_DIR}"
    fi

    declare -g CLI_LOADER_INITIALIZE_PATH="${CLI_LOADER_CACHE_DIR}/initialize.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
}

cli::import() {
    CLI_LOADER_IMPORTS+=( "$*" )
}

cli::import_group() {
    cli::import ${CLI_GROUP} .group
}

cli::cache::put() {
    arg_cache="$1" \
        ::cli::cache::put::inline
}

cli::cache::test() {
    arg_cache="$1" \
    arg_source="${CLI_LOADER_SOURCE_PATH}" \
        ::cli::cache::test::inline
}

cli::loader::cache::exports() {
    if ! cli::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then
        if cli::loader::is_declared 'inline'; then
            cli emit inline \
                --name "$(cli path join --delimiter '::' -- ${CLI_PATH})::inline" \
                --path "${CLI_LOADER_SOURCE_PATH}" \
                --function 'inline'
        else
            "$0" 
        fi | cli::cache::put "${CLI_LOADER_EXPORTS_PATH}"
    fi
}

cli::loader::cache::initialize() {

    # test initialize cache 
    if ! cli::cache::test "${CLI_LOADER_INITIALIZE_PATH}"; then
   
        # initialize hard coded
        if cli::loader::is_declared initialize; then

            # cache empty result
            if [[ ! -f "${CLI_LOADER_INITIALIZE_PATH}" ]]; then
                : > "${CLI_LOADER_INITIALIZE_PATH}"
            fi

        # initialize lazily generated (like JIT)
        else
            "$0" '--help' \
                | cli dsl tokenize \
                | cli dsl parse \
                | cli dsl emit \
                | cli::cache::put "${CLI_LOADER_INITIALIZE_PATH}"
        fi
    fi
}

cli::loader::load::imports() {
    local command_path=
    local cache_path=
    local -a import=()
    local -A imported=()
    local -A base_path=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORTS[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORTS[i]} )

        # if import previously seen, continue
        if ${imported[${import[@]}]-false}; then
            continue
        fi
        imported[${import[@]}]=true

        # if base path not resolved
        if [[ -z "${base_path[$import]-}" ]]; then

            # resolve base path
            base_path[${import}]=$(${import} '---which')
            # if cli still not resolved, fail
            # TODO
        fi

        # if import codegen cache stale
        command_path=$(arg_delimiter='/' arg_base=${base_path[${import}]} \
            ::cli::path::join::inline "${import[@]:1}")
        cache_path="$(arg_path=${command_path} \
            ::cli::cache::path::inline)/exports.sh"

        if ! arg_cache="${cache_path}" arg_source="${command_path}" \
            ::cli::cache::test::inline; then

            # refresh import codegen cache
            ${import[@]} '---exports' > /dev/null
        fi
            
        # source codegen
        source "${cache_path}"
    done
}

cli::loader::load::initialize() {
    cli::loader::cache::initialize
    source "${CLI_LOADER_INITIALIZE_PATH}"
}

cli::loader::execute() {

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::loader::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args

        if cli::loader::is_declared main; then
            main "${arg_[@]}"

        elif cli::loader::is_declared inline; then
            inline "${arg_[@]}"

        elif cli::loader::is_declared export; then
            export
            
        else
            echo "Unexpected missing entry point 'main' or 'export'."
            exit 1
        fi
    fi
}

cli::loader::self_test() {
    self_test
    result=$?
    if ! (( ${result} == 0 )); then
        read line file < <(caller)
        echo "Self-test failed: ${file}"
    fi
    exit ${result}
}

cli::load() {
    # implicit imports
    if cli::loader::is_declared export; then
        CLI_LOADER_IMPORTS+=( \
            'cli emit export' \
            'cli emit initialize' \
        )
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then
        case "$1" in
            '---type')
                echo 'command' ;;
            '---which') 
                echo "${CLI_LOADER_SOURCE_PATH}" ;;
            '---print') 
                cat "${CLI_LOADER_SOURCE_PATH}" ;;
            '---imports')
                for i in "${CLI_LOADER_IMPORTS[@]}"; do echo "${i}"; done ;;
            '---initialize')
                cli::loader::load::imports
                cli::loader::cache::initialize
                echo "${CLI_LOADER_INITIALIZE_PATH}"
                ;;
            '---exports')
                cli::loader::cache::exports
                echo "${CLI_LOADER_EXPORTS_PATH}"
                ;;
        esac 
        exit
    fi

    cli::loader::load::imports

    for i in "$@"; do
        case "${i}" in
            '--') break ;;
            '-h') ;& '--help')
            help
            exit
        esac
    done
    unset i

    case "${1-}" in
        '--self-test')
            cli::loader::self_test
            exit
        ;;
    esac 

    cli::loader::load::initialize
    cli::loader::execute "$@"
}

main() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    echo 'set -o pipefail'
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    echo "declare -a CLI_LOADER_IMPORTS=()"
    echo ": \${CLI_PATH:=\${BASH_SOURCE[1]##*/}}"
    echo "declare path=( \${CLI_PATH} )"
    echo "declare length=\${#path[@]}"
    echo "declare CLI_NAME=\"\${path[@]: -1:1}\""
    echo "declare CLI_GROUP=\"\${path[@]:0:\$(( length - 1 ))}\""
    echo "declare CLI_PARENT_GROUP=\"\${path[@]:0:\$(( length - 2 ))}\""
    echo "unset path length"

    declare -f cli::import
    declare -f cli::import_group
    declare -f cli::load

    declare -f cli::loader::dry_run
    declare -f cli::loader::escape_args_then_call_as
    declare -f cli::loader::execute
    declare -f cli::loader::self_test

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::initialize() {

            # hard coded
            if declare -F initialize > /dev/null; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::initialize
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else

        declare -f ::cli::cache::put::inline
        declare -f ::cli::cache::test::inline
        declare -f ::cli::cache::path::inline
        declare -f ::cli::path::join::inline

        declare -f cli::cache::test
        declare -f cli::cache::put

        declare -f cli::loader::is_declared
        declare -f cli::loader::cache::load
        declare -f cli::loader::cache::initialize
        declare -f cli::loader::cache::exports
        declare -f cli::loader::load::imports
        declare -f cli::loader::load::initialize

        echo
        echo "cli::loader::cache::load \"\${BASH_SOURCE[1]}\""
  fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) echo "Unexpected argument '$1'."; exit 1 ;;
        esac

        shift
    done
}

declare -a CLI_LOADER_IMPORTS
cli::loader::cache::load ${BASH_SOURCE}

cat "${BASH_SOURCE%/*}/emit/inline" \
    | {
        while true; do
            read -r
            if [[ "${REPLY}" == 'main() {' ]]; then
                echo "::cli::inline::inline() {"
                while true; do 
                    read -r
                    echo "${REPLY}"
                    if [[ ${REPLY} == '}' ]]; then
                        exit
                    fi
                done
            fi
        done
    } \
    | source /dev/stdin
        
inline() {
    arg_name="::cli::$1::inline" \
    arg_path="${CLI_LOADER_DIR}/$2" \
        ::cli::inline::inline \
        | source /dev/stdin
}

inline 'cache::put' 'cache/put'
inline 'cache::test' 'cache/test'
inline 'cache::path' 'cache/path'
inline 'path::join' 'path/join'

if (( $# == 0 )); then
    if ! cli::cache::test "${CLI_LOADER_EXPORTS_PATH}"; then
        : ${arg_pack:=false}
        main | cli::cache::put "${CLI_LOADER_EXPORTS_PATH}"
    fi
    echo "${CLI_LOADER_EXPORTS_PATH}"
    exit
fi

cli::load "$@"
