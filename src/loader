#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli

Summary
    The shim.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

cli::bash::initialize() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    set +m

    # see https://dougrichardson.us/notes/fail-fast-bash-scripting.html
    set -e
    shopt -s inherit_errexit

    set -u
    set -o pipefail

    set -E
    set -o functrace
    
    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    shopt -s lastpipe

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    shopt -s globstar

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    shopt -s extglob

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    shopt -s nullglob

    # enables BASH_ARGC and BASH_ARGV
    shopt -s extdebug
}
cli::bash::initialize

# optimization
main() {
    if [[ ! "${1-}" == '---exports' ]]; then
        return
    fi

    local exports_path="$(cd $(dirname $0); pwd)/.cli/loader/exports.sh"
    if [[ ! -f "${exports_path}" || "$0" -nt "${exports_path}" ]]; then
        return
    fi

    echo "${exports_path}"
    exit
}
main "$@"
unset main

cli::meta::declare() {
    :
}

# shim
declare -r CLI_SHIM_ROOT_DIR_CLI="$(cd $(dirname $0); pwd)"

# lock
declare CLI_LOCK_FILE="${CLI_LOCK_FILE-/tmp/.cli_lock}"

# debug
declare CLI_STACK_SHOW_PROCESS
declare CLI_STACK_SHOW_HIDDEN

# regex
declare -r REGEX_NAME="[a-z.][a-z0-9-]*"
declare -r CLI_REGEX_NAME="^${REGEX_NAME}$"
declare -r CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"
declare -r CLI_REGEX_PROPERTY_ARG="^(${REGEX_NAME})=(.*)$"

declare -r CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
declare -r CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
declare -r CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
declare -r CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
declare -r CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

# types
declare -rA CLI_TYPE_CLI_META_TABLES=(
    # TODO: remove?
    [alias]="map"
    [type]="map_of map"
    [require]="map_of map"
    [default]="map_of map"
    [regex]="map_of map"
    [allow]="map_of map_of map"
    [positional]="map_of boolean" \
)
declare -rA CLI_TYPE_CLI_META_GROUP=(
    [type]="map"
    [bash_type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
declare -rA CLI_TYPE_CLI_META=(
    [alias]="map"
    [bash_name]="map"
    [group]="map_of cli_meta_group"
    #[attributes]="map_of cli_meta_attributes"
)
declare -rA CLI_TYPE_CLI_META_ATTRIBUTE=(
    [type]="string"
    [blob]="string"
)
declare -rA CLI_TYPE_CLI_META_ATTRIBUTES=(
    [method]="map_of cli_meta_attribute"
)
declare -rA CLI_TYPE_CLI_TOKENS=(
    [id]="array"
    [identifier]="array"
)
declare -rA CLI_TYPE_CLI_ARGS=(
    [path]="array"
    [first_named]="string"
    [named]="map_of array"
    [positional]="array"
)
declare -rA CLI_TYPE_CLI_BASH_STACK_HIDDEN_ATTRIBUTE=()

# tokens
declare -ra CLI_ARG_TOKEN=(
    [0]="PATH"
    [1]="VALUE"
    [2]="DASH"
    [3]="DASH_DASH"
    [4]="DASH_DASH_DASH"
    [5]="END_OPTIONS"
    [6]="EOF"
)
declare -r CLI_ARG_TOKEN_PATH="0"
declare -r CLI_ARG_TOKEN_VALUE="1"
declare -r CLI_ARG_TOKEN_DASH="2"
declare -r CLI_ARG_TOKEN_DASH_DASH="3"
declare -r CLI_ARG_TOKEN_DASH_DASH_DASH="4"
declare -r CLI_ARG_TOKEN_END_OPTIONS="5"
declare -r CLI_ARG_TOKEN_EOF="6"

# productions
declare -ra CLI_ARG_PRODUCTION=(
    [0]="SEGMENT"
    [1]="OPTION"
    [2]="POSITIONAL"
)
declare -r CLI_ARG_PRODUCTION_SEGMENT="0"
declare -r CLI_ARG_PRODUCTION_OPTION="1"
declare -r CLI_ARG_PRODUCTION_POSITIONAL="2"

# attributes
declare -A CLI_META_ATTRIBUTES_METHOD=(
    ['::cli::bash::stack::call::inline']=0
    ['::cli::bash::stack::trace::inline']=0
    ['::cli::stderr::assert::inline']=0
    ['cli::assert']=0
    
    ['cli::main']=0
    ['cli::loader::shim']=0
    ['bash::main']=0

    # ['cli::trap::err']=0
)
declare -ra CLI_META_ATTRIBUTES_METHOD_0_TYPE=( 'cli_bash_stack_hidden_attribute' )
declare -ra CLI_META_ATTRIBUTES_METHOD_0_BLOB=()

# frame
declare -gA CLI_SCOPE=()
declare -ga CLI_LOADER_IMPORTS=()
declare -gA CLI_LOADER_IMPORTED=()
declare -gA CLI_LOADER_SOURCED=()
declare -ga CLI_LOADER_IMPORT_PATHS=()

# initialize
cli::core::scope::add() { CLI_SCOPE[$1]="$2"; }

# bash
cli::bash::declare() { ::cli::bash::initialize::inline "$@"; }

# emulate bgen
bgen() {
    cli::bash::declare::type::cli_meta_tables() {
        cli::core::scope::add $1 CLI_META_TABLES

        cli::bash::declare \
            map $1_ALIAS \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_POSITIONAL \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_TYPE
    }
    cli::bash::declare::type::cli_meta_group() {
        cli::core::scope::add $1 CLI_META_GROUP

        cli::bash::declare \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_BASH_TYPE \
            map $1_TYPE \
            boolean $1_POSITIONAL
    }
    cli::bash::declare::type::cli_meta() {
        cli::core::scope::add $1 CLI_META

        cli::bash::declare \
            map $1_ALIAS \
            map $1_GROUP \
            map $1_BASH_NAME
    }
    cli::bash::declare::type::cli_meta_attributes() {
        cli::core::scope::add $1 CLI_META_ATTRIBUTES

        cli::bash::declare \
            map $1_TYPE \
            map $1_BLOB
    }
    cli::bash::declare::type::cli_tokens() {
        cli::core::scope::add $1 CLI_TOKENS

        cli::bash::declare \
            array $1_ID \
            array $1_IDENTIFIER
    }
    cli::bash::declare::type::cli_args() {
        cli::core::scope::add $1 CLI_ARGS

        cli::bash::declare \
            string $1_FIRST_NAMED \
            map $1_NAMED \
            array $1_PATH \
            array $1_POSITIONAL
    }

    declare -Ag CLI_BGEN_DECLARE=(
        [CLI_TYPE_CLI_META_TABLES]=cli::bash::declare::type::cli_meta_tables
        [CLI_TYPE_CLI_META_GROUP]=cli::bash::declare::type::cli_meta_group
        [CLI_TYPE_CLI_META]=cli::bash::declare::type::cli_meta
        [CLI_TYPE_CLI_META_ATTRIBUTES]=cli::bash::declare::type::cli_meta_attributes
        [CLI_TYPE_CLI_TOKENS]=cli::bash::declare::type::cli_tokens
        [CLI_TYPE_CLI_ARGS]=cli::bash::declare::type::cli_args
    )
}
bgen

import() {

    ::cli::stderr::lock::inline() {
        flock -x "${CLI_LOCK_FILE}" cat
    }

    ::cli::bash::log::inline() {
        echo "$@" >&2
    }

    ::cli::bash::return::inline() {
        return $1
    }

    ::cli::bash::join::inline() {
        local delimiter=$1
        shift

        local -a segment=()
        while (( $# > 0 )); do
            segment+=( "$1" )
            shift
            if (( $# == 0 )); then break; fi
            segment+=( "${delimiter}" )
        done

        printf %s "${segment[@]}"
        echo
    }

    ::cli::bash::stack::call::inline() {
        
        # argument counts by frame
        set -- ${BASH_ARGV[@]}

        # bash stack
        local -i argc=0
        for (( i=0; i<${#FUNCNAME[@]}; i++ )); do
            local -a args=()
            local inline_args=''
            local funcname="${FUNCNAME[$i]}"

            if (( i == ${#FUNCNAME[@]}-1 )); then funcname='bash::main'; fi

            # reverse argv for i-th frame
            for (( j=${BASH_ARGC[$i]}-1; j>=0; j-- )); do
                args+=( "$(::cli::bash::literal::inline "${BASH_ARGV[${j}+${argc}]}")" )
            done

            # pop argc stack for i-th frame
            argc+=${BASH_ARGC[$i]}

            if [[ ! "${CLI_STACK_SHOW_HIDDEN-}" ]] \
                && cli::attributes::method::is_defined \
                "${funcname}" 'cli_bash_stack_hidden_attribute'; then
                continue
            fi

            # inline args when they won't disturb formatting
            inline_args="${args[@]}"
            if (( ${#inline_args} > 80 )); then
                inline_args=
            else
                args=()
            fi

            printf '%-50s %s:%s\n' \
                "${funcname} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-}

            for arg in "${args[@]}"; do
                echo "${arg}"
            done | sed 's/^/  /'
        done
    }

    ::cli::bash::stack::process::inline() {
        local ARG_START_PID=${1-$$}
        local ARG_END_PID=${2-${CLI_PID-}}

        # load process poset and associated command lines
        local -a pid_parent=()
        local -a pid_cmd=()
        while read pid ppid cmd; do
            pid_parent[${pid}]=${ppid}
            pid_cmd[${pid}]="${cmd}"
        done < <(ps -o pid=,ppid=,args=)

        # subprocess stack
        local pid=${BASHPID}
        local -a subshell=( ${BASHPID} )
        while (( $pid != $$ )); do
            echo "(${pid}) subshell"
            pid=${pid_parent[${pid}]}
        done

        # process stack
        local pid=${ARG_START_PID}
        for (( i=0; ${pid} > 0; i++ )); do

            echo -n "(${pid}) "
            local inline_args=${pid_cmd[${pid}]}
            if (( ${#inline_args} < 80 )); then
                echo "${inline_args}"
            else
                echo "${inline_args}" \
                    | sed -e $'s/--/\\\n  --/g'
            fi

            if (( ${pid} == ${ARG_END_PID-} )); then break; fi
            pid=${pid_parent[${pid}]-0}
        done
    }

    ::cli::bash::stack::trace::inline() {
        ::cli::bash::stack::call::inline
        if [[ -n "${CLI_STACK_SHOW_PROCESS-}" ]]; then
            ::cli::bash::stack::process::inline
        fi
    }

    ::cli::bash::is_function_declared::inline() {
        if declare -F "${1-}" > /dev/null; then 
            true
        else 
            false
        fi
    }

    ::cli::bash::literal::inline() {
        local literal="$*"
        
        #echo "if [[ ! \"${literal}\" =~ ^[a-zA-Z_-]* ]]; then"
        if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
            echo "${literal}"
            return 0
        fi

        local ARRAY=( "$*" )
        literal=$(declare -p ARRAY)

        # 0123456789012345678901
        # declare -a ARRAY=([0]="foo")
        literal="${literal:22}"
        literal="${literal:0: -1}"

        echo "${literal}"
    }

    ::cli::bash::emit::inline() {
        for name in "$@"; do
            if [[ "${name}" =~ ^.*[*]$ ]]; then
                # declare -p \
                #     | grep "^declare [-A-Za-z]* ${name:0:-1}" \
                #     || true # grep fails on no match but we want it to succeed

                # the syntax ${!VAR*} will only print *initialized* variables
                # (e.g. 'declare VAR=' but not 'declare VAR') whereas the above
                # grep will print both initialized and uninitialized variables
                # The one above is slow. Instead we choose to initialize all
                # variables so we can use the faster one below.
                
                ::cli::bash::emit::inline $(eval "echo \${!${name}}")
            elif [[ -z "${name}" ]]; then
                continue
            else
                set +e
                declare -p "${name}" 2> /dev/null
                set -e
            fi
        done
    }

    ::cli::subshell::temp::dir::inline() {

        # create and return a temporary directory
        declare -n REPLY_REF=${1-'REPLY'}
        REPLY_REF=( "$(mktemp -d "${TMPDIR:-/tmp/}cli-XXXXXXXX")/" )

        # record the temporary directory 
        declare -ga "CLI_SUBSHELL_TEMP_DIR_${BASHPID}+=()"
        declare -n CLI_SUBSHELL_TEMP_DIR_BASHPID=CLI_SUBSHELL_TEMP_DIR_${BASHPID}
        CLI_SUBSHELL_TEMP_DIR_BASHPID+=( "${REPLY_REF}" )
    }

    ::cli::subshell::temp::file::inline() {

        # create and return a temporary file
        declare -n REPLY_REF=${1-'REPLY'}
        REPLY_REF=( $(mktemp "${2-"${TMPDIR:-/tmp/}"}cli-XXXXXXXX") )

        # record the temporary file 
        declare -ga "CLI_SUBSHELL_TEMP_FILE_${BASHPID}+=()"
        declare -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
        CLI_SUBSHELL_TEMP_FILE_BASHPID+=( "${REPLY_REF}" )
    }

    ::cli::subshell::temp::clean::inline() {
        declare -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
        rm -f "${CLI_SUBSHELL_TEMP_FILE_BASHPID[@]}"

        declare -n CLI_SUBSHELL_TEMP_DIR_BASHPID=CLI_SUBSHELL_TEMP_DIR_${BASHPID}
        rm -r -f "${CLI_SUBSHELL_TEMP_DIR_BASHPID[@]}"
    }    

    ::cli::subshell::signal_group::inline() {
        local SIGNAL=${1-'SIGINT'}
        read PID < <(ps -p ${BASHPID} -o pgid=)
        kill -${SIGNAL} -${PID}
    }

    ::cli::stderr::cat::inline() {

        # create a temporary file
        ::cli::subshell::temp::file::inline

        # write to file instead of stderr so generator can take lock
        cat > "${REPLY}"

        # lock and copy file to stderr
        cat "${REPLY}" \
            | ::cli::stderr::lock::inline >&2 

        # cleanup
        rm "${REPLY}"
    }

    ::cli::stderr::dump::inline() {

        # copy stdin to stderr
        ::cli::stderr::cat::inline

        # issue control-c
        ::cli::subshell::signal_group::inline
    }

    ::cli::subshell::trap::exit::inline() {
        ::cli::subshell::temp::clean::inline
    }

    ::cli::stderr::assert::inline() {
        if (( $# == 0 )); then 
            set 'Condition failed'
        fi

        {
            echo "ASSERT FAILED:" "$*"
            ::cli::bash::stack::trace::inline \
                | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }

    ::cli::stderr::fail::inline() {
        echo "$*" \
            | ::cli::stderr::dump::inline
    }
}
import

declare_traps() {
    cli::trap::err() {
        local -a CLI_PIPESTATUS=( "${PIPESTATUS[@]}" )
        local CLI_TRAP_EXIT_CODE=${1-'?'}
        local BPID="${BASHPID}"

        # only dump if we are exiting after the trap; e.g. errexit is set (set -e)
        #   -e  Exit immediately if a command exits with a non-zero status.
        if [[ ! $- =~ e ]]; then
            return
        fi

        {
            echo -n "TRAP ERR: exit=${CLI_TRAP_EXIT_CODE}"
            if (( ${#CLI_PIPESTATUS[@]} > 1 )); then
                echo -n ", pipe=[$(cli::join ',' "${CLI_PIPESTATUS[@]}")]"
            fi
            echo ", bpid=${BPID}, pid=$$"

            ::cli::bash::stack::trace::inline | sed 's/^/  /'
        } | ::cli::stderr::dump::inline
    }
    cli::trap::exit() { 
        ::cli::subshell::trap::exit::inline
    }
}
declare_traps

trap 'cli::trap::err $?' ERR
trap 'cli::trap::exit' EXIT

# system
cli::lock() { ::cli::lock::inline "${CLI_LOCK_FILE}"; }

# temp
cli::temp::dir() { ::cli::subshell::temp::dir::inline "$@"; }
cli::temp::file() { ::cli::subshell::temp::file::inline "$@"; }

# util
cli::join() { ::cli::bash::join::inline "$@"; }
cli::literal() { ::cli::bash::literal::inline "$@"; }
cli::stacktrace() { ::cli::bash::stack::trace::inline $((${1-0} + 1)); }
cli::dump() { ::cli::bash::emit::inline "$@"; }
cli::is_function_declared() { ::cli::bash::is_function_declared::inline "$@"; }
cli::log() { ::cli::bash::log::inline "$@"; }

# fail
cli::fail() { ::cli::stderr::fail::inline "$@"; }
cli::assert() { ::cli::stderr::assert::inline "$@"; }
# cli::dump() { ::cli::subshell::dump::inline "$@"; }

# path
cli::path::make_absolute() { echo "$(cd "$(dirname "$1")"; pwd)/${1##*/}"; }
cli::path::name() { echo "${1##*/}"; }

declare_attributes() {
    cli::attributes::is_defined() {
        local target_type=${1-}; shift
        local target=${1-}; shift
        local type=${1-}; shift

        local -n targets="CLI_META_ATTRIBUTES_${target_type}"
        local index=${targets[${target}]:-}
        local -n ref="CLI_META_ATTRIBUTES_${target_type}_${index}_TYPE"
        for attribute in "${ref[@]}"; do
            if [[ "${attribute}" == "${type}" ]]; then
                return 0
            fi
        done

        return 1
    }

    cli::attributes::method::is_defined() {
        cli::attributes::is_defined 'METHOD' "$@" 
    }
}
declare_attributes

declare_cache() {
    cli::cache::path() {
        local arg_path="$1"

        local name="${arg_path##*/}"
        local dir="${arg_path%/*}"
        echo "${dir}/.cli/${name}"
    }

    cli::cache::test() {
        local arg_cache="$1" \
        local arg_source="${2-${CLI_LOADER_COMMAND_PATH}}"

        if [[ ! -f "${arg_cache}" ]] \
            || [[ "${arg_cache}" -ot "${arg_source}" ]]; then
            false
        else
            true
        fi
    }

    cli::cache::put() {
        local arg_cache="$1"

        mkdir -p "${arg_cache%/*}"

        # read content into temp file and then atomically update cache
        local temp_path=$(mktemp "/tmp/cli.cache.put.XXXXXX")
        cat > "${temp_path}"
        mv "${temp_path}" "${arg_cache}"
    }
}
declare_cache

declare_import() {
    cli::import::default() {
        cli::core::scope::add \
            CLI_META CLI_META

        cli::bash::declare \
            map CLI_META_BASH_NAME \
            map CLI_META_ALIAS \
            map CLI_META_GROUP \
            map CLI_META_GROUP_0_ALLOW \
            map CLI_META_GROUP_0_DEFAULT \
            map CLI_META_GROUP_0_REGEX \
            map CLI_META_GROUP_0_REQUIRE \
            map CLI_META_GROUP_0_TYPE \
            boolean CLI_META_GROUP_0_POSITIONAL

        CLI_META_BASH_NAME=(
            [help]="help"
            [self-test]="self_test"
        )
        CLI_META_ALIAS=(
            [h]="help" 
        )
        CLI_META_GROUP=(
            ["*"]="0" 
        )
        CLI_META_GROUP_0_TYPE=(
            [help]="boolean"
            [self-test]="boolean"
        )
    }

    cli::import() {

        if ${CLI_LOADER_IMPORTED[ "$*" ]-false}; then
            return
        fi

        cli::import::parent "$*"

        CLI_LOADER_IMPORTS+=( "$*" )
        CLI_LOADER_IMPORTED[ "$*" ]=true
    }

    cli::import_inline() {
        cli::import "$*"
    }

    cli::import::parent() {

        local command=( "$@" )

        # no hierarchy
        if (( ${#command[@]} < 2 )); then return; fi

        # group
        if [[ "${command[@]: -1}" == '.group' ]]; then

            # root has no parent command; (e.g. 'cli .group')
            if (( ${#command[@]} == 2 )); then return; fi

            # slice off '.group'; (e.g. 'cli util .group' => 'cli util')
            command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" )
        fi

        # slice off last command and append '.group'
        command=( "${command[@]:0:$(( ${#command[@]}-1 ))}" '.group' )

        # import ancestors
        cli::import::parent "${command[@]}"

        cli::import "${command[@]}"
    }
}
declare_import

declare_export() {
    cli::export::functions::print() {
        local glob

        for i in "$@"; do 
            glob+="${i}::"
        done

        while read keyword flags name; do
            if [[ "${name}" == ${glob}* ]]; then
                echo "${name}"
            fi
        done < <(declare -F)
    }

    cli::export::functions() {
        cli::export::functions::print "$@" \
            | while read; do declare -f "${REPLY}"; done
    }

    cli::export::variable() {
        while (( $# > 0 )); do
            declare -p "$1" \
                | sed 's/^declare/declare -g/'
            shift
        done
    }

    cli::export::variables() {
        local -u glob

        for i in "$@"; do 
            glob+="${i}_"; 
        done

        for i in $(eval echo "\${!${glob}@}"); do
            cli::export::variable "${i}"
        done
    }

    cli::export::variable::merge() {
        cli::export::variable "$@" \
            | sed 's/=/+=/'
    }

    cli::export() {
        cli::export::variables "$@"
        cli::export::functions "$@"
    }

    cli::export::import() {
        echo "cli::import $@"
    }
}
declare_export

declare_core() {
    # Arguments when --print-struct
    #     --print-struct -s    [Flag] : Print structs
    #     --                          : Struct names

    # Arguments when --print
    #     --print -p           [Flag] : Print variables
    #     --                          : Variable names

    # Arguments when --type
    #     --type -t                   : Name of type
    #     --name -n        [Optional] : Name of variable
    #     --field -f     [Properties] : Fields of type
    #     --                          : Value

    cli::declare() {
        : ${1?}
        : ${2?}

        arg_type="$1" \
        arg_name="$2" \
        arg_read=false \
        arg_print=false \
            ::cli::core::declare::inline
    }

    cli::put() {
        : ${1:?}

        arg_name="$1" \
        arg_read=false \
        arg_print=false \
        arg_type= \
            ::cli::core::declare::inline "${@:2}"
    }

    cli::print() {
        : ${1:?}

        arg_name="$1" \
        arg_read=false \
        arg_print=true \
        arg_type= \
            ::cli::core::declare::inline
    }

    cli::read() {
        : ${1:?}

        arg_name="$1" \
        arg_read=true \
        arg_print=false \
        arg_type= \
            ::cli::core::declare::inline
    }

    cli::write() {
        : ${1:?}

        arg_name="$1" \
        arg_type="${2:-}" \
            ::cli::core::write::inline
    }

    cli::save() {
        arg_dir="${1-}" \
            ::cli::core::save::inline
    }

    cli::load() {
        arg_dir="${1-}" \
            ::cli::core::load::inline
    }
}
declare_core

# loader
cli::loader::to_bash() {
    while read REPLY; do
        [[ "${REPLY}" =~ ${CLI_REGEX_NAME} ]] || \
            cli::assert "Unexpected cli name \"${REPLY}\"" \
                "does not match regex ${CLI_REGEX_NAME}."

        echo "${REPLY//[-.]/_}"
    done

    # mapfile
    # if (( ${#MAPFILE} == 0 )); then return; fi

    # set ${MAPFILE[@]}
    # while (( $# > 0 )); do
    #     if [[ ! "$1" =~ ${CLI_REGEX_NAME} ]]; then
    #         cli::fail "Unexpected cli name \"$1\"" \
    #             "found in \"${MAPFILE[@]}\"" \
    #             "does not match regex ${CLI_REGEX_NAME}."
    #     fi
    #     echo "${1//[-.]/_}"
    #     shift
    # done
}

# cli::loader::make_fqp() {
#     arg_delimiter='/' \
#     arg_base="$1" \
#         cli::loader::path_join "${@:2}"
# }

# cli::loader::make_fqn() {
#     arg_delimiter='::' \
#     arg_base='::' \
#         cli::loader::path_join "$@"
# }

cli::loader::to_inline() {
    printf '%s\n' "$@" \
        | cli::loader::to_bash \
        | mapfile -t bash_names

    cli::join '::' '' "${bash_names[@]}" 'inline'
}

cli::loader::inline() (
    local path="$("$@" ---which)"
    local fqn=$(cli::loader::to_inline "$@")

    local -a imports=()

    # known case; 'cli loader' itself is not an inline command
    if [[ "${fqn}" == '::cli::loader::inline' ]]; then
        return
    fi

    # disable loader
    cli() { 
        if [[ "${1-}" == 'loader' && "${2-}" == '---exports' ]]; then 
            echo '/dev/null'; 
        fi 
    }
    cli::main() { return; }
    cli::import() { return; }

    # capture imports upon which the inlined function depends
    cli::import_inline() {
        imports+=( "$*" )
    }

    # source file
    source "${path}"

    # emit nothing if no inlined function discovered
    if ! cli::is_function_declared ${fqn}; then
        return
    fi

    # emit dependencies
    cli::loader::inline::import "${imports[@]}"

    # emit function
    declare -f ${fqn}
)

cli::loader::inline::import() {
    if (( $# > 0 )); then
        printf 'cli::import %s\n' "$@"
    fi
}

cli::loader::exports() {

    local inline_function=$(cli::loader::inline "$@")
    if [[ -n "${inline_function}" ]]; then
        # declarative; inline content found in import 
        echo "${inline_function}"

    elif [[ ! "${CLI_COMMAND[@]}" == 'cli loader' ]]; then
        # procedural; execute import to generate content
        "$@" 

    else
        main
    fi
}

cli::loader::import() {
    cli::import "$1"

    if [[ -n "${CLI_LOADER_IMPORT_DISABLE-}" ]]; then
        return
    fi

    local COMMAND="$1"
    shift

    # capture inline function    
    local inline_function=$(cli::loader::inline ${COMMAND})
    [[ -n "${inline_function}" ]] \
        || cli::assert "Expected command '${COMMAND}' to export inline function."

    # capture existing function
    local fqn=$(cli::loader::to_inline ${COMMAND})
    cli::is_function_declared ${fqn} \
        || cli::assert "cli::is_function_declared ${fqn}"
    local existing_function=$(
        cli::loader::inline::import "$@"
        declare -f ${fqn}
    )

    # assert exiting function matches inlined function
    local diff=$(diff <(echo "${existing_function}") <(echo "${inline_function}") || true)
    if [[ -n "${diff}" ]]; then
        echo "cli::loader::import, existing_function != inline_function, fqn=${fqn}"
        echo "${diff}"
        exit 1
    fi > /dev/stderr
}

cli::loader::cache::exports() {
    local path="$("$@" ---which)"
    local exports_path=$(cli::cache::path "${path}")/exports.sh

    if ! cli::cache::test "${exports_path}" "${path}"; then
        cli::loader::exports "$@" \
            | cli::cache::put "${exports_path}"
    fi

    echo "${exports_path}"
}

cli::loader::cache::bgen() {

    # allow hard coded metadata of logic that is itself necessary to parse help
    if cli::is_function_declared cli::meta::declare; then
        cli::import::default
        cli::meta::declare
        return
    fi

    [[ ! "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata should have not been declared outside of cli::meta::declare."

    # test cache 
    # cli::log "BGEN ${CLI_COMMAND[@]} -> ${CLI_LOADER_BGEN_PATH}"
    if ! cli::cache::test "${CLI_LOADER_BGEN_PATH}"; then

        # generate (like ngen)
        cli::loader::dsl::bgen \
            | cli::cache::put "${CLI_LOADER_BGEN_PATH}"
    fi
}

cli::source() {
    if (( $# > 0 )); then
        CLI_LOADER_IMPORTS+=("$*");
    fi

    local exports_path=
    local -a import=()
    local -a export_paths=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORTS[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORTS[i]} )

        # if import previously seen, continue
        if [[ ! ${CLI_LOADER_SOURCED[${import[@]}]-false} ]]; then
            continue
        fi
        CLI_LOADER_SOURCED[${import[@]}]=true

        # TODO: inline shim; e.g. if import is 'cli ...', then use shim to 
        # resolve unix path, then define function cli() that caches that 
        # result; e.g. cli() { ~/git/cli/src/cli/"$1/.../$n" "${@:n+1}"; }

        # refresh import codegen cache
        local exports_path=$(cli::loader::cache::exports "${import[@]}")

        # source the exports to gather imports only (ignore declare)
        declare() { return; }
        source "${exports_path}"
        unset declare

        export_paths+=( "${exports_path}" )
    done

    # source exports in reverse order so that dependencies are sourced first
    for (( i=1; i<=${#export_paths[@]}; i++ )); do
        export_path="${export_paths[@]: -$i:1}"
        CLI_LOADER_IMPORT_PATHS+=( "${export_path}" )
        source "${export_path}"
    done
}

cli::loader::initialize() {
    
    # somehow the metadata should have been declared
    [[ "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata missing. Add cli::meta::declare?"

    # to test 'cli args' logic itself hard code logic here to skip 'cli args' 
    # logic if there is ...

    # cli::print CLI_META > /dev/stderr

    #  ... a single parameter group { 'help' 'self-test' } and ...
    # declare -p CLI_META_GROUP_0_TYPE > /dev/stderr
    if (( ${#CLI_META_GROUP[@]} == 1 )) && \
        (( ${#CLI_META_GROUP_0_TYPE[@]} == 2 )); then

        # ... no named parameters
        if (( $# == 0 )); then
            ARG_HELP=false
            ARG_SELF_TEST=false
            return
        fi

        # ... or only positional parameters
        if [[ "$1" == '--' ]] && ${CLI_META_GROUP_0_POSITIONAL}; then
            shift
            ARG_HELP=false
            ARG_SELF_TEST=false
            CLI_ARGS_POSITIONAL=( "$@" )
            return
        fi
    fi

    cli::declare cli_tokens CLI_TOKENS
    cli::declare cli_args CLI_ARGS

    ARG_TOKENS=CLI_TOKENS \
        ::cli::args::tokenize::inline "$@"
    # for i in "${!CLI_TOKENS_ID[@]}"; do
    #     cli::log ${CLI_ARG_TOKEN[CLI_TOKENS_ID[$i]]} "${CLI_TOKENS_IDENTIFIER[$i]-}"
    # done

    ARG_ARGS=CLI_ARGS \
    ARG_TOKENS=CLI_TOKENS \
    ARG_ALIAS=CLI_META_ALIAS \
        ::cli::args::parse::inline
    # cli::write CLI_ARGS > /dev/stderr

    # determine the group id from the first named argument
    local meta_group_id=0
    if [[ -z "${CLI_META_GROUP['*']+set}" ]]; then

        if [[ ${CLI_ARGS_FIRST_NAMED} == '' ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND[@]}'." \
                "Instead no named arguments were passed."
        fi

        if [[ ! -n ${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]+set} ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND[@]}'." \
                "Instead '${CLI_ARGS_FIRST_NAMED}' was passed as the first named argument."
        fi

        meta_group_id=${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]}
    fi

    local CLI_META_GROUP_N="CLI_META_GROUP_${meta_group_id}"
    local CLI_META_GROUP_N_TYPE="${CLI_META_GROUP_N}_TYPE"
    local CLI_TYPE_GROUP_TYPE_N="CLI_GROUP_${meta_group_id}"

    ARG_ARGS=CLI_ARGS \
    ARG_META="${CLI_META_GROUP_N}" \
        ::cli::args::initialize::inline
    # cli::write CLI_ARGS

    _ARG_PREFIX='ARG' \
    _ARG_TYPE="${CLI_TYPE_GROUP_TYPE_N}" \
    _ARG_META="${CLI_META_GROUP_N_TYPE}" \
    _ARG_ARGS=CLI_ARGS \
    _ARG_BASH_NAME=CLI_META_BASH_NAME \
        ::cli::args::emit::inline
    # cli::dump 'ARG_*'

    # cli::fail '--- CALLED ARG TOKENIZE ---'
}

cli::loader::dsl::tokenize() { help | cli dsl tokenize; }
cli::loader::dsl::parse() { cli::loader::dsl::tokenize | cli dsl parse; }
cli::loader::dsl::meta() { cli::loader::dsl::parse | cli dsl meta; }
cli::loader::dsl::load() { cli::loader::dsl::meta | cli dsl load; }
cli::loader::dsl::bgen() { cli::loader::dsl::load | cli dsl bgen; }
cli::loader::dsl::wire() { cli::loader::dsl::load | cli core wire load -- CLI_META cli_meta | sort -u; }
cli::loader::dsl::wire_bash() { cli::loader::dsl::wire | cli core wire read | sort -u; }

cli::initialize() {

    # ${bash_source[1]} '.cli/loader/exports.sh'
    # ${bash_source[2]} the command itself
    declare -g CLI_LOADER_COMMAND_PATH="${BASH_SOURCE[1]}"
    declare -g CLI_LOADER_CACHE_DIR="$(cli::cache::path "${CLI_LOADER_COMMAND_PATH}")"
    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
}

cli::shebang() {
    BASH_ARGV0="$(cli::path::make_absolute "$1")"
    shift

    if [[ -v CLI_NAME ]]; then
        local -a CLI_COMMAND=( "${0##"$( dirname $(${CLI_NAME} ---which) )"}" )
        CLI_COMMAND=( ${CLI_NAME} $( IFS=/; echo ${CLI_COMMAND}; unset IFS; ) )
        ${CLI_COMMAND[@]} "$@"
    else
        local CLI_NAME=$(cli::path::name $0)
        local -a CLI_COMMAND=( "${CLI_NAME}" )
        cli::main "$@"
    fi
}

cli::loader::shim() {
    # CLI_NAME
    [[ ${CLI_NAME-} ]] \
        || cli::assert "CLI_NAME not set."

    # CLI_COMMAND
    local -a CLI_COMMAND=( "${CLI_NAME}" )
    while [[ "${1-}" =~ ${CLI_REGEX_NAME} ]]; do
        CLI_COMMAND+=( "$1" )
        shift
    done

    # CLI_SOURCE
    local -n DIR_REF="CLI_SHIM_ROOT_DIR_${CLI_COMMAND^^}"
    [[ "${DIR_REF-}" ]] \
        || cli::assert "Missing root dir for cli '${CLI_COMMAND}'."
    local CLI_SOURCE="${DIR_REF}"
    for i in "${CLI_COMMAND[@]:1}"; do
        CLI_SOURCE+="/$i"
    done

    if [[ -d "${CLI_SOURCE}" ]]; then
        CLI_SOURCE+='/.group'
    fi
   
    # $0
    BASH_ARGV0="${CLI_SOURCE}"

    [[ -f "$0" ]] \
        || cli::assert "Source file '$0' for command '${CLI_COMMAND[@]}' does not exist."

    [[ -x "$0" ]] \
        || cli::assert "Source file '$0' for command '${CLI_COMMAND[@]}' is not executable."

    # optimize for commands that depend only on the values above
    while true; do
        case "${1-}" in
            '---noop') ;;
            '---command') ;;
            '---which') ;;
            '---print') ;;
            *) break ;;
        esac
        cli::main "$@"
        exit
    done

    if (( $$ == ${BASHPID} )); then 
        cli::main "$@"
    else (            
        declare -gA CLI_SCOPE=()
        declare -ga CLI_LOADER_IMPORTS=()
        declare -gA CLI_LOADER_IMPORTED=()
        declare -gA CLI_LOADER_SOURCED=()
        declare -ga CLI_LOADER_IMPORT_PATHS=()
        cli::main "$@"
    ) fi
}

cli::main() {
    [[ -v CLI_NAME ]] \
        || cli::assert "Shim failed to define CLI_NAME."
    [[ -v CLI_COMMAND ]] \
        || cli::assert "Shim failed to define CLI_COMMAND."
    [[ "${CLI_COMMAND}" == "${CLI_NAME}" ]] \
        || cli::assert "Shim misdefined CLI_NAME and CLI_COMMAND."

    # error testing
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---assert')
                    cli::assert ;;
                '---subshell-assert')
                    ( cli::assert ) ;;
                '---err')
                    err() { return 1; }; err ;;
                '---subshell-err')
                    err() { return 1; }; ( err; ) ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---eval')
                    shift; eval "${1-}" ;;
                '---noop') ;;
                '---command')
                    echo "${CLI_COMMAND[@]}" ;;
                '---env')
                    declare -p ;;
                '---which') 
                    echo "$0" ;;
                '---print') 
                    cat "$0" ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    if [[ ! "${CLI_COMMAND[@]}" == 'cli loader' ]]; then
        cli::import::parent "${CLI_COMMAND[@]}"
        source "$0"
    fi

    # well-known options
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---imports')
                    for i in "${CLI_LOADER_IMPORTS[@]}"; do echo "${i}"; done ;;
                '---dependencies')
                    cli imports -c "${CLI_COMMAND[@]}" ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    cli::source

    # help
    for i in "$@"; do
        case "${i}" in
            '--') 
                break ;;
            '-h') ;& '--help')
                help; exit ;;
        esac
    done
    unset i

    # self-test
    if [[ "${1-}" == '--self-test' ]]; then
        shift
        if [[ "${1-}" == '--' ]]; then shift; else shift $#; fi
        self_test "$@"
        exit
    fi

    # well-known options that require imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---exports')
                    cli::loader::cache::exports ${CLI_COMMAND[@]} ;;
                '---inline')
                    cat $(${CLI_COMMAND[@]} ---exports) ;;
                '---tokenize')
                    cli::loader::dsl::tokenize ;;
                '---parse')
                    cli::loader::dsl::parse ;;
                '---meta')
                    cli::loader::dsl::meta ;;
                '---load')
                    cli::loader::dsl::load ;;
                '---bgen')
                    cli::loader::dsl::bgen ;;
                '---wire')
                    cli::loader::dsl::wire ;;
                '---wire-bash')
                    cli::loader::dsl::wire_bash ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # bgen metadata
    cli::loader::cache::bgen
    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
        source "${CLI_LOADER_BGEN_PATH}"
    fi

    # well-known options that require loaded metadata
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---import')
                    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
                        echo "${CLI_LOADER_BGEN_PATH}"
                    fi
                    ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # initialize ARG_* variables
    cli::loader::initialize "$@"

    # well-known options that require loaded arguments
    while [[ "${1-}" == ---* ]]; do
        case "$1" in
            '---args-tokenize')
                cli::write CLI_TOKENS ;;
            '---args-load')
                cli::write CLI_ARGS ;;
            '---args')
                cli::dump 'ARG_*' ;;
            '---cli')
                cli::dump 'CLI_*' ;;
            '---source')
                shift; source "$1"; shift
                continue ;;
            '---read')
                shift
                while read -a REPLY; do main "$@" "${REPLY[@]}"; done ;;
            *) cli::fail "Unexpected unknown internal option \"$1\"."
        esac 
        exit
    done

    # well known features
    if [[ -n "${ARG_RUN_AS-}" ]] && [[ ! "${ARG_RUN_AS}" == "$(whoami)" ]]; then
        arg_user="${ARG_RUN_AS}" \
        arg_command="$0" \
            ::cli::run_as::inline "$@"
        return
    fi

    # hide bash entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['bash::main']=0 )

    # hide cli entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['cli::main']=0 )

    main "${CLI_ARGS_POSITIONAL[@]}"
}

cli::initialize

# shim
cli() {
    local CLI_NAME='cli'
    cli::loader::shim "$@"
}

# these functions pre-imported because the import logic itself depends on them.
# the effect of importing pre-imported functions is to ensure the copies here
# match the source copies. 
cli::loader::import 'cli subshell temp dir'
cli::loader::import 'cli subshell temp file'
cli::loader::import 'cli subshell temp clean'
cli::loader::import 'cli subshell trap exit' \
    'cli subshell temp clean'

cli::loader::import 'cli stderr lock'
cli::loader::import 'cli stderr cat' \
    'cli stderr lock' \
    'cli subshell temp file'

cli::loader::import 'cli subshell signal-group'
cli::loader::import 'cli stderr dump' \
    'cli stderr cat' \
    'cli subshell signal-group'
cli::loader::import 'cli stderr assert' \
    'cli stderr dump' \
    'cli bash stack trace'
cli::loader::import 'cli stderr fail' \
    'cli stderr dump'

cli::loader::import 'cli bash log'
cli::loader::import 'cli bash return'
cli::loader::import 'cli bash join'
cli::loader::import 'cli bash stack call'
cli::loader::import 'cli bash stack process'
cli::loader::import 'cli bash stack trace'
cli::loader::import 'cli bash is-function-declared'
cli::loader::import 'cli bash literal'
cli::loader::import 'cli bash emit'

cli::import cli bash initialize

cli::import cli run-as

cli::import cli core declare
cli::import cli core load
cli::import cli core save
cli::import cli core write

cli::import cli args tokenize
cli::import cli args parse
cli::import cli args initialize
cli::import cli args emit

# cli::import cli name to-bash
# cli::import cli core struct emit

main() {
    echo "set -$-"
    echo

    cat <<-EOF 
		shopt -s inherit_errexit
		shopt -s lastpipe
		shopt -s globstar
		shopt -s extglob
		shopt -s nullglob
		shopt -s extdebug
		EOF
    echo

    declare -p CLI_SHIM_ROOT_DIR_CLI
    echo

    (
        declare -A CLI_SCOPE=()
        declare -a CLI_LOADER_IMPORTS=()
        declare -A CLI_LOADER_IMPORTED=()
        declare -A CLI_LOADER_SOURCED=()
        declare -a CLI_LOADER_IMPORT_PATHS=()

        declare -p CLI_SCOPE
        declare -p CLI_LOADER_IMPORTS
        declare -p CLI_LOADER_IMPORTED
        declare -p CLI_LOADER_SOURCED
        declare -p CLI_LOADER_IMPORT_PATHS
    )

    declare -p CLI_LOCK_FILE
    echo 

    declare -p CLI_REGEX_NAME
    declare -p CLI_REGEX_BASH_NAME
    declare -p CLI_REGEX_PROPERTY_ARG
    echo

    declare -p CLI_REGEX_VARIABLE_NAME
    declare -p CLI_REGEX_STRUCT_NAME
    declare -p CLI_REGEX_STRUCT_FIELD_NAME
    declare -p CLI_REGEX_TYPE_NAME
    declare -p CLI_REGEX_GLOBAL_NAME
    echo

    declare -p CLI_STACK_SHOW_HIDDEN
    declare -p CLI_STACK_SHOW_PROCESS
    echo

    declare -p CLI_TYPE_CLI_META
    declare -p CLI_TYPE_CLI_META_GROUP
    declare -p CLI_TYPE_CLI_META_TABLES
    declare -p CLI_TYPE_CLI_TOKENS
    declare -p CLI_TYPE_CLI_ARGS
    declare -p CLI_TYPE_CLI_META_ATTRIBUTE
    declare -p CLI_TYPE_CLI_META_ATTRIBUTES
    echo

    declare -p CLI_BGEN_DECLARE
    echo

    declare -p CLI_ARG_TOKEN
    declare -p CLI_ARG_TOKEN_PATH
    declare -p CLI_ARG_TOKEN_VALUE
    declare -p CLI_ARG_TOKEN_DASH
    declare -p CLI_ARG_TOKEN_DASH_DASH
    declare -p CLI_ARG_TOKEN_DASH_DASH_DASH
    declare -p CLI_ARG_TOKEN_END_OPTIONS
    declare -p CLI_ARG_TOKEN_EOF
    echo

    declare -p CLI_ARG_PRODUCTION
    declare -p CLI_ARG_PRODUCTION_SEGMENT
    declare -p CLI_ARG_PRODUCTION_OPTION
    declare -p CLI_ARG_PRODUCTION_POSITIONAL
    echo

    declare -p CLI_META_ATTRIBUTES_METHOD
    declare -p CLI_META_ATTRIBUTES_METHOD_0_TYPE
    declare -p CLI_META_ATTRIBUTES_METHOD_0_BLOB
    echo

    trap -p
    echo

    cli::export::functions::print cli | sed 's/^/# /'
    echo 

    cli::export::functions cli
    echo

    echo "main() { echo \"Unexpected missing 'main' in '\${BASH_SOURCE[1]}'.\"; }"
    echo "help() { echo \"Unexpected missing 'help' in '\${BASH_SOURCE[1]}'.\"; }"
    echo "self_test() { return; }"
    echo

    local ARG_PACK=false
    if ${ARG_PACK}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::bgen() {

            # hard coded
            if [[ -n ${CLI_SCOPE[CLI_META]+set} ]]; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::bgen
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else
        :
        # declare -f cli::loader::cache::bgen
        # declare -f cli::loader::cache::exports
        # echo

        # declare -f cli::source
        # echo

        # declare -f cli::loader::initialize
        # declare -f cli::loader::inline
        # declare -f cli::loader::inline::import
        # echo
    fi

    printf '%s\n' "${CLI_LOADER_IMPORTS[@]}" \
        | sort -u \
        | mapfile -t CLI_LOADER_DEPENDENCIES
    printf '# %s\n' "${CLI_LOADER_DEPENDENCIES[@]}"
    echo

    for import in "${CLI_LOADER_DEPENDENCIES[@]}"; do
        cli::loader::to_inline ${import}
    done | mapfile -t CLI_LOADER_INLINES
    printf '# %s\n' "${CLI_LOADER_INLINES[@]}"
    echo

    printf '%s\n' "${CLI_LOADER_INLINES[@]}" \
        | while read; do eval "declare -f ${REPLY}"; done

    echo 'cli::initialize'
}

self_test() { :; }

cli loader "$@"
