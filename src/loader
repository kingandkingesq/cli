#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

cli::reference() {
    if [[ ${CLI_REFLECT:-} == 'true' ]]; then
        echo $@ > /dev/stderr
    fi
}

cli::import() {
    cli::reference "$@"
    "$@"
}

# dry run support
cli::dry_run() {
    if [[ "${arg_dry_run:-}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:-}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:-}" == "true" ]]; then set +x; fi
    fi
}

cli::escape_args_then_call_as() {
    local user=$1
    shift

    local -a args
    for i in "$@"; do
        args+=( $(printf %q "${i}") )
    done

    sudo su "${user}" -c "${args[*]}"
}

cli::define_initialize() {

    # hard coded
    if declare -F initialize > /dev/null; then
        return
        
    # eagerly generated (like ngen)
    elif declare -F $1::define_initialize > /dev/null; then
        $1::define_initialize

    # lazily generated (like JIT)
    else
        help \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl emit \
            | source /dev/stdin
    fi
}

cli::load() {

    # dump help if '-h' or '--help' appear anywhere on the command line
    for i in "$@"; do
        if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then 
            help
            exit
        fi
    done
    unset i

    case "${1-}" in

        # run self test
        '--self-test')
            self_test
            result=$?
            if ! (( ${result} == 0 )); then
                read line file < <(caller)
                echo "Self-test failed: ${file}"
            fi
            exit ${result}
        ;;

        # only emit initialize if generated from help
        '---test-initialize')
            declare -F initialize > /dev/null
            exit
        ;;
    esac 

    cli::define_initialize "${FUNCNAME[1]}"

    case "${1-}" in
 
        # emit initialize generated from help
        '---emit-initialize')
            declare -f initialize
            exit
        ;;
    esac 

    # declare well known variables
    : ${arg_run_as:=}

    # save and verify args, then define/initialize variables
    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"

    else
        # clean up known arguments
        unset arg_run_as
        unset args
        main
    fi
}

initialize() {
    : ${arg_pack:=false}
    : ${arg_help:=false}
    : ${arg_self_test:=false}

    while (( $# > 0 )); do
        case $1 in
            '-h') ;& '--help') arg_help=true ;;
            '--self-test') arg_self_test=true ;;
            # emit the version used in packed clis
            '---pack') arg_pack=true ;; 
            *) echo "Unexpected argument '$1'."; exit 1 ;;
        esac

        shift
    done
}

main() {

    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    echo 'set -e'
    echo 'set -u' 
    # set -o pipefail
    echo

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 
    echo

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    if [[ ${CLI_REFLECT:-} == 'true' ]]; then
        # prevent JIT to prevent capturing libraries used during JIT
        echo "initialize() { return; }"
    fi

    if ${arg_pack}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else
        declare -f cli::reference
    fi

    declare -f cli::import
    declare -f cli::dry_run
    declare -f cli::escape_args_then_call_as
    declare -f cli::define_initialize
    declare -f cli::load
}

cli::load "$@"