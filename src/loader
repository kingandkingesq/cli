#!/usr/bin/env bash

# loader sourcing itself
if [[ -v CLI_IFS ]]; then
    cli::bash::function::is_declared loader_source || cli::assert
    loader_source
    return
fi

# supress background processes from displaying their exit status upon completion.
# see https://mywiki.wooledge.org/BashFAQ/024
set +m

# see https://dougrichardson.us/notes/fail-fast-bash-scripting.html
set -e
shopt -s inherit_errexit

set -u
set -o pipefail

set -E
set -o functrace

# run the last segment of a pipeline in the current execution process, not a subshell.
# see https://mywiki.wooledge.org/BashFAQ/024
shopt -s lastpipe

# If set, the pattern ‘**’ used in a filename expansion context will match all 
# files and zero or more directories and subdirectories. If the pattern is followed 
# by a ‘/’, only directories and subdirectories match.
shopt -s globstar

# If the extglob shell option is enabled using the shopt builtin, 
# several extended pattern matching operators are recognized. 
shopt -s extglob

# If set, Bash allows filename patterns which match 
# no files to expand to a null string, rather than themselves.
shopt -s nullglob

# enables BASH_ARGC and BASH_ARGV
shopt -s extdebug

# optimization
cli::loader::main() {
    if [[ ! "${1-}" == '---exports' ]]; then
        return
    fi

    local exports_path="$(cd $(dirname $0); pwd)/.cli/loader/exports.sh"
    if [[ ! -f "${exports_path}" || "$0" -nt "${exports_path}" ]]; then
        return
    fi

    echo "${exports_path}"
    exit
}
cli::loader::main "$@"
unset -f cli::loader::main

# lock
[[ ! -v CLI_IFS ]] || cli::assert
readonly CLI_IFS="$IFS"
readonly CLI_LOADER_LOCK="${CLI_LOADER_LOCK-/tmp/.cli_lock}"

# debug
declare CLI_STACK_SHOW_PROCESS
declare CLI_STACK_SHOW_HIDDEN

# regex
readonly REGEX_NAME="[a-z.][a-z0-9-]*"
readonly CLI_REGEX_NAME="^${REGEX_NAME}$"
readonly CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"
readonly CLI_REGEX_PROPERTY_ARG="^(${REGEX_NAME})=(.*)$"
readonly CLI_REGEX_BASH_FUNCTION="^[:a-z_][:a-z0-9_]*$"

readonly CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
readonly CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
readonly CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
readonly CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

readonly -A CLI_KNOWN_COMMANDS=(
    ['cli loader']=
    ['cli dsl tokenize']=
    ['cli dsl parse']=
    ['cli dsl meta']=
    ['cli dsl build']=
)

# types
readonly -A CLI_TYPE_CLI_HELP_PARSE=(
    [group]="map_of cli_help_parse_group"
)
readonly -A CLI_TYPE_CLI_HELP_PARSE_GROUP=(
    [alias]="map"
    [type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
readonly -A CLI_TYPE_CLI_META_GROUP=(
    [type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
readonly -A CLI_TYPE_CLI_META=(
    [alias]="map"
    [group]="map_of cli_meta_group"
    #[attributes]="map_of cli_meta_attributes"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTE=(
    [type]="array"
    [blob]="array"
)
readonly -A CLI_TYPE_CLI_META_ATTRIBUTES=(
    [method]="map_of cli_meta_attribute"
)
readonly -A CLI_TYPE_CLI_TOKENS=(
    [id]="array"
    [identifier]="array"
)
readonly -A CLI_TYPE_CLI_ARGS=(
    [path]="array"
    [first_named]="string"
    [named]="map_of array"
    [positional]="array"
)
readonly -A CLI_TYPE_CLI_BASH_STACK_HIDDEN_ATTRIBUTE=()

# tokens
readonly -a CLI_ARG_TOKEN=(
    [0]="PATH"
    [1]="VALUE"
    [2]="DASH"
    [3]="DASH_DASH"
    [4]="DASH_DASH_DASH"
    [5]="END_OPTIONS"
    [6]="EOF"
)
readonly CLI_ARG_TOKEN_PATH="0"
readonly CLI_ARG_TOKEN_VALUE="1"
readonly CLI_ARG_TOKEN_DASH="2"
readonly CLI_ARG_TOKEN_DASH_DASH="3"
readonly CLI_ARG_TOKEN_DASH_DASH_DASH="4"
readonly CLI_ARG_TOKEN_END_OPTIONS="5"
readonly CLI_ARG_TOKEN_EOF="6"

# productions
readonly -a CLI_ARG_PRODUCTION=(
    [0]="SEGMENT"
    [1]="OPTION"
    [2]="POSITIONAL"
)
readonly CLI_ARG_PRODUCTION_SEGMENT="0"
readonly CLI_ARG_PRODUCTION_OPTION="1"
readonly CLI_ARG_PRODUCTION_POSITIONAL="2"

# attributes
declare -A CLI_META_ATTRIBUTES_METHOD=(
    # ['cli::bash::stack::call']=0
    # ['cli::bash::stack::trace']=0
    # ['cli::stderr::assert']=0
    # ['cli::assert']=0
    
    # ['cli::main']=0
    # ['bash::main']=0
    
    # ['cli::trap::err']=0
)
readonly -a CLI_META_ATTRIBUTES_METHOD_0_TYPE=( 'cli_bash_stack_hidden_attribute' )
readonly -a CLI_META_ATTRIBUTES_METHOD_0_BLOB=()

# globals
declare -A CLI_LOADER_IMPORTED=(
    ["cli .group"]=true
    ["cli attribute .group"]=true
    ["cli bash .group"]=true
    ["cli cache .group"]=true
    ["cli name .group"]=true
    ["cli path .group"]=true
    ["cli set .group"]=true
    ["cli shim .group"]=true
    ["cli stderr .group"]=true
    ["cli subshell .group"]=true
    ["cli temp .group"]=true
)
declare -A CLI_LOADER_COVERED=()
declare -A CLI_LOADER_SOURCED_PATHS=()

# debug
declare -a CLI_COMMAND_STACK=()

# frame
declare -A CLI_SCOPE=()

# statics
declare -a CLI_LOADER_CLI_LOADER_IMPORT=()
declare -n CLI_IMPORT='CLI_LOADER_CLI_LOADER_IMPORT'

inline() {

    source "${CLI_SHIM_ROOT_DIR_CLI}/set/test.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/set/deflower.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/name/to-bash.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/name/to-inline.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/name/to-function.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/name/to-symbol.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/name/parse.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/attribute/is-defined.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/path/get-info.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/path/dir.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/path/name.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/path/make-absolute.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/cache/path.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/cache/put.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/cache/test.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/lock.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/function/list.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/filter/glob.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/printf.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/log.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/which.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/return.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/join.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/stack/call.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/stack/process.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/stack/trace.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/function/is-declared.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/literal.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/variable/list.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/variable/emit.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/array/pop.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/bash/map/copy.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/subshell/on-exit.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/subshell/signal-group.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/temp/remove.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/temp/file.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/temp/dir.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/temp/fifo.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/cat.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/dump.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/assert.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/fail.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/stderr/on-err.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/shim/source.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/shim/probe.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/shim/which.sh"
    source "${CLI_SHIM_ROOT_DIR_CLI}/shim/shebang.sh"
}

# public
cli::export() {
    cli::loader::emit::variables "$@"
    cli::loader::emit::functions "$@"
}

cli::source() {
    (( $# > 0 )) || cli::assert 'Missing import.'
    
    CLI_IMPORT+=( "$*" )
}

# loader library
cli::loader::help() {
    echo
    echo 'Global Arguments'
    echo '    --help -h        [Flag] : Show this message and exit.'
    echo '    --self-test      [Flag] : Runs a self test.'
}

cli::loader::emit::functions() {
    cli::loader::function::list "$@" \
        | while read; do 
            declare -f "${REPLY}"
        done
}

cli::loader::emit::variables() {
    local DECLARE FLAGS VALUE

    cli::loader::variable::list "$@" \
        | while read DECLARE FLAGS VALUE; do
            echo "declare ${FLAGS}g ${VALUE}" 
        done
}

cli::loader::emit::imports() {
    cli::bash::printf 'cli::source %s\n' "$@"
}

cli::loader::function::list() {
    local GLOB

    for i in "$@"; do 
        GLOB+="${i}::"
    done
    GLOB+='*'

    cli::bash::function::list "${GLOB}"
}

cli::loader::variable::list() {
    local -u GLOB

    for i in "$@"; do 
        GLOB+="${i^^}_"; 
    done

    cli::dump "${GLOB}*"
}

cli::loader::cache::path() {
    REPLY="${CLI_CACHE}/$1"
}

cli::loader::cache::test() {
    cli::loader::cache::path "$@"
    cli::cache::test "${REPLY}" "${CLI_SOURCE}" "${CLI_LOADER_CLI_LOADER_SOURCE}"
}

# loader core
cli::loader::import_parent() {
    local COMMAND=( "${CLI_COMMAND[@]}" )

    # no hierarchy
    if (( ${#COMMAND[@]} < 2 )); then 
        return
    fi

    # group
    if [[ "${COMMAND[@]: -1}" == '.group' ]]; then

        # root has no parent command; (e.g. 'cli .group')
        if (( ${#COMMAND[@]} == 2 )); then 
            return
        fi

        # slice off '.group'; (e.g. 'cli util .group' => 'cli util')
        COMMAND=( "${COMMAND[@]:0:$(( ${#COMMAND[@]}-1 ))}" )
    fi

    # slice off last command and append '.group'
    COMMAND=( "${COMMAND[@]:0:$(( ${#COMMAND[@]}-1 ))}" '.group' )

    if cli::set::test CLI_LOADER_IMPORTED "${COMMAND[*]}"; then
        return
    fi

    # check no variables exist that should be imported with this group
    cli::bash::array::pop "${COMMAND[@]}"

    # TODO: expect only the group main function; e.g. cli::args::group::main
    if ! diff <( cli::loader::emit::variables "${MAPFILE[@]}" ) - < /dev/null > /dev/null; then
        echo "Attempt to import '${COMMAND[@]}' but variables already defined:" >&2
        cli::export "${MAPFILE[@]}" | sed 's/^/  /' >&2
        cli::assert "${MAPFILE[@]}"
    fi

    # import parent
    # echo "${CLI_COMMAND[@]} -> ${COMMAND[@]}" >&2
    "${COMMAND[@]}" ---source
}

cli::loader::backpatch() {

    cli::name::to_inline "${CLI_COMMAND[@]}"
    set "${REPLY}"

    cli::bash::function::is_declared "$1" \
        || cli::assert "No stub '$1' found to backpatch."

    # unset stub
    unset -f "$1"

    # backpatch stub
    cli::loader::source::exports

    cli::bash::function::is_declared "$1" \
        || cli::assert "Failed to backpatch stub '$1'."

    cli::loader::main::cover
}

cli::loader::import() {
    if ! cli::set::deflower CLI_LOADER_IMPORTED "${CLI_COMMAND[*]}"; then
        return
    fi

    # loader
    [[ ! "${CLI_COMMAND[@]}" == 'cli loader' ]] \
        || cli::assert 'Importing the loader is disallowed.'

    cli::loader::import_parent

    cli::name::to_inline "${CLI_COMMAND[@]}"
    local FUNCTION=${REPLY}

    # skip if inline function already imported
    if cli::bash::function::is_declared "${FUNCTION}"; then

        # this happens when:
        #   1. the loader declares functions it is also importing which it does 
        #       because the loader cannot load it's own dependencies.
        #   2. two libraries A and B both import inline function I and
        #       A emits the thunk for I and then B goes to emit the same thunk for I
        #   3. recursive calls of an inline function
        return
    fi

    # emit inline stub
    if [[ ${CLI_TYPE} == inline ]]; then
        eval "${FUNCTION}() { ${CLI_COMMAND[@]} ---backpatch; ${FUNCTION} \"\$@\"; }"
        cli::bash::function::is_declared "${FUNCTION}" || cli::assert
        return
    fi

    [[ ! "${CLI_COMMAND[@]}" == 'cli dispatch parse' ]] || cli::assert ${CLI_TYPE}

    # missing group
    if [[ ! -f "${CLI_SOURCE}" ]]; then
        [[ ${CLI_TYPE} == group ]] || cli::assert
        return
    fi

    # echo "importing ${CLI_COMMAND[*]}" >&2

    # source the import!
    cli::loader::source::exports
}

cli::loader::source::exports() {

    if ! cli::loader::cache::test 'exports.sh'; then 
        ${CLI_COMMAND[@]} ---exports > /dev/null
    fi

    cli::loader::cache::path 'exports.sh'
    cli::loader::source "${REPLY}"
}

cli::loader::source() {
    cli::path::make_absolute "$1"
    set "${REPLY}"

    if ! cli::set::deflower CLI_LOADER_SOURCED_PATHS "$1"; then
        return
    fi

    [[ -f "$1" ]] || cli::assert "File missing. Cannot source path '$1'."
    source "$1"
}

cli::loader::shim() {

    # error handling should work before doing anything
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---eval0')
                    shift
                    eval "$@" ;;
                '---assert')
                    cli::assert ;;
                '---subshell-assert')
                    ( cli::assert ) ;;
                '---err')
                    err() { return 1; }; err ;;
                '---subshell-err')
                    err() { return 1; }; ( err; ) ;;
                *)
                    break ;;
            esac
            return
        done
    fi

    # CLI_NAME
    [[ "${CLI_NAME}" ]] || cli::assert "Shim failed to define CLI_NAME."
    [[ "${CLI_NAME}" =~ ${CLI_REGEX_NAME} ]] || cli::assert "Bad shim name."

    # CLI_COMMAND
    cli::name::parse "$@"
    local -a CLI_COMMAND=( "${CLI_NAME}" "${MAPFILE[@]}" )
    shift ${#MAPFILE[@]}

    # CLI_SYMBOL
    cli::name::to_symbol "${CLI_COMMAND[@]}"
    local CLI_SYMBOL="CLI_LOADER_${REPLY}"

    # CLI_GROUP
    local -n CLI_GROUP="${CLI_SYMBOL}_GROUP"
    if [[ ! -v CLI_GROUP ]]; then
        CLI_GROUP="${CLI_COMMAND[@]: 0: $(( ${#CLI_COMMAND[@]} -1 )) }"
    fi

    # CLI_COMMAND_NAME
    local -n CLI_COMMAND_NAME="${CLI_SYMBOL}_NAME"
    if [[ ! -v CLI_COMMAND_NAME ]]; then
        CLI_COMMAND_NAME=${CLI_COMMAND[@]: -1}
    fi

    # CLI_META
    local CLI_META="${CLI_SYMBOL}_META"

    # CLI_TYPE
    local -n CLI_TYPE="${CLI_SYMBOL}_TYPE"
    if [[ ! -v CLI_TYPE ]]; then
        CLI_TYPE=command

        if [[ ${CLI_COMMAND_NAME} == '.group' ]]; then
            CLI_TYPE=group
        fi
    fi

    # CLI_SOURCE
    local -n CLI_SOURCE="${CLI_SYMBOL}_SOURCE"
    if [[ ! -v CLI_SOURCE ]]; then
        cli::shim::probe "${CLI_COMMAND[@]}" \
            || cli::assert "Failed to find source for '${CLI_COMMAND[@]}'. Probed ${MAPFILE[@]}"
        CLI_SOURCE="${REPLY}"

        if [[ "${CLI_SOURCE}" == *.sh ]]; then
            CLI_TYPE=inline
        fi

        # file exists unless its a group in which case it's optional
        [[ ${CLI_TYPE} == group || -f "${CLI_SOURCE}" ]] \
            || cli::assert "Source file '${CLI_SOURCE}' for command '${CLI_COMMAND[*]}' does not exist."

        # file is executable if it exists
        [[ ! -f "${CLI_SOURCE}" || -x "${CLI_SOURCE}" ]] \
            || cli::assert "Source file '${CLI_SOURCE}' for command '${CLI_COMMAND[*]}' is not executable."
    fi

    # CLI_CACHE
    local -n CLI_CACHE="${CLI_SYMBOL}_CACHE"
    if [[ ! -v CLI_CACHE ]]; then
        cli::cache::path "${CLI_SOURCE}"
        CLI_CACHE="${REPLY}"
    fi


    # CLI_FUNCTION, MAIN, INLINE, and SELF_TEST
    local -n CLI_FUNCTION_MAIN="${CLI_SYMBOL}_FUNCTION_MAIN"
    local -n CLI_FUNCTION_INLINE="${CLI_SYMBOL}_FUNCTION_INLINE"
    local -n CLI_FUNCTION_SELF_TEST="${CLI_SYMBOL}_FUNCTION_SELF_TEST"
    local -n CLI_FUNCTION_HELP="${CLI_SYMBOL}_FUNCTION_HELP"
    if [[ ! -v CLI_FUNCTION_MAIN ]]; then

        if [[ ${CLI_TYPE} == group ]]; then
            cli::name::to_function ${CLI_GROUP}
        else
            cli::name::to_function "${CLI_COMMAND[@]}"
        fi

        CLI_FUNCTION_INLINE="${REPLY}"
        CLI_FUNCTION_MAIN="${REPLY}::main"
        CLI_FUNCTION_SELF_TEST="${REPLY}::self_test"
        CLI_FUNCTION_HELP="${REPLY}::help"
    fi

    # CLI_IMPORT
    local -n CLI_IMPORT="${CLI_SYMBOL}_IMPORT"
    if [[ ! -v CLI_IMPORT ]]; then
        declare -ag "${CLI_SYMBOL}_IMPORT+=()"
    fi

    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---type')
                    echo ${CLI_TYPE} ;;
                '---which') 
                    echo "${CLI_SOURCE}" ;;
                '---cache')
                    echo "${CLI_CACHE}" ;;
                '---print') 
                    cat "${CLI_SOURCE}" ;;
                '---source')
                    cli::loader::import ;;
                '---backpatch')
                    cli::loader::backpatch ;;
                '---exports')
                    if ! cli::loader::cache::test 'exports.sh'; then 
                        break
                    fi
                    echo "${REPLY}" ;;
                *)
                    break ;;
            esac
            return
        done
    fi

    cli::loader::main::prolog "$@"
}

cli::loader::main::prolog() {

    # $0
    BASH_ARGV0="${CLI_SOURCE}"

    # reset bash variables
    IFS="${CLI_IFS}"

    # establish frame
    # local -A CLI_SCOPE=(
    #     [CLI_NAME]='string'
    #     [CLI_COMMAND]='array'
    #     [CLI_IMPORT]='array'
    # )

    # stack
    # local -a CLI_COMMAND_STACK=( "${CLI_COMMAND_STACK[@]}" "${CLI_COMMAND[*]}" )

    cli::loader::import_parent

    # unset -f help
    # unset -f self_test

    # source the code!
    cli::loader::source "${CLI_SOURCE}"

    [[ ${CLI_TYPE} == inline ]] \
        || [[ "${CLI_FUNCTION_INLINE}" == 'cli' ]] \
        || ! cli::bash::function::is_declared ${CLI_FUNCTION_INLINE} \
        || cli::assert "Command '${CLI_COMMAND[*]}' source '${CLI_SOURCE}'" \
            "declares '${CLI_FUNCTION_INLINE}' but is missing .sh".

    # imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---exports')
                    ! cli::loader::cache::test 'exports.sh' || cli::assert
                    cli::loader::main::dispatch \
                        | cli::cache::put "${REPLY}"
                    echo "${REPLY}" ;;
                '---dependencies')
                    cli imports -c "${CLI_COMMAND[@]}" ;;
                *) break ;;
            esac 
            return
        done
    fi

    cli::loader::main::dispatch "$@"
}

cli::loader::main::help() {

    # -h anywhere (except after --) prints help and exits
    while (( $# > 0 )); do
        case "$1" in
            '--') 
                break ;;
            '-h') ;& '--help')
                cli::loader::main::invoke ${CLI_FUNCTION_HELP} 
                cli::loader::help
                return ;;
        esac
        shift
    done

    return 1
}

cli::loader::main::dispatch() {
    
    [[ -v CLI_NAME ]] || cli::assert
    [[ -v CLI_TYPE ]] || cli::assert
    [[ -v CLI_COMMAND ]] || cli::assert

    # help
    if cli::loader::main::help "$@"; then
        return
    fi

    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---env')
                    declare -p ;;
                '---imports')
                    for i in "${CLI_IMPORT[@]}"; do echo "${i}"; done ;;
                *) break ;;
            esac 
            return
        done
    fi

    # self test
    if [[ "${1-}" == '--self-test' ]]; then
        cli::loader::main::invoke "${CLI_FUNCTION_SELF_TEST}"
        return
    fi

    # inline
    if [[ "${CLI_TYPE}" == 'inline' ]]; then
        cli::loader::main::inline "$@"

    # group
    elif [[ "${CLI_TYPE}" == 'group' ]]; then
        cli::loader::main::group "$@"

    # command
    else
        [[ "${CLI_TYPE}" == 'command' ]] || cli::assert
        cli::loader::main::command "$@"
    fi
}

cli::loader::main::group() {
    [[ "${CLI_COMMAND[@]: -1}" == '.group' ]] || cli::assert

    if [[ "${1-}" == '-l' ]]; then
        cli::path::dir "${CLI_SOURCE}"
        cli list --dir "${REPLY}"
        return
    fi

    (( $# == 0 )) \
        || cli::assert "Unexpected arguments passed to '${CLI_COMMAND[*]}': $@"

    if cli::loader::cache::test 'exports.sh'; then 
        cat "${REPLY}"
        return
    fi

    cli::loader::main::invoke "${CLI_FUNCTION_MAIN}" "$@"
}

cli::loader::main::inline() {
    [[ "${CLI_FUNCTION_INLINE}" ]] || cli::assert

    # well-known options that require imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---reply')
                    shift
                    cli::loader::main::inline -- "$@"
                    echo "${REPLY-}" ;;
                '---mapfile')
                    shift
                    cli::loader::main::inline -- "$@"
                    for REPLY in "${MAPFILE[@]}"; do
                        echo "${REPLY-}" 
                    done ;;
                '---pipe')
                    shift
                    while read -a MAPFILE; do 
                        cli::loader::main::inline -- "$@" "${MAPFILE[@]}"
                    done ;;
                '---') 
                    break ;;
                *) cli::assert "Unexpected unknown internal option \"$1\" for command '${CLI_COMMAND[*]}'."
            esac 
            return
        done
    fi

    if (( $# > 0 )); then
        if [[ "${1-}" == '--' || "${1-}" == '---' ]]; then
            shift
        fi

        if cli::bash::function::is_declared ${CLI_FUNCTION_MAIN}; then
            cli::loader::main::invoke ${CLI_FUNCTION_MAIN} "$@"
            return
        fi

        cli::loader::main::invoke ${CLI_FUNCTION_INLINE} "$@"
        return
    fi

    # emit dependencies and function
    cli::loader::emit::imports "${CLI_IMPORT[@]}"
    declare -f ${CLI_FUNCTION_INLINE}
}

cli::loader::main::command::load() {
    if cli::loader::cache::test 'meta.sh'; then
        cli::loader::source "${REPLY}"
        return
    fi
    local META_SH="${REPLY}"
    
    mkdir -p "${CLI_CACHE}"

    local HELP="${CLI_CACHE}/help"
    local TOKENIZE="${CLI_CACHE}/tokenize"
    local PARSE="${CLI_CACHE}/parse"
    local META="${CLI_CACHE}/meta"
    local LOAD="${CLI_CACHE}/load"

    if [[ -f "${META_SH}" && -f "${HELP}" ]] \
        && diff "${HELP}" <( cli::loader::main::dispatch -h ) > /dev/null; then
        cli::loader::source "${META_SH}"
        return
    fi

    cli::loader::main::dispatch -h | \
        ARG_SCOPE=CLI_SCOPE \
        ARG_CLI_DSL_DECLARE_HELP="${HELP}" \
        ARG_CLI_DSL_DECLARE_TOKENIZE="${TOKENIZE}" \
        ARG_CLI_DSL_DECLARE_PARSE="${PARSE}" \
        ARG_CLI_DSL_DECLARE_META="${META}" \
        ARG_CLI_DSL_DECLARE_LOAD="${LOAD}" \
            cli dsl build -- "${CLI_META}" \
                | cli::cache::put "${META_SH}"

    cli::loader::source "${META_SH}"
}

cli::loader::main::command() {

    # parsing
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---tokenize')
                    cli::loader::main::dispatch -h | cli dsl tokenize ;;
                '---parse')
                    ${CLI_COMMAND[@]} ---tokenize | cli dsl parse ;;
                '---meta')
                    ${CLI_COMMAND[@]} ---parse | cli dsl meta ;;
                '---load')
                    ${CLI_COMMAND[@]} ---meta | cli dsl load -- ;;
                '---build')
                    cli::loader::main::dispatch -h \
                        | ARG_SCOPE=CLI_SCOPE cli dsl build -- "${CLI_META}" ;;
                *) break ;;
            esac 
            return
        done
    fi

    if cli::set::test CLI_KNOWN_COMMANDS "${CLI_COMMAND[*]}"; then
        cli::loader::main::command::known "$@"
        return
    fi

    cli::loader::main::command::load

    ARG_SCOPE=CLI_SCOPE \
        cli::dispatch::parse "$@"
    local CLI_META_GROUP=${REPLY}

    # declare locals for group
    local -A CLI_SCOPE_LAST=()
    local -n CLI_META_GROUP_TYPE=${CLI_META_GROUP}_TYPE
    for REPLY in ${!CLI_META_GROUP_TYPE[@]}; do

        # variable name
        local NAME=${REPLY}
        cli::name::to_symbol ${NAME}
        local VARIABLE="ARG_${REPLY}"

        # variable flags
        local TYPE="${CLI_META_GROUP_TYPE[${NAME}]}"
        cli::core::type::to_bash ${TYPE}
        local FLAGS="${REPLY}"

        # declare variable
        local -${FLAGS} ${VARIABLE}
        
        # prolog
        CLI_SCOPE_LAST[${VARIABLE}]=CLI_SCOPE[${VARIABLE}]
        CLI_SCOPE[${VARIABLE}]="${TYPE}"

        # initialize variable
        if cli::set::test REPLY_CLI_PARSE_ARGS_NAMED ${NAME}; then
            local -n VARIABLE_REF=${VARIABLE}
            local -n VALUE_REF="REPLY_CLI_PARSE_ARGS_NAMED_${REPLY_CLI_PARSE_ARGS_NAMED[${NAME}]}"
            case ${TYPE} in
                'array') VARIABLE_REF=( "${VALUE_REF[@]}" ) ;;
                'map')
                    local PAIR
                    for PAIR in "${VALUE_REF[@]}"; do
                        VARIABLE_REF[${PAIR%%=*}]="${PAIR#*=}"
                    done
                    ;;
                *) VARIABLE_REF="${VALUE_REF}" ;;
            esac
        else
            # default value
            ARG_SCOPE=CLI_SCOPE \
                cli::core::variable::initialize ${VARIABLE}
        fi

        # declare -p ${VARIABLE} >&2
    done
    unset TYPE NAME VARIABLE FLAGS PAIR
    unset -n VARIABLE_REF VALUE_REF

    # cli::dump 'REPLY_CLI_PARSE_ARGS_*' >&2

    cli::loader::main::command::dispatch "${REPLY_CLI_PARSE_ARGS_POSITIONAL[@]}"

    # epilog
    for REPLY in ${!CLI_SCOPE_LAST[@]}; do
        CLI_SCOPE[${REPLY}]=CLI_SCOPE_LAST[${REPLY}]
    done
}

cli::loader::main::command::known() {
    ARG_HELP=false
    ARG_SELF_TEST=false

    if (( $# > 0 )); then
        [[ "$1" == '--' ]] || cli::assert
        shift
    fi

    cli::loader::main::command::dispatch "$@"
}

cli::loader::main::command::dispatch() {

    # well-known options that require loaded arguments
    while [[ "${1-}" == ---* ]]; do
        case "$1" in
            '---args-tokenize')
                cli::write CLI_TOKENS ;;
            '---args-load')
                cli::write CLI_ARGS ;;
            '---args')
                cli::dump 'ARG_*' ;;
            '---cli')
                cli::dump 'CLI_*' ;;
            '---read')
                shift
                while read -a REPLY; do ${CLI_FUNCTION_MAIN} "$@" "${REPLY[@]}"; done ;;
            *) cli::stderr::fail "Unexpected unknown internal option \"$1\"."
        esac 
        return
    done

    # well known features
    if [[ -n "${ARG_RUN_AS-}" ]] \
        && [[ ! "${ARG_RUN_AS}" == "$(whoami)" ]]; then
        arg_user="${ARG_RUN_AS}" \
        arg_command="$0" \
            cli::run_as "$@"
        return
    fi

    cli::loader::main::invoke ${CLI_FUNCTION_MAIN} "$@"
}

cli::loader::main::cover() {
    if ! cli::set::deflower CLI_LOADER_COVERED "${CLI_COMMAND[*]}"; then
        return
    fi

    for REPLY in "${CLI_IMPORT[@]}"; do
        set ${REPLY}

        cli::shim::source "$1" \
            || cli::assert "Failed to find shim '$1' for import of '$*'."

        # echo "cover ${CLI_COMMAND[*]}: $@ ---source" >&2
        "$@" ---source
    done
}

cli::loader::main::invoke() {
    local CLI_FUNCTION="$1"
    shift

    cli::bash::function::is_declared ${CLI_FUNCTION} \
        || cli::assert "Command '${CLI_COMMAND[@]}' missing entrypoint '${CLI_FUNCTION}'."

    cli::loader::main::cover

    ${CLI_FUNCTION} "$@"
}

cli::dump() {
    cli::bash::variable::emit "$@"
}

loader_source() {

    diff_import() {
        cli::source $1

        if [[ -n "${CLI_LOADER_IMPORT_DISABLE-}" ]]; then
            while (( $# > 0 )); do 
                CLI_LOADER_IMPORTED[$1]=true
                shift
            done

            return
        fi

        local COMMAND="$1"
        shift

        CLI_LOADER_COVERED["${COMMAND}"]=true

        # capture existing function
        cli::name::to_inline ${COMMAND}
        FQN="${REPLY}"

        cli::bash::function::is_declared ${FQN} \
            || cli::assert "Expected '${FQN}' to be inlined into loader."
        local EXISTING_FUNCTION=$(
            cli::loader::emit::imports "$@"
            declare -f ${FQN}
        )

        # assert exiting function matches inlined function
        local DIFF=$(diff <(echo "${EXISTING_FUNCTION}") $(${COMMAND} ---exports) || true)

        if [[ -n "${DIFF}" ]]; then

            cli::shim::probe ${COMMAND}
            echo "EXISTING_FUNCTION != INLINE_FUNCTION, FQN=${FQN}, ${REPLY}"
            echo "to disable check declare -x CLI_LOADER_IMPORT_DISABLE=1"
            
            echo "---diff---"
            echo "${DIFF}"

            echo "---existing---"
            echo "${EXISTING_FUNCTION}"

            # capture inline function    
            echo "---inline---"
            local INLINE_FUNCTION
            INLINE_FUNCTION=$(${COMMAND}) \
                || cli::assert "Expected command '${COMMAND}' to export inline function."
            echo "${INLINE_FUNCTION}"
            exit 1
        fi >&2
    }

    # these functions pre-imported because the import logic itself depends on them
    diff_import 'cli set test'
    diff_import 'cli set deflower' \
        'cli set test'

    diff_import 'cli path get-info'
    diff_import 'cli path name'
    diff_import 'cli path dir'
    diff_import 'cli path make-absolute'

    diff_import 'cli subshell signal-group'
    diff_import 'cli subshell on-exit'

    diff_import 'cli temp remove'
    diff_import 'cli temp file' \
        'cli temp remove' \
        'cli subshell on-exit'
    diff_import 'cli temp dir' \
        'cli temp file'

    diff_import 'cli temp fifo' \
        'cli temp file'

    diff_import 'cli cache test'
    diff_import 'cli cache path' \
        'cli path dir' \
        'cli path name'
    diff_import 'cli cache put' \
        'cli path dir' \
        'cli temp file'

    diff_import 'cli stderr lock'
    diff_import 'cli stderr cat' \
        'cli stderr lock' \
        'cli temp file'
    diff_import 'cli stderr dump' \
        'cli stderr cat' \
        'cli subshell signal-group'
    diff_import 'cli stderr assert' \
        'cli stderr dump' \
        'cli bash stack trace'
    diff_import 'cli stderr fail' \
        'cli stderr dump'
    diff_import 'cli stderr on-err' \
        'cli stderr dump' \
        'cli bash stack trace'

    diff_import 'cli bash array pop'
    diff_import 'cli bash map copy' \
        'cli set test'
    
    diff_import 'cli bash filter glob'
    diff_import 'cli bash function list' \
        'cli bash filter glob'
    diff_import 'cli bash which' \
        'cli path get-info'
    diff_import 'cli bash log'
    diff_import 'cli bash printf'
    diff_import 'cli bash return'
    diff_import 'cli bash join'
    diff_import 'cli bash literal'
    diff_import 'cli bash function is-declared'

    diff_import 'cli name parse'
    diff_import 'cli name to-bash'
    diff_import 'cli name to-inline' \
        'cli name to-bash' \
        'cli bash join'
    diff_import 'cli name to-function' \
        'cli name to-bash' \
        'cli bash join'
    diff_import 'cli name to-symbol' \
        'cli name to-bash' \
        'cli bash join'

    diff_import 'cli attribute is-defined'
    diff_import 'cli bash stack call' \
        'cli bash literal' \
        'cli attribute is-defined'
    diff_import 'cli bash stack process'
    diff_import 'cli bash stack trace' \
        'cli bash stack process' \
        'cli bash stack call'

    diff_import 'cli shim source' \
        'cli bash which' \
        'cli bash function is-declared'
    diff_import 'cli shim which' \
        'cli shim source'
    diff_import 'cli shim probe' \
        'cli shim which'
    diff_import 'cli shim shebang' \
        'cli path make-absolute' \
        'cli path name' \
        'cli shim source'

    # cli::source cli bash array pop
    diff_import 'cli bash variable list'
    diff_import 'cli bash variable emit' \
        'cli bash variable list'

    cli::source cli dispatch parse

    cli::loader::main() {

        echo "set -$-"
        echo

        declare -p CLI_IFS
        echo

        shopt -p | sort -k2 -k3
        echo

        #cli::loader::emit::variables cli | sort -k4
        {
            (
                CLI_LOADER_SOURCED_PATHS=()
                CLI_COMMAND_STACK=()
                CLI_SCOPE=()

                declare -p CLI_LOADER_SOURCED_PATHS
                declare -p CLI_COMMAND_STACK
                declare -p CLI_SCOPE
            )
            declare -p CLI_LOADER_IMPORTED
            declare -p CLI_LOADER_COVERED
            declare -p CLI_LOADER_LOCK

            declare -p CLI_LOADER_CLI_LOADER_SOURCE
            declare -p CLI_LOADER_CLI_LOADER_IMPORT

            cli::loader::emit::variables cli regex
            cli::loader::emit::variables cli known
            cli::loader::emit::variables cli type
            cli::loader::emit::variables cli bgen
            cli::loader::emit::variables cli arg
            cli::loader::emit::variables cli meta attributes

        } | sort -k2 -k3
        echo

        echo '# cli core'
        cli::export cli core
        echo

        echo '# TOC of cli::*'
        cli::loader::function::list cli | sed 's/^/# /'
        echo 

        cli::loader::emit::functions cli
        echo

        declare -f cli
        declare -f loader_source
        echo

        (( ${#CLI_LOADER_COVERED[@]} > 0 )) || cli::assert
        unset "CLI_LOADER_COVERED['cli loader']"

        declare -f cli::dispatch::parse

        printf '%s\n' "${!CLI_LOADER_COVERED[@]}" \
            | sort -u \
            | mapfile -t
        printf '# cli::source %s\n' "${MAPFILE[@]}"
        echo

        for import in "${MAPFILE[@]}"; do
            cli::name::to_inline ${import}
            echo "${REPLY}" 
        done | mapfile -t
        printf '# %s\n' "${MAPFILE[@]}"
        echo

        printf '%s\n' "${MAPFILE[@]}" \
            | while read; do eval "declare -f ${REPLY}"; done

        trap -p
        echo
    }

    self_test() (
        cli loader ---exports
    )
}

cli::initialize() {

    # ${bash_source[1]} '.cli/loader/exports.sh'
    # ${bash_source[2]} the command itself
    declare -g CLI_LOADER_COMMAND_PATH="${BASH_SOURCE[1]}"
    cli::cache::path "${CLI_LOADER_COMMAND_PATH}"
    declare -g CLI_LOADER_CACHE_DIR="${REPLY}"

    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
}

trap 'cli::stderr::on_err $?' ERR

cli::assert() {
    cli::stderr::assert "$@"
}

# shim
source "$( cd $(dirname ${BASH_SOURCE}); cd ..; pwd)/cli"
inline
cli::initialize

# cli::bash::function::is_declared 'cli' || cli::assert
# [[ -v CLI_SHIM_ROOT_DIR_CLI ]] || cli::assert

cli loader "$@"

# cat src/loader | egrep -o cli::[a-z:_]+ | sort -u | grep -v cli::loader
