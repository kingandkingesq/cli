#!/usr/bin/env bash
help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::main'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

cli::meta::declare() {
    :
}

cli::shopt() {
    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    set +m

    # see https://dougrichardson.us/notes/fail-fast-bash-scripting.html
    set -e
    shopt -s inherit_errexit

    set -u
    set -o pipefail

    set -E
    set -o functrace
    
    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    shopt -s lastpipe

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    shopt -s globstar

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    shopt -s extglob

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    shopt -s nullglob

    # enables BASH_ARGC and BASH_ARGV
    shopt -s extdebug
}
cli::shopt

# cache
declare BASH_DIR="${BASH_SOURCE%/*}"
declare BASH_NAME="${BASH_SOURCE##*/}"
declare CACHE_DIR="${BASH_DIR}/.cli/${BASH_NAME}"
declare EXPORTS_PATH="${CACHE_DIR}/exports.sh"
if [[ -f "${EXPORTS_PATH}" && "${1-}" == '---exports' ]] \
    && [[ "${EXPORTS_PATH}" -nt "${BASH_SOURCE}" ]]; then
    echo "${EXPORTS_PATH}"
    exit
fi

# debug
declare CLI_STACK_SHOW_PROCESS=
declare CLI_STACK_SHOW_HIDDEN=
declare CLI_ASSERT_EXIT=411

# temp
declare CLI_TEMP_TEMPLATE='XXXXXXXXXXXX'

# regex
declare CLI_REGEX_NAME_RAW="[a-z.][a-z0-9-]*"
declare CLI_REGEX_NAME="^${CLI_REGEX_NAME_RAW}$"
declare CLI_REGEX_BASH_NAME="^[a-z_][a-z0-9_]*$"
declare CLI_REGEX_PROPERTY_ARG="^(${CLI_REGEX_NAME_RAW})=(.*)"

declare CLI_REGEX_VARIABLE_NAME="^[a-z][a-z0-9_]*$"
declare CLI_REGEX_STRUCT_NAME=${CLI_REGEX_VARIABLE_NAME}
declare CLI_REGEX_STRUCT_FIELD_NAME=${CLI_REGEX_VARIABLE_NAME}
declare CLI_REGEX_TYPE_NAME="^(map_of[[:space:]])*[a-z][a-z0-9_]*$"
declare CLI_REGEX_GLOBAL_NAME="^[A-Z][A-Z0-9_]*$"

# types
declare -A CLI_TYPE_CLI_META_TABLES=(
    # TODO: remove?
    [alias]="map"
    [type]="map_of map"
    [require]="map_of map"
    [default]="map_of map"
    [regex]="map_of map"
    [allow]="map_of map_of map"
    [positional]="map_of boolean" \
)
declare -A CLI_TYPE_CLI_META_GROUP=(
    [type]="map"
    [bash_type]="map"
    [require]="map"
    [default]="map"
    [regex]="map"
    [allow]="map_of map"
    [positional]="boolean"
)
declare -A CLI_TYPE_CLI_META=(
    [alias]="map"
    [bash_name]="map"
    [group]="map_of cli_meta_group"
    #[attributes]="map_of cli_meta_attributes"
)
declare -A CLI_TYPE_CLI_META_ATTRIBUTE=(
    [type]="string"
    [blob]="string"
)
declare -A CLI_TYPE_CLI_META_ATTRIBUTES=(
    [method]="map_of cli_meta_attribute"
)
declare -A CLI_TYPE_CLI_TOKENS=(
    [id]="array"
    [identifier]="array"
)
declare -A CLI_TYPE_CLI_ARGS=(
    [path]="array"
    [first_named]="string"
    [named]="map_of array"
    [positional]="array"
)
declare -A CLI_TYPE_CLI_BASH_STACK_HIDDEN_ATTRIBUTE=()

# tokens
declare -g -ar CLI_ARG_TOKEN=(
    [0]="PATH"
    [1]="VALUE"
    [2]="DASH"
    [3]="DASH_DASH"
    [4]="DASH_DASH_DASH"
    [5]="END_OPTIONS"
    [6]="EOF"
)
declare -r CLI_ARG_TOKEN_PATH="0"
declare -r CLI_ARG_TOKEN_VALUE="1"
declare -r CLI_ARG_TOKEN_DASH="2"
declare -r CLI_ARG_TOKEN_DASH_DASH="3"
declare -r CLI_ARG_TOKEN_DASH_DASH_DASH="4"
declare -r CLI_ARG_TOKEN_END_OPTIONS="5"
declare -r CLI_ARG_TOKEN_EOF="6"

# productions
declare -ar CLI_ARG_PRODUCTION=(
    [0]="SEGMENT"
    [1]="OPTION"
    [2]="POSITIONAL"
)
declare -r CLI_ARG_PRODUCTION_SEGMENT="0"
declare -r CLI_ARG_PRODUCTION_OPTION="1"
declare -r CLI_ARG_PRODUCTION_POSITIONAL="2"

# attributes
declare -A CLI_META_ATTRIBUTES_METHOD=(
    ['::cli::bash::stack::call::inline']=0
    ['::cli::bash::stack::trace::inline']=0
    ['::cli::bash::err::dump::inline']=0
    ['::cli::bash::assert::inline']=0
    ['::cli::subshell::assert::inline']=0
    ['cli::trap::err']=0
    ['cli::assert']=0
)
declare -ar CLI_META_ATTRIBUTES_METHOD_0_TYPE=( 'cli_bash_stack_hidden_attribute' )
declare -ar CLI_META_ATTRIBUTES_METHOD_0_BLOB=()

# initialize
::cli::core::scope::add::inline() { CLI_SCOPE[$1]="$2"; }

# bash
cli::bash::declare() { ::cli::bash::initialize::inline "$@"; }

# emulate bgen
bgen() {
    cli::bash::declare::type::cli_meta_tables() {
        ::cli::core::scope::add::inline $1 CLI_META_TABLES

        cli::bash::declare \
            map $1_ALIAS \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_POSITIONAL \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_TYPE
    }
    cli::bash::declare::type::cli_meta_group() {
        ::cli::core::scope::add::inline $1 CLI_META_GROUP

        cli::bash::declare \
            map $1_ALLOW \
            map $1_DEFAULT \
            map $1_REGEX \
            map $1_REQUIRE \
            map $1_BASH_TYPE \
            map $1_TYPE \
            boolean $1_POSITIONAL
    }
    cli::bash::declare::type::cli_meta() {
        ::cli::core::scope::add::inline $1 CLI_META

        cli::bash::declare \
            map $1_ALIAS \
            map $1_GROUP \
            map $1_BASH_NAME
    }
    cli::bash::declare::type::cli_meta_attributes() {
        ::cli::core::scope::add::inline $1 CLI_META_ATTRIBUTES

        cli::bash::declare \
            map $1_TYPE \
            map $1_BLOB
    }
    cli::bash::declare::type::cli_tokens() {
        ::cli::core::scope::add::inline $1 CLI_TOKENS

        cli::bash::declare \
            array $1_ID \
            array $1_IDENTIFIER
    }
    cli::bash::declare::type::cli_args() {
        ::cli::core::scope::add::inline $1 CLI_ARGS

        cli::bash::declare \
            string $1_FIRST_NAMED \
            map $1_NAMED \
            array $1_PATH \
            array $1_POSITIONAL
    }

    declare -Ag CLI_BGEN_DECLARE=(
        [CLI_TYPE_CLI_META_TABLES]=cli::bash::declare::type::cli_meta_tables
        [CLI_TYPE_CLI_META_GROUP]=cli::bash::declare::type::cli_meta_group
        [CLI_TYPE_CLI_META]=cli::bash::declare::type::cli_meta
        [CLI_TYPE_CLI_META_ATTRIBUTES]=cli::bash::declare::type::cli_meta_attributes
        [CLI_TYPE_CLI_TOKENS]=cli::bash::declare::type::cli_tokens
        [CLI_TYPE_CLI_ARGS]=cli::bash::declare::type::cli_args
    )
}
bgen

import() {

    ::cli::lock::inline() {
        flock -x "$1" cat
    }

    ::cli::bash::log::inline() {
        echo "$@" >&2
    }

    ::cli::bash::return::inline() {
        return $1
    }

    ::cli::bash::join::inline() {
        local delimiter=$1
        shift

        local -a segment=()
        while (( $# > 0 )); do
            segment+=( "$1" )
            shift
            if (( $# == 0 )); then break; fi
            segment+=( "${delimiter}" )
        done

        printf %s "${segment[@]}"
        echo
    }

    ::cli::bash::stack::call::inline() {
        
        # argument counts by frame
        set -- ${BASH_ARGV[@]}

        # bash stack
        local -i argc=0
        for (( i=0; i<${#FUNCNAME[@]}; i++ )); do
            local -a args=()
            local inline_args=''
            local funcname="${FUNCNAME[$i]}"

            if (( i == ${#FUNCNAME[@]}-1 )); then funcname='bash::main'; fi

            # reverse argv for i-th frame
            for (( j=${BASH_ARGC[$i]}-1; j>=0; j-- )); do
                args+=( "$(::cli::bash::literal::inline "${BASH_ARGV[${j}+${argc}]}")" )
            done

            # pop argc stack for i-th frame
            argc+=${BASH_ARGC[$i]}

            if [[ -z "${CLI_STACK_SHOW_HIDDEN-}" ]] \
                && cli::attributes::method::is_defined \
                "${funcname}" 'cli_bash_stack_hidden_attribute'; then
                continue
            fi

            # inline args when they won't disturb formatting
            inline_args="${args[@]}"
            if (( ${#inline_args} > 80 )); then
                inline_args=
            else
                args=()
            fi

            printf '%-50s %s:%s\n' \
                "${funcname} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-}

            for arg in "${args[@]}"; do
                echo "${arg}"
            done | sed 's/^/  /'
        done
    }

    ::cli::bash::stack::process::inline() {
        local ARG_START_PID=${1-$$}
        local ARG_END_PID=${2-${CLI_PID-}}

        # load process poset and associated command lines
        local -a pid_parent=()
        local -a pid_cmd=()
        while read pid ppid cmd; do
            pid_parent[${pid}]=${ppid}
            pid_cmd[${pid}]="${cmd}"
        done < <(ps -o pid=,ppid=,args=)

        # subprocess stack
        local pid=${BASHPID}
        local -a subshell=( ${BASHPID} )
        while (( $pid != $$ )); do
            echo "(${pid}) subshell"
            pid=${pid_parent[${pid}]}
        done

        # process stack
        local pid=${ARG_START_PID}
        for (( i=0; ${pid} > 0; i++ )); do

            echo -n "(${pid}) "
            local inline_args=${pid_cmd[${pid}]}
            if (( ${#inline_args} < 80 )); then
                echo "${inline_args}"
            else
                echo "${inline_args}" \
                    | sed -e $'s/--/\\\n  --/g'
            fi

            if (( ${pid} == ${ARG_END_PID-} )); then break; fi
            pid=${pid_parent[${pid}]-0}
        done
    }

    ::cli::bash::stack::trace::inline() {
        ::cli::bash::stack::call::inline
        if [[ -n "${CLI_STACK_SHOW_PROCESS-}" ]]; then
            ::cli::bash::stack::process::inline
        fi
    }

    ::cli::bash::is_function_declared::inline() {
        if declare -F "${1-}" > /dev/null; then 
            true
        else 
            false
        fi
    }

    ::cli::bash::literal::inline() {
        local literal="$*"
        
        #echo "if [[ ! \"${literal}\" =~ ^[a-zA-Z_-]* ]]; then"
        if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
            echo "${literal}"
            return 0
        fi

        local ARRAY=( "$*" )
        literal=$(declare -p ARRAY)

        # 0123456789012345678901
        # declare -a ARRAY=([0]="foo")
        literal="${literal:22}"
        literal="${literal:0: -1}"

        echo "${literal}"
    }

    ::cli::bash::emit::inline() {
        for name in "$@"; do
            if [[ "${name}" =~ ^.*[*]$ ]]; then
                # declare -p \
                #     | grep "^declare [-A-Za-z]* ${name:0:-1}" \
                #     || true # grep fails on no match but we want it to succeed

                # the syntax ${!VAR*} will only print *initialized* variables
                # (e.g. 'declare VAR=' but not 'declare VAR') whereas the above
                # grep will print both initialized and uninitialized variables
                # The one above is slow. Instead we choose to initialize all
                # variables so we can use the faster one below.
                
                ::cli::bash::emit::inline $(eval "echo \${!${name}}")
            elif [[ -z "${name}" ]]; then
                continue
            else
                set +e
                declare -p "${name}" 2> /dev/null
                set -e
            fi
        done
    }

    ::cli::subshell::temp::dir::inline() {

        # create and return a temporary directory
        declare -n REPLY_REF=${1-'REPLY'}
        REPLY_REF=( "$(mktemp -d "${TMPDIR:-/tmp/}cli-XXXXXXXX")/" )

        # record the temporary directory 
        declare -ga "CLI_SUBSHELL_TEMP_DIR_${BASHPID}+=()"
        declare -n CLI_SUBSHELL_TEMP_DIR_BASHPID=CLI_SUBSHELL_TEMP_DIR_${BASHPID}
        CLI_SUBSHELL_TEMP_DIR_BASHPID+=( "${REPLY_REF}" )
    }

    ::cli::subshell::temp::file::inline() {

        # create and return a temporary file
        declare -n REPLY_REF=${1-'REPLY'}
        REPLY_REF=( $(mktemp "${2-"${TMPDIR:-/tmp/}"}cli-XXXXXXXX") )

        # record the temporary file 
        declare -ga "CLI_SUBSHELL_TEMP_FILE_${BASHPID}+=()"
        declare -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
        CLI_SUBSHELL_TEMP_FILE_BASHPID+=( "${REPLY_REF}" )
    }

    ::cli::subshell::temp::clean::inline() {
        declare -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID}
        rm -f "${CLI_SUBSHELL_TEMP_FILE_BASHPID[@]}"

        declare -n CLI_SUBSHELL_TEMP_DIR_BASHPID=CLI_SUBSHELL_TEMP_DIR_${BASHPID}
        rm -r -f "${CLI_SUBSHELL_TEMP_DIR_BASHPID[@]}"
    }    

    ::cli::subshell::signal_group::inline() {
        local SIGNAL=${1-'SIGINT'}
        read PID < <(ps -p ${BASHPID} -o pgid=)
        kill -${SIGNAL} -${PID}
    }

    ::cli::subshell::dump::inline() {

        # create a temporary file
        ::cli::subshell::temp::file::inline

        # write to dump file (generator can take lock)
        cat > "${REPLY}"

        # aquire lock and copy dump file to stderr
        cat "${REPLY}" \
            | ::cli::lock::inline "$0" >&2 

        # cleanup
        rm "${REPLY}"

        # terminate parent subshells (ie to prevent parents generating
        # noisy debug spew due to their dumping in response to this dump.)
        # if ::cli::subshell::parent::inline; then
        #     kill -SIGTERM ${BASHPPID}
        # fi
        
        # exit
        exit 1
    }

    ::cli::subshell::trap::exit::inline() {
        ::cli::subshell::temp::clean::inline
    }

    ::cli::subshell::assert::inline() {
        if (( $# == 0 )); then 
            set 'Condition failed'
        fi

        {
            echo "ASSERT FAILED:" "$*"
            ::cli::bash::stack::trace::inline \
                | sed 's/^/  /'
        } | ::cli::subshell::dump::inline
    }

    ::cli::subshell::fail::inline() {
        echo "$*" \
            | ::cli::subshell::dump::inline
    }
}
import

: ${CLI_COMMAND:=${BASH_SOURCE}}

# system
cli::lock() { ::cli::lock::inline "${CLI_LOCK_FILE}"; }

# temp
cli::temp::dir() { ::cli::subshell::temp::dir::inline "$@"; }
cli::temp::file() { ::cli::subshell::temp::file::inline "$@"; }

# util
cli::join() { ::cli::bash::join::inline "$@"; }
cli::literal() { ::cli::bash::literal::inline "$@"; }
cli::stacktrace() { ::cli::bash::stack::trace::inline $((${1-0} + 1)); }
cli::dump() { ::cli::bash::emit::inline "$@"; }
cli::is_function_declared() { ::cli::bash::is_function_declared::inline "$@"; }
cli::log() { ::cli::bash::log::inline "$@"; }

# fail
cli::fail() { ::cli::subshell::fail::inline "$@"; }
cli::assert() { ::cli::subshell::assert::inline "$@"; }
# cli::dump() { ::cli::subshell::dump::inline "$@"; }

# traps
cli::trap::err() {
    local -a CLI_PIPESTATUS=( "${PIPESTATUS[@]}" )
    local CLI_TRAP_EXIT_CODE=${1-'?'}
    local BPID="${BASHPID}"

    # only dump if we are exiting after the trap; e.g. errexit is set (set -e)
    #   -e  Exit immediately if a command exits with a non-zero status.
    if [[ ! $- =~ e ]]; then
        return
    fi

    {
        echo -n "TRAP ERR: exit=${CLI_TRAP_EXIT_CODE}"
        if (( ${#CLI_PIPESTATUS[@]} > 1 )); then
            echo -n ", pipe=[$(cli::join ',' "${CLI_PIPESTATUS[@]}")]"
        fi
        echo ", bpid=${BPID}, pid=$$"

        ::cli::bash::stack::trace::inline | sed 's/^/  /'
    } | ::cli::subshell::dump::inline
}
cli::trap::exit() { 
    ::cli::subshell::trap::exit::inline
}

# attributes
cli::attributes::is_defined() {
    local target_type=${1-}; shift
    local target=${1-}; shift
    local type=${1-}; shift

    local -n targets="CLI_META_ATTRIBUTES_${target_type}"
    local index=${targets[${target}]:-}
    local -n ref="CLI_META_ATTRIBUTES_${target_type}_${index}_TYPE"
    for attribute in "${ref[@]}"; do
        if [[ "${attribute}" == "${type}" ]]; then
            return 0
        fi
    done

    return 1
}

cli::attributes::method::is_defined() {
    cli::attributes::is_defined 'METHOD' "$@" 
}

#cache
cli::cache::path() {
    local arg_path="$1"

    local name="${arg_path##*/}"
    local dir="${arg_path%/*}"
    echo "${dir}/.cli/${name}"
}

cli::cache::test() {
    local arg_cache="$1" \
    local arg_source="${2-${CLI_LOADER_COMMAND_PATH}}"

    if [[ ! -f "${arg_cache}" ]] \
        || [[ "${arg_cache}" -ot "${arg_source}" ]]; then
        false
    else
        true
    fi
}

cli::cache::put() {
    local arg_cache="$1"

    mkdir -p "${arg_cache%/*}"

    # read content into temp file and then atomically update cache
    local temp_path=$(mktemp "/tmp/cli.cache.put.XXXXXX")
    cat > "${temp_path}"
    mv "${temp_path}" "${arg_cache}"
}

# import
cli::import::default() {
    ::cli::core::scope::add::inline \
        CLI_META CLI_META

    cli::bash::declare \
        map CLI_META_BASH_NAME \
        map CLI_META_ALIAS \
        map CLI_META_GROUP \
        map CLI_META_GROUP_0_ALLOW \
        map CLI_META_GROUP_0_DEFAULT \
        map CLI_META_GROUP_0_REGEX \
        map CLI_META_GROUP_0_REQUIRE \
        map CLI_META_GROUP_0_TYPE \
        boolean CLI_META_GROUP_0_POSITIONAL

    CLI_META_BASH_NAME=(
        [help]="help"
        [self-test]="self_test"
    )
    CLI_META_ALIAS=(
        [h]="help" 
    )
    CLI_META_GROUP=(
        ["*"]="0" 
    )
    CLI_META_GROUP_0_TYPE=(
        [help]="boolean"
        [self-test]="boolean"
    )
}

cli::import() {
    CLI_LOADER_IMPORTS+=( "$*" )
}

cli::import_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local group="${segments[@]:0:$(( length - 1 ))}"
    cli::import ${group} .group
}

cli::import_parent_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local parent_group="${segments[@]:0:$(( length - 2 ))}"
    cli::import ${parent_group} .group
}

cli::import_inline() {
    cli::import "$*"
}

# export
cli::export::functions() {
    local glob

    for i in "$@"; do 
        glob+="${i}::"
    done

    while read keyword flags name; do
        if [[ "${name}" == ${glob}* ]]; then
            declare -f "${name}"
        fi
    done < <(declare -F)
}

cli::export::variable() {
    while (( $# > 0 )); do
        declare -p "$1" \
            | sed 's/^declare/declare -g/'
        shift
    done
}

cli::export::variables() {
    local -u glob

    for i in "$@"; do 
        glob+="${i}_"; 
    done

    for i in $(eval echo "\${!${glob}@}"); do
        cli::export::variable "${i}"
    done
}

cli::export::variable::merge() {
    cli::export::variable "$@" \
        | sed 's/=/+=/'
}

cli::export() {
    cli::export::variables "$@"
    cli::export::functions "$@"
}

cli::export::import() {
    echo "cli::import $@"
}

cli::export::import_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local group="${segments[@]:0:$(( length - 1 ))}"
    echo "cli::import ${group} .group"
}

cli::export::import_parent_group() {
    local segments=( ${CLI_COMMAND} )
    local length=${#segments[@]}
    local parent_group="${segments[@]:0:$(( length - 2 ))}"
    echo "cli::import ${parent_group} .group"
}

# core

# Arguments when --print-struct
#     --print-struct -s    [Flag] : Print structs
#     --                          : Struct names

# Arguments when --print
#     --print -p           [Flag] : Print variables
#     --                          : Variable names

# Arguments when --type
#     --type -t                   : Name of type
#     --name -n        [Optional] : Name of variable
#     --field -f     [Properties] : Fields of type
#     --                          : Value

cli::declare() {
    : ${1?}
    : ${2?}

    arg_type="$1" \
    arg_name="$2" \
    arg_read=false \
    arg_print=false \
        ::cli::core::declare::inline
}

cli::put() {
    : ${1:?}

    arg_name="$1" \
    arg_read=false \
    arg_print=false \
    arg_type= \
        ::cli::core::declare::inline "${@:2}"
}

cli::print() {
    : ${1:?}

    arg_name="$1" \
    arg_read=false \
    arg_print=true \
    arg_type= \
        ::cli::core::declare::inline
}

cli::read() {
    : ${1:?}

    arg_name="$1" \
    arg_read=true \
    arg_print=false \
    arg_type= \
        ::cli::core::declare::inline
}

cli::write() {
    : ${1:?}

    arg_name="$1" \
    arg_type="${2:-}" \
        ::cli::core::write::inline
}

cli::save() {
    arg_dir="${1-}" \
        ::cli::core::save::inline
}

cli::load() {
    arg_dir="${1-}" \
        ::cli::core::load::inline
}

# loader
cli::loader::to_bash() {
    while read REPLY; do
        if [[ ! "${REPLY}" =~ ${CLI_REGEX_NAME} ]]; then
            cli::fail "Unexpected cli name \"${REPLY}\"" \
                "does not match regex ${CLI_REGEX_NAME}."
        fi
        echo "${REPLY//[-.]/_}"
    done

    # mapfile
    # if (( ${#MAPFILE} == 0 )); then return; fi

    # set ${MAPFILE[@]}
    # while (( $# > 0 )); do
    #     if [[ ! "$1" =~ ${CLI_REGEX_NAME} ]]; then
    #         cli::fail "Unexpected cli name \"$1\"" \
    #             "found in \"${MAPFILE[@]}\"" \
    #             "does not match regex ${CLI_REGEX_NAME}."
    #     fi
    #     echo "${1//[-.]/_}"
    #     shift
    # done
}

# cli::loader::path_join() {
#     local GLOB="?([.])[a-zA-Z0-9]*([a-zA-Z0-9-])"
  
#     : ${arg_delimiter:?}
#     : ${arg_base:?}

#     if [[ ! "${arg_base}" == ${arg_delimiter}* ]]; then
#         echo "Unexpected relative base path '${arg_base}'. Base path must be absolute." >&2
#         exit 1
#     fi

#     local path="${arg_base:-${arg_delimiter}}"

#     while (( $# > 0 )); do

#         # ensure uniformity of group names (e.g. foo-bar, not foo_bar)
#         if [[ ! "$1" == $GLOB ]]; then
#             echo "Unexpected segment '$1' does not match '${GLOB}'." >&2
#             exit 1
#         fi

#         # if path does not end in a arg_delimiter, then add one (e.g. '::' or '/')
#         if [[ -n "${path}" && ! "${path}" =~ .*${arg_delimiter}$ ]]; then
#             path="${path}${arg_delimiter}"
#         fi

#         path="${path}$1"
#         shift
#     done

#     echo "${path}"
# }

# cli::loader::make_fqp() {
#     arg_delimiter='/' \
#     arg_base="$1" \
#         cli::loader::path_join "${@:2}"
# }

# cli::loader::make_fqn() {
#     arg_delimiter='::' \
#     arg_base='::' \
#         cli::loader::path_join "$@"
# }

cli::loader::to_inline() {
    printf '%s\n' "$@" \
        | cli::loader::to_bash \
        | mapfile -t bash_names

    cli::join '::' '' "${bash_names[@]}" 'inline'
}

cli::loader::inline() (
    local path="$("$@" ---which)"
    local fqn=$(cli::loader::to_inline "$@")

    local -a imports=()

    # cli::log ${CLI_COMMAND[@]} $fqn

    if [[ "${fqn}" == '::cli::loader::inline' ]]; then
        return
    fi

    # disable loader
    cli() { 
        if [[ "${1-}" == 'loader' && "${2-}" == '---exports' ]]; then 
            echo '/dev/null'; 
        fi 
    }
    cli::main() { return; }
    cli::import() { return; }
    cli::import_group() { return; }
    cli::import_parent_group() { return; }

    # capture imports upon which the inlined function depends
    cli::import_inline() {
        imports+=( "$*" )
    }

    # source file
    source "${path}"

    # emit nothing if no inlined function discovered
    if ! cli::is_function_declared ${fqn}; then
        return
    fi

    # emit dependencies
    cli::loader::inline::import "${imports[@]}"

    # emit function
    declare -f ${fqn}
)

cli::loader::inline::import() {
    if (( $# > 0 )); then
        printf 'cli::import %s\n' "$@"
    fi
}

cli::loader::cache::load() {
    declare -g CLI_LOADER_COMMAND_PATH="$1"
    declare -g CLI_LOADER_CACHE_DIR="$(cli::cache::path "${CLI_LOADER_COMMAND_PATH}")"
    declare -g CLI_LOADER_BGEN_PATH="${CLI_LOADER_CACHE_DIR}/bgen.sh"
    declare -g CLI_LOADER_EXPORTS_PATH="${CLI_LOADER_CACHE_DIR}/exports.sh"
    declare -g CLI_LOADER_METADATA_PATH="${CLI_LOADER_CACHE_DIR}/metadata.sh"
}

cli::loader::exports() {

    # declarative; inline content found in import 
    local inline_function=$(cli::loader::inline "$@")
    if [[ -n "${inline_function}" ]]; then
        echo "${inline_function}"
        return
    fi

    # execute import to generate content
    "$@" 
}

cli::loader::import() {
    cli::import "$1"

    local COMMAND="$1"
    shift

    # capture inline function    
    local inline_function=$(cli::loader::inline ${COMMAND})
    [[ -n "${inline_function}" ]] \
        || cli::assert "Command '${COMMAND}' exports inline function."

    # capture existing function
    local fqn=$(cli::loader::to_inline ${COMMAND})
    cli::is_function_declared ${fqn} \
        || cli::assert "cli::is_function_declared ${fqn}"
    local existing_function=$(
        cli::loader::inline::import "$@"
        declare -f ${fqn}
    )

    if [[ -n "${CLI_LOADER_IMPORT_DISABLE-}" ]]; then
        return
    fi

    # assert exiting function matches inlined function
    local diff=$(diff <(echo "${existing_function}") <(echo "${inline_function}") || true)
    if [[ -n "${diff}" ]]; then
        echo "cli::loader::import, existing_function != inline_function, fqn=${fqn}"
        echo "${diff}"
        exit 1
    fi > /dev/stderr
}

cli::loader::cache::exports() {
    local path="$("$@" ---which)"
    local exports_path=$(cli::cache::path "${path}")/exports.sh

    if ! cli::cache::test "${exports_path}" "${path}"; then
        cli::loader::exports "$@" \
            | cli::cache::put "${exports_path}"
    fi

    echo "${exports_path}"
}

cli::loader::cache::bgen() {

    # allow hard coded metadata of logic that is itself necessary to parse help
    if cli::is_function_declared cli::meta::declare; then
        cli::import::default
        cli::meta::declare
        return
    fi

    # the metadata should have not been declared outside of cli::meta::declare
    cli::assert "[[ -z \"\${CLI_SCOPE[CLI_META]+set}\" ]]"

    # test cache 
    # cli::log "BGEN ${CLI_COMMAND} -> ${CLI_LOADER_BGEN_PATH}"
    if ! cli::cache::test "${CLI_LOADER_BGEN_PATH}"; then

        # generate (like ngen)
        cli::loader::dsl::bgen \
            | cli::cache::put "${CLI_LOADER_BGEN_PATH}"
    fi
}

cli::source() {
    if (( $# > 0 )); then
        CLI_LOADER_IMPORTS+=("$*");
    fi

    local exports_path=
    local -a import=()
    local -a export_paths=()

    # foreach import
    for (( i=0; i < ${#CLI_LOADER_IMPORTS[@]}; i++ )); do
        # verify import
        # TODO

        import=( ${CLI_LOADER_IMPORTS[i]} )

        # if import previously seen, continue
        if ${CLI_LOADER_SOURCED[${import[@]}]-false}; then
            continue
        fi
        CLI_LOADER_SOURCED[${import[@]}]=true

        # TODO: inline shim; e.g. if import is 'cli ...', then use shim to 
        # resolve unix path, then define function cli() that caches that 
        # result; e.g. cli() { ~/git/cli/src/cli/"$1/.../$n" "${@:n+1}"; }

        # refresh import codegen cache
        local exports_path=$(cli::loader::cache::exports "${import[@]}")

        # source the exports to gather imports only (ignore declare)
        declare() { return; }
        source "${exports_path}"
        unset declare

        export_paths+=( "${exports_path}" )
    done

    # source exports in reverse order so that dependencies are sourced first
    for (( i=1; i<=${#export_paths[@]}; i++ )); do
        export_path="${export_paths[@]: -$i:1}"
        source "${export_path}"
    done
}

cli::loader::initialize() {
    
    # somehow the metadata should have been declared
    [[ "${CLI_SCOPE[CLI_META]+set}" ]] \
        || cli::assert "Metadata missing. Add cli::meta::declare?"

    # to test 'cli args' logic itself hard code logic here to skip 'cli args' 
    # logic if there is ...

    # cli::print CLI_META > /dev/stderr

    #  ... a single parameter group { 'help' 'self-test' } and ...
    # declare -p CLI_META_GROUP_0_TYPE > /dev/stderr
    if (( ${#CLI_META_GROUP[@]} == 1 )) && \
        (( ${#CLI_META_GROUP_0_TYPE[@]} == 2 )); then

        # ... no named parameters
        if (( $# == 0 )); then
            ARG_HELP=false
            ARG_SELF_TEST=false
            return
        fi

        # ... or only positional parameters
        if [[ "$1" == '--' ]] && ${CLI_META_GROUP_0_POSITIONAL}; then
            shift
            ARG_HELP=false
            ARG_SELF_TEST=false
            CLI_ARGS_POSITIONAL=( "$@" )
            return
        fi
    fi

    cli::declare cli_tokens CLI_TOKENS
    cli::declare cli_args CLI_ARGS

    ARG_TOKENS=CLI_TOKENS \
        ::cli::args::tokenize::inline "$@"
    # for i in "${!CLI_TOKENS_ID[@]}"; do
    #     cli::log ${CLI_ARG_TOKEN[CLI_TOKENS_ID[$i]]} "${CLI_TOKENS_IDENTIFIER[$i]-}"
    # done

    ARG_ARGS=CLI_ARGS \
    ARG_TOKENS=CLI_TOKENS \
    ARG_ALIAS=CLI_META_ALIAS \
        ::cli::args::parse::inline
    # cli::write CLI_ARGS > /dev/stderr

    # determine the group id from the first named argument
    local meta_group_id=0
    if [[ -z "${CLI_META_GROUP['*']+set}" ]]; then

        if [[ ${CLI_ARGS_FIRST_NAMED} == '' ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND}'." \
                "Instead no named arguments were passed."
        fi

        if [[ ! -n ${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]+set} ]]; then
            cli::fail \
                "Expected a discrimiator from the set { ${!CLI_META_GROUP[@]} }" \
                "be passed as named argument to command '${CLI_COMMAND}'." \
                "Instead '${CLI_ARGS_FIRST_NAMED}' was passed as the first named argument."
        fi

        meta_group_id=${CLI_META_GROUP[${CLI_ARGS_FIRST_NAMED}]}
    fi

    local CLI_META_GROUP_N="CLI_META_GROUP_${meta_group_id}"
    local CLI_META_GROUP_N_TYPE="${CLI_META_GROUP_N}_TYPE"
    local CLI_TYPE_GROUP_TYPE_N="CLI_GROUP_${meta_group_id}"

    ARG_ARGS=CLI_ARGS \
    ARG_META="${CLI_META_GROUP_N}" \
        ::cli::args::initialize::inline
    # cli::write CLI_ARGS

    _ARG_PREFIX='ARG' \
    _ARG_TYPE="${CLI_TYPE_GROUP_TYPE_N}" \
    _ARG_META="${CLI_META_GROUP_N_TYPE}" \
    _ARG_ARGS=CLI_ARGS \
    _ARG_BASH_NAME=CLI_META_BASH_NAME \
        ::cli::args::emit::inline
    # cli::dump 'ARG_*'

    # cli::fail '--- CALLED ARG TOKENIZE ---'
}

cli::loader::dsl::tokenize() { help | cli dsl tokenize; }
cli::loader::dsl::parse() { cli::loader::dsl::tokenize | cli dsl parse; }
cli::loader::dsl::meta() { cli::loader::dsl::parse | cli dsl meta; }
cli::loader::dsl::load() { cli::loader::dsl::meta | cli dsl load; }
cli::loader::dsl::bgen() { cli::loader::dsl::load | cli dsl bgen; }
cli::loader::dsl::wire() { cli::loader::dsl::load | cli core wire load -- CLI_META cli_meta | sort -u; }
cli::loader::dsl::wire_bash() { cli::loader::dsl::wire | cli core wire read | sort -u; }

cli::main() {
    # ${bash_source[1]} '.cli/loader/exports.sh'
    # ${bash_source[2]} the command itself
    cli::loader::cache::load "${BASH_SOURCE[1]}"

    # well-known options
    if [[ "${1-}" == ---* ]]; then

        while true; do
            case "$1" in
                '---assert')
                    cli::assert ;;
                '---subshell-assert')
                    ( cli::assert; echo hi; ); echo yp; ;;
                '---fail')
                    err() { return 1; }; err ;;
                '---subshell-fail')
                    err() { return 1; }; ( err; ) ;;
                '---command')
                    echo "${CLI_COMMAND[@]}" ;;
                '---type')
                    echo 'command' ;;
                '---which') 
                    echo "${CLI_LOADER_COMMAND_PATH}" ;;
                '---print') 
                    cat "${CLI_LOADER_COMMAND_PATH}" ;;
                '---imports')
                    for i in "${CLI_LOADER_IMPORTS[@]}"; do echo "${i}"; done ;;
                '---dependencies')
                    cli imports -c "${CLI_COMMAND}" ;;
                *)
                    break ;;
            esac
            exit
        done
    fi

    cli::source

    # help
    for i in "$@"; do
        case "${i}" in
            '--') 
                break ;;
            '-h') ;& '--help')
                help; exit ;;
        esac
    done
    unset i

    # self-test
    if [[ "${1-}" == '--self-test' ]]; then
        shift
        if [[ "${1-}" == '--' ]]; then shift; else shift $#; fi
        self_test "$@"
        exit
    fi

    # well-known options that require imports
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---exports')
                    cli::loader::cache::exports ${CLI_COMMAND} ;;
                '---inline')
                    cat $(${CLI_COMMAND} ---exports) ;;
                '---tokenize')
                    cli::loader::dsl::tokenize ;;
                '---parse')
                    cli::loader::dsl::parse ;;
                '---meta')
                    cli::loader::dsl::meta ;;
                '---load')
                    cli::loader::dsl::load ;;
                '---bgen')
                    cli::loader::dsl::bgen ;;
                '---wire')
                    cli::loader::dsl::wire ;;
                '---wire-bash')
                    cli::loader::dsl::wire_bash ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # bgen metadata
    cli::loader::cache::bgen
    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
        source "${CLI_LOADER_BGEN_PATH}"
    fi

    # well-known options that require loaded metadata
    if [[ "${1-}" == ---* ]]; then
        while true; do
            case "$1" in
                '---import')
                    if [[ -f "${CLI_LOADER_BGEN_PATH}" ]]; then
                        echo "${CLI_LOADER_BGEN_PATH}"
                    fi
                    ;;
                *) break ;;
            esac 
            exit
        done
    fi

    # initialize ARG_* variables
    cli::loader::initialize "$@"

    # well-known options that require loaded arguments
    while [[ "${1-}" == ---* ]]; do
        case "$1" in
            '---args-tokenize')
                cli::write CLI_TOKENS ;;
            '---args-load')
                cli::write CLI_ARGS ;;
            '---args')
                cli::dump 'ARG_*' ;;
            '---cli')
                cli::dump 'CLI_*' ;;
            '---source')
                shift; source "$1"; shift
                continue ;;
            '---read')
                shift
                while read -a REPLY; do main "$@" "${REPLY[@]}"; done ;;
            *) cli::fail "Unexpected unknown internal option \"$1\"."
        esac 
        exit
    done

    # well known features
    if [[ -n "${ARG_RUN_AS-}" ]] && [[ ! "${ARG_RUN_AS}" == "$(whoami)" ]]; then
        arg_user="${ARG_RUN_AS}" \
        arg_command="$0" \
            ::cli::run_as::inline "$@"
        return
    fi

    # hide bash entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['bash::main']=0 )

    # hide cli entrypoint
    CLI_META_ATTRIBUTES_METHOD+=( ['cli::main']=0 )

    main "${CLI_ARGS_POSITIONAL[@]}"
}

main() {
    declare -f cli::shopt
    echo 'cli::shopt'

    echo "main() { echo \"Unexpected missing 'main' in \${BASH_SOURCE[1]}.\"; }"
    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    echo

    # 'cli_scope' and 'cli_loader_imports' should be lower case because they mutating?
    echo "declare -Ag CLI_SCOPE=()"
    echo "declare -ag CLI_LOADER_IMPORTS=()"
    echo "declare -Ag CLI_LOADER_SOURCED=()"
    echo ": \${CLI_COMMAND:=\${BASH_SOURCE[1]}}"
    echo "declare CLI_ROOT_DIR='/Users/Setup/git/cli/src/'"
    echo "declare CLI_LOCK_FILE=\"${CLI_LOCK_FILE-/tmp/.cli_lock}\""

    echo "trap \"cli::trap::err \\\$? >&2\" ERR"
    echo "trap 'cli::trap::exit' EXIT"
    echo

    declare -p CLI_TEMP_TEMPLATE
    echo 

    declare -p CLI_REGEX_NAME
    declare -p CLI_REGEX_BASH_NAME
    declare -p CLI_REGEX_PROPERTY_ARG
    echo

    declare -p CLI_REGEX_VARIABLE_NAME
    declare -p CLI_REGEX_STRUCT_NAME
    declare -p CLI_REGEX_STRUCT_FIELD_NAME
    declare -p CLI_REGEX_TYPE_NAME
    declare -p CLI_REGEX_GLOBAL_NAME
    echo

    declare -p CLI_STACK_SHOW_HIDDEN
    declare -p CLI_STACK_SHOW_PROCESS
    declare -p CLI_ASSERT_EXIT
    echo

    declare -p CLI_TYPE_CLI_META
    declare -p CLI_TYPE_CLI_META_GROUP
    declare -p CLI_TYPE_CLI_META_TABLES
    declare -p CLI_TYPE_CLI_TOKENS
    declare -p CLI_TYPE_CLI_ARGS
    echo

    declare -p CLI_BGEN_DECLARE
    echo

    declare -p CLI_ARG_TOKEN
    declare -p CLI_ARG_TOKEN_PATH
    declare -p CLI_ARG_TOKEN_VALUE
    declare -p CLI_ARG_TOKEN_DASH
    declare -p CLI_ARG_TOKEN_DASH_DASH
    declare -p CLI_ARG_TOKEN_DASH_DASH_DASH
    declare -p CLI_ARG_TOKEN_END_OPTIONS
    declare -p CLI_ARG_TOKEN_EOF
    echo

    declare -p CLI_ARG_PRODUCTION
    declare -p CLI_ARG_PRODUCTION_SEGMENT
    declare -p CLI_ARG_PRODUCTION_OPTION
    declare -p CLI_ARG_PRODUCTION_POSITIONAL
    echo

    declare -p CLI_META_ATTRIBUTES_METHOD
    declare -p CLI_META_ATTRIBUTES_METHOD_0_TYPE
    declare -p CLI_META_ATTRIBUTES_METHOD_0_BLOB
    echo

    declare -f cli::main
    echo

    declare -f cli::lock
    declare -f cli::temp::dir
    declare -f cli::temp::file
    echo 

    declare -f cli::join
    echo

    declare -f cli::bash::declare
    declare -f cli::is_function_declared
    declare -f cli::literal
    declare -f cli::dump
    echo

    declare -f cli::trap::err
    declare -f cli::trap::exit
    echo

    declare -f cli::fail
    declare -f cli::assert
    declare -f cli::stacktrace
    echo

    declare -f cli::attributes::is_defined
    declare -f cli::attributes::method::is_defined
    echo

    declare -f cli::cache::test
    declare -f cli::cache::path
    declare -f cli::cache::put
    echo

    declare -f cli::export
    declare -f cli::export::import
    declare -f cli::export::import_group
    declare -f cli::export::import_parent_group
    declare -f cli::export::variable
    declare -f cli::export::variable::merge
    declare -f cli::export::variables
    declare -f cli::export::functions
    echo

    declare -f cli::import
    declare -f cli::import_group
    declare -f cli::import_parent_group
    declare -f cli::import_inline
    declare -f cli::import::default
    echo

    declare -f ::cli::core::scope::add::inline
    echo

    declare -f cli::declare
    declare -f cli::print
    declare -f cli::read
    declare -f cli::write
    declare -f cli::put
    declare -f cli::save
    declare -f cli::load
    declare -f cli::log
    echo

    declare -f cli::bash::declare::type::cli_meta_tables
    declare -f cli::bash::declare::type::cli_meta_group
    declare -f cli::bash::declare::type::cli_meta
    declare -f cli::bash::declare::type::cli_tokens
    declare -f cli::bash::declare::type::cli_args
    echo
    
    declare -f cli::loader::dsl::tokenize
    declare -f cli::loader::dsl::parse
    declare -f cli::loader::dsl::meta
    declare -f cli::loader::dsl::load
    declare -f cli::loader::dsl::bgen
    declare -f cli::loader::dsl::wire
    declare -f cli::loader::dsl::wire_bash
    echo

    declare -f cli::loader::to_bash
    declare -f cli::loader::exports
    declare -f cli::loader::to_inline
    echo

    local ARG_PACK=false
    if ${ARG_PACK}; then
        cli::import() { 
            local name=$*
            echo "${name// /::}::source"
        }

        cli::loader::cache::bgen() {

            # hard coded
            if [[ -n ${CLI_SCOPE[CLI_META]+set} ]]; then
                return
            fi

            # generated (ala ngen)
            ${FUNCNAME[2]}::cache::bgen
        }

        cli() {
            # intercept and ignore 'cli loader' calls
            if [[ "${1-}" == 'loader' ]]; then return; fi
            ( unset cli; cli "$@"; )
        }

        declare -f cli
    else

        declare -f cli::loader::cache::load
        declare -f cli::loader::cache::bgen
        declare -f cli::loader::cache::exports
        echo

        declare -f cli::source
        echo

        declare -f cli::loader::initialize
        declare -f cli::loader::inline
        declare -f cli::loader::inline::import
        echo
    fi

    printf '%s\n' "${CLI_LOADER_IMPORTS[@]}" \
        | sort -u \
        | mapfile -t CLI_LOADER_DEPENDENCIES
    printf '# %s\n' "${CLI_LOADER_DEPENDENCIES[@]}"
    echo

    for import in "${CLI_LOADER_DEPENDENCIES[@]}"; do
        cli::loader::to_inline ${import}
    done | mapfile -t CLI_LOADER_INLINES
    printf '# %s\n' "${CLI_LOADER_INLINES[@]}"
    echo

    printf '%s\n' "${CLI_LOADER_INLINES[@]}" \
        | while read; do eval "declare -f ${REPLY}"; done
}

self_test() {
    :
}

declare -A CLI_SCOPE=()
declare -a CLI_LOADER_IMPORTS=()
declare -A CLI_LOADER_SOURCED=()
declare CLI_ROOT_DIR='/Users/Setup/git/cli/src/'
declare CLI_LOCK_FILE="${CLI_LOCK_FILE-/tmp/.cli_lock}"

trap 'cli::trap::err $?' ERR
trap 'cli::trap::exit' EXIT

# these functions pre-imported because the import logic itself depends on them.
# the effect of importing pre-imported functions is to ensure the copies here
# match the source copies. 
cli::loader::import 'cli lock'

cli::loader::import 'cli subshell temp dir'
cli::loader::import 'cli subshell temp file'
cli::loader::import 'cli subshell temp clean'
cli::loader::import 'cli subshell trap exit' \
    'cli subshell temp clean'
cli::loader::import 'cli subshell signal-group'
cli::loader::import 'cli subshell dump' \
    'cli lock' \
    'cli subshell temp file' \
    'cli subshell signal-group'
cli::loader::import 'cli subshell assert' \
    'cli subshell dump' \
    'cli bash stack trace'
cli::loader::import 'cli subshell fail' \
    'cli subshell dump'

cli::loader::import 'cli bash log'
cli::loader::import 'cli bash return'
cli::loader::import 'cli bash join'
cli::loader::import 'cli bash stack call'
cli::loader::import 'cli bash stack process'
cli::loader::import 'cli bash stack trace'
cli::loader::import 'cli bash is-function-declared'
cli::loader::import 'cli bash literal'
cli::loader::import 'cli bash emit'

cli::import cli bash initialize

cli::import cli run-as

cli::import cli core declare
cli::import cli core load
cli::import cli core save
cli::import cli core write

cli::import cli args tokenize
cli::import cli args parse
cli::import cli args initialize
cli::import cli args emit

# cli::import cli name to-bash
# cli::import cli core struct emit

cli::main "$@"
