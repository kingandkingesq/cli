#!/usr/bin/env bash
source /dev/stdin < <(cli loader)
source /dev/stdin < <(cli::import cli_emit)

help() {
    cat << EOF
Command
    cli pack

Summary
    Package a group of commands into a into a single file.
    
Description
    Recursively discover cli commands developed as individual files
    and hosted in a specified directory, and package them into a 
    single file. For example, a cli 'integrate' with commands 'circle',
    'square', 'cube', 'sphere' could be arranged as a files 'integrate', 
    'circle', 'square', 'cube', 'square' and '.group' in a directory 'src':

        integrate
        src/.group
        src/area/.group
        src/area/square
        src/area/circle
        src/volume/.group
        src/volume/circle
        src/volume/circle
    
    File 'integrate' must be on the path and contain:

        #!/usr/bin/env bash
        cli shim "\$(dirname \${BASH_SOURCE})/src" "\$@"

    The remaining files must all start with the following:
    
        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)

    This will define 'cli::import' and 'cli::export' and 'cli::export_import'.
    Commands must use 'cli::import' instead of 'source' to reference libraries. 
    Libraries use 'cli::export' to emit functions and variables with common 
    prefixes and 'cli::export_import' to reference other libraries. 

    For example, 'src/.group' could define and export 'integrate::multiply' and
    'INTEGRATE_PI' like this:

        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)
        main() { cli::export 'integrate'; }
        INTEGRATE_PI='3.14159'
        integrate::multiply() { IFS='*' expr=\$*; echo "\$expr" | bc -l; }
        cli::load "\$@"

    then 'src/area/.group' could import 'src/.group' and use it to
    define and export 'integrate::area::square':

        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)
        main() { 
            cli::export_import integrate .group
            cli::export integrate area
        }
        integrate::area::square() { integrate::multiply \$1 \$1; }
        cli::load "\$@"

     finally 'circle' could reference 'src/area/.group' like this:

        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)
        source /dev/stdin < <(cli::import integrate area .group)
        help() {
            echo "Arguments"
            echo "    --radius     [Required] : Radius of the circle."
        }
        main() { 
            echo \$(integrate::multiply \${INTEGRATE_PI} \\
                \$(integrate::area::square \${arg_radius}))
        }
        cli::load "\$@"
        
    To pack the 'area' cli into a single file:

        cli pack --dir src --name area --output-dir /usr/bin

Arguments
    --dir -d        [Required] : Root directory hosting groups of commands
                                 which are to be packaged into a single cli.
    --name -n       [Required] : Name of the cli.
    --output-dir -o            : Ouput directory. Default: ".".

Global Arguments
    --help -h           [Flag] : Show this message and exit.
    --self-test         [Flag] : Runs a self test.
    --dry-run           [Flag] : Show a table of content of the commands and
                                 libraries that would be packed.
EOF
}

main() (
    if ${arg_dry_run}; then
        table_of_content
    else
        local path="${arg_output_dir}/${arg_name}"
        emit > "${path}"
        chmod a+x "${path}"
    fi
)

find_commands() {
    cli find commands --recursive --dir "${arg_dir}"
}

find_references() {
    find_commands \
        | while read; do \
            CLI_REFLECT='true' "${arg_dir}/${REPLY}" -h 2>&1 >/dev/null; \
          done \
        | sort -u
}

table_of_content() {
    echo 'commands:'
    find_commands \
        | while read; do echo "$(emit_command_name "${REPLY}")"; done \
        | sed 's/^/    /'
    echo

    echo 'libraries:'
    find_references \
        | while read; do echo "$(emit_library_name "${REPLY}")"; done \
        | sed 's/^/    /'
}

emit() {
    echo \#!/usr/bin/env bash
    echo

    # toc
    table_of_content | sed 's/^/\# /' | emit_section 'Table Of Content'

    # commands
    find_commands \
        | while read; do \
            cat <("${arg_dir}/${REPLY}" '---emit-initialize') \
                <(cat "${arg_dir}/${REPLY}" | sed 1,2d | emit::file) \
            | emit::subproc "$(emit_command_name "${REPLY}")"; \
          done \
        | emit_section 'Commands'

    # libraries
    find_references \
        | while read; do \
            ${REPLY} | emit::function "$(emit_library_name "${REPLY}")"; \
          done \
        | emit_section 'Libraries'

    # loader
    cli loader | emit_section 'Loader'

    # shim
    cli shim --pack | emit_section 'Shim'

    echo cli::shim "${arg_name}" \"\$@\"
}

emit_section() {
    echo \#
    echo \# $1
    echo \#
    while read -r; do echo "${REPLY}"; done
    echo
}

emit_library_name() {
    echo "${1// /::}"
}

emit_command_name() {
    # e.g. given a cli 'integrate' with command './area/circle'
    # emit 'integrate::area::circle'
    local name="${1#./}"
    echo "${arg_name}::${name//\//::}"
}

self_test() (
    return
)

cli::load "$@"