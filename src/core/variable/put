#!/usr/bin/env bash
source $(cli loader)
cli::import_group
cli::import_inline cli bash emit
cli::import_inline cli core variable put-builtin
cli::import_inline cli core variable declare
cli::import_inline cli core type is-builtin
cli::import_inline cli core type is-modified
cli::import cli_assert

help() {
cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Put a record.

Description

Arguments
    ${CLI_CORE_VARIABLE_ARG_NAME}
    ${CLI_CORE_VARIABLE_ARG_TYPE}
    --                      : Record to put.

Debug Arguments
    --source -s      [Flag] : Source stdin to provide 'CLI_TYPE__*' metadata.

Global Arguments
    ${CLI_GLOBAL_ARG_HELP}
    ${CLI_GLOBAL_ARG_SELF_TEST}
EOF
}

::cli::core::variable::put::inline() {
    inline "$@"
}

inline() {
    : ${arg_name?}
    : ${arg_type?}

    local -n ref=${arg_name}
    local -a type=( ${arg_type} )

    # builtin
    if arg_type=${arg_type} ::cli::core::type::is_builtin::inline; then

        # scaler
        if arg_type=${arg_type} ::cli::core::type::is_scaler::inline; then
            cli::check::condition "(( $# < 2 ))" "Unexpected excess value '${@:2}'."

            # supplied
            if (( $# != 0 )); then
                case ${type} in
                    'boolean') cli::check::regex "$1" '^$|^true$|^false$' ;;
                    'integer') cli::check::regex "$1" '^$|^[-]?[0-9]+$' ;;
                esac

                ref="$1" 

            # default
            else
                arg_type=${arg_type} \
                arg_name=${arg_name} \
                    ::cli::core::variable::initialize::inline
            fi

        # map
        elif [[ ${type} == 'map' ]]; then
            cli::check::condition "(( $# < 3 ))" "Unexpected excess value '${@:3}'."

            # supplied
            if (( $# != 0 )); then
                cli::check::regex "${1-}" '.'
                ref+=( [$1]="${2:-}" )

            # default
            else
                ref+=()
            fi

        # array
        else
            cli::assert "[[ ${type} == 'array' ]]"

            # default or supplied
            ref+=( "$@" ) 
        fi

    else
        local next_type
        local next_name

        # anonymous
        if arg_type=${arg_type} ::cli::core::type::is_modified::inline; then
            next_type=${type[@]:1}
            next_name=${arg_name}${CLI_NSS}${ref[$1]:-}

            if [[ ! -n ${ref[$1]+set} ]]; then

                # update anonymous type
                ref+=( [$1]=${#ref[@]} )

                next_name=${arg_name}${CLI_NSS}${ref[$1]}

                # declare variable
                arg_name=${next_name} \
                arg_type=${next_type} \
                    ::cli::core::variable::declare::inline
            fi

        # user defined
        else
            local -n fields_ref=CLI_TYPE__${type^^}
            next_type=${fields_ref[$1]}
            next_name=${arg_name}${CLI_NSS}${1^^}
        fi

        : ${next_name:?}
        : ${next_type:?}

        # recurse
        arg_name=${next_name} \
        arg_type=${next_type} \
            ::cli::core::variable::put::inline "${@:2}"
    fi
}

main() {
    if ${arg_source}; then
        source /dev/stdin
    fi

    arg_name=${arg_name} \
    arg_type="${arg_type}"
        inline "$@"

    ::cli::bash::emit::inline 'CLI_TYPE__*' "${arg_name^^}" "${arg_name^^}_*"
}

self_test() {

    set_builtin() {

        # string
        declare MY_STRING=""
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --name MY_STRING --type string -- 'Hello world!' \
            | assert::pipe_eq \
                'declare -- MY_STRING="Hello world!"'

        # boolean
        declare MY_BOOLEAN=false
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --name MY_BOOLEAN --type boolean -- true \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="true"'

        # integer
        declare -i MY_INTEGER=0
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --name MY_INTEGER --type integer -- 42 \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="42"'

        # array
        declare -a MY_ARRAY
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --name MY_ARRAY --type array -- a \
            | ${CLI_COMMAND} -s --name MY_ARRAY --type array -- b \
            | ${CLI_COMMAND} -s --name MY_ARRAY --type array -- c \
            | assert::pipe_eq \
                'declare -a MY_ARRAY=([0]="a" [1]="b" [2]="c")'

        # map
        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --name MY_MAP --type map -- a 0 \
            | ${CLI_COMMAND} -s --name MY_MAP --type map -- b 1 \
            | ${CLI_COMMAND} -s --name MY_MAP --type map -- c 2 \
            | assert::pipe_eq \
                'declare -A MY_MAP=([c]="2" [b]="1" [a]="0" )'
    }

    set_builtin_default() {

        # string
        declare MY_STRING=""
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --name MY_STRING --type string -- 'Hello world!' \
            | ${CLI_COMMAND} -s --name MY_STRING --type string \
            | assert::pipe_eq \
                "declare -- MY_STRING=\"\""


        # boolean
        declare MY_BOOLEAN=false
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --name MY_BOOLEAN --type boolean -- true \
            | ${CLI_COMMAND} -s --name MY_BOOLEAN --type boolean \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="false"'

        # integer
        declare -i MY_INTEGER=0
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --name MY_INTEGER --type integer -- 42 \
            | ${CLI_COMMAND} -s --name MY_INTEGER --type integer \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="0"'

        # array
        declare -a MY_ARRAY=()
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --name MY_ARRAY --type array \
            | assert::pipe_eq \
                'declare -a MY_ARRAY=()'

        # map
        declare -A MY_MAP=()
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --name MY_MAP --type map \
            | assert::pipe_eq \
                'declare -A MY_MAP=()'
    }

    set_indirect() {

        # string
        declare -A MY_MAP_OF_STRING=()
        declare -p MY_MAP_OF_STRING \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_STRING --type 'map_of string' -- x 'Hello World' \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_STRING=([x]=\"0\" )" \
                "declare -- MY_MAP_OF_STRING__0=\"Hello World\""

        # boolean
        declare -A MY_MAP_OF_BOOLEAN=()
        declare -p MY_MAP_OF_BOOLEAN \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_BOOLEAN --type 'map_of boolean' -- x true \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_BOOLEAN=([x]=\"0\" )" \
                "declare -- MY_MAP_OF_BOOLEAN__0=\"true\""

        # integer
        declare -A MY_MAP_OF_INTEGER=()
        declare -p MY_MAP_OF_INTEGER \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_INTEGER --type 'map_of integer' -- x 42 \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_INTEGER=([x]=\"0\" )" \
                "declare -i MY_MAP_OF_INTEGER__0=\"42\""

        # array
        declare -A MY_MAP_OF_ARRAY=()
        declare -p MY_MAP_OF_ARRAY \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_ARRAY --type 'map_of array' -- x a b c \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_ARRAY=([x]=\"0\" )" \
                "declare -a MY_MAP_OF_ARRAY__0=([0]=\"a\" [1]=\"b\" [2]=\"c\")"

        # map
        declare -A MY_MAP_OF_MAP=()
        declare -p MY_MAP_OF_MAP \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_MAP --type 'map_of map' -- x a 0 \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_MAP --type 'map_of map' -- x b 1 \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_MAP --type 'map_of map' -- y a 0 \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_MAP --type 'map_of map' -- y a \
            | assert::pipe_eq \
                'declare -A MY_MAP_OF_MAP=([y]="1" [x]="0" )' \
                'declare -A MY_MAP_OF_MAP__0=([b]="1" [a]="0" )' \
                "declare -A MY_MAP_OF_MAP__1=([a]=\"\" )"
    }

    set_indirect_default() {

        # string
        declare -A MY_MAP_OF_STRING=()
        declare -p MY_MAP_OF_STRING \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_STRING --type 'map_of string' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_STRING=([x]=\"0\" )" \
                "declare -- MY_MAP_OF_STRING__0=\"\""

        # boolean
        declare -A MY_MAP_OF_BOOLEAN=()
        declare -p MY_MAP_OF_BOOLEAN \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_BOOLEAN --type 'map_of boolean' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_BOOLEAN=([x]=\"0\" )" \
                "declare -- MY_MAP_OF_BOOLEAN__0=\"false\""

        # integer
        declare -A MY_MAP_OF_INTEGER=()
        declare -p MY_MAP_OF_INTEGER \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_INTEGER --type 'map_of integer' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_INTEGER=([x]=\"0\" )" \
                "declare -i MY_MAP_OF_INTEGER__0=\"0\""

        # array
        declare -A MY_MAP_OF_ARRAY=()
        declare -p MY_MAP_OF_ARRAY \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_ARRAY --type 'map_of array' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_ARRAY=([x]=\"0\" )" \
                "declare -a MY_MAP_OF_ARRAY__0=()"

        # map
        declare -A MY_MAP_OF_MAP=()
        declare -p MY_MAP_OF_MAP \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_MAP --type 'map_of map' -- x \
            | assert::pipe_eq \
                'declare -A MY_MAP_OF_MAP=([x]="0" )' \
                'declare -A MY_MAP_OF_MAP__0=()'
    }

    set_udt() {

        # indirect
        declare -A CLI_TYPE__VERSION=(['major']='integer' ['minor']='integer')
        declare -A MY_MAP_OF_VERSION=()
        declare -p \
            CLI_TYPE__VERSION \
            MY_MAP_OF_VERSION \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x major 1 \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x minor 2 \
            | assert::pipe_eq \
                "declare -A CLI_TYPE__VERSION=([minor]=\"integer\" [major]=\"integer\" )" \
                "declare -A MY_MAP_OF_VERSION=([x]=\"0\" )" \
                "declare -i MY_MAP_OF_VERSION__0__MAJOR=\"1\"" \
                "declare -i MY_MAP_OF_VERSION__0__MINOR=\"2\""

        # indirect default
        declare -A CLI_TYPE__VERSION=(['major']='integer' ['minor']='integer')
        declare -A MY_MAP_OF_VERSION=()
        declare -p \
            CLI_TYPE__VERSION \
            MY_MAP_OF_VERSION \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x major 1 \
            | ${CLI_COMMAND} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x major \
            | assert::pipe_eq \
                "declare -A CLI_TYPE__VERSION=([minor]=\"integer\" [major]=\"integer\" )" \
                "declare -A MY_MAP_OF_VERSION=([x]=\"0\" )" \
                "declare -i MY_MAP_OF_VERSION__0__MAJOR=\"0\"" \
                "declare -i MY_MAP_OF_VERSION__0__MINOR=\"0\""

        # direct
        declare -A CLI_TYPE__UDT=(['positional']='boolean' ['allow']='map_of map' ['version']='version')
        declare -- MY_UDT__POSITIONAL=false
        declare -i MY_UDT__VERSION__MAJOR=0
        declare -i MY_UDT__VERSION__MINOR=0
        declare -A MY_UDT__ALLOW=()
        declare -p \
            CLI_TYPE__UDT \
            CLI_TYPE__VERSION \
            MY_UDT__POSITIONAL \
            MY_UDT__VERSION__MAJOR \
            MY_UDT__VERSION__MINOR \
            MY_UDT__ALLOW \
            | ${CLI_COMMAND} -s --name MY_UDT --type udt -- positional true \
            | ${CLI_COMMAND} -s --name MY_UDT --type udt -- version minor 2 \
            | ${CLI_COMMAND} -s --name MY_UDT --type udt -- version major 1 \
            | ${CLI_COMMAND} -s --name MY_UDT --type udt -- allow color white \
            | ${CLI_COMMAND} -s --name MY_UDT --type udt -- allow color black \
            | assert::pipe_eq \
                'declare -A CLI_TYPE__UDT=([positional]="boolean" [version]="version" [allow]="map_of map" )' \
                'declare -A CLI_TYPE__VERSION=([minor]="integer" [major]="integer" )' \
                'declare -A MY_UDT__ALLOW=([color]="0" )' \
                'declare -A MY_UDT__ALLOW__0=([black]="" [white]="" )' \
                'declare -- MY_UDT__POSITIONAL="true"' \
                'declare -i MY_UDT__VERSION__MAJOR="1"' \
                'declare -i MY_UDT__VERSION__MINOR="2"'
    }

    test_bad_value() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name MY_BOOLEAN -- 'bad' \
            2> /dev/null
        assert::failed

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --type integer --name MY_INTEGER -- 'bad' \
            2> /dev/null
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --type map --name MY_MAP -- '' \
            2> /dev/null
        assert::failed
        set -e
    }

    test_too_many_values() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name MY_BOOLEAN -- 'true' 'bad' \
            2> /dev/null
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --type map --name MY_MAP -- 'key' 'value' 'bad' \
            2> /dev/null
        assert::failed
        set -e
    }

    set_builtin
    set_builtin_default

    set_indirect
    set_indirect_default

    set_udt

    test_bad_value
    test_too_many_values
}

cli::load "$@"
