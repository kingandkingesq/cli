#!/usr/bin/env CLI_NAME=cli bash-cli-part
cli::import cli core variable parse
cli::import cli core variable declare
cli::import cli core type is-builtin
cli::import cli core type is-modified

help() {
    cat << EOF
Command
    ${CLI_COMMAND[@]}
    
Summary
    Put a record.

Description

Arguments
    --                      : Record to put.
EOF
}

cli::core::variable::put::main() {
    ::cli::core::variable::parse::inline "$@"
    shift ${#MAPFILE[@]}
    shift

    ARG_NAME=${REPLY} \
    ARG_TYPE="${MAPFILE[@]}" \
        ::cli::core::variable::put::inline "$@"

    cli::dump "${REPLY}" "${REPLY}_*"
}

::cli::core::variable::put::inline() {
    local -a TYPE=( ${ARG_TYPE} )
    local NAME="${ARG_NAME}"
    local -n REF="${NAME}"
    # TODO: Verify REF is valid!

    # builtin
    if ::cli::core::type::is_builtin::inline ${TYPE[@]}; then

        # scaler
        if ::cli::core::type::is_scaler::inline ${TYPE[@]}; then
            (( ${#TYPE[@]} == 1 )) || cli::assert

            (( $# == 0 || $# == 1 )) || cli::assert \
                "Failed to assign '${1-}' to ${TYPE} '${NAME}'." \
                "Expected a record with one or no fields, but got '$@'."

            # scaler value supplied
            if (( $# != 0 )); then
                case ${TYPE} in
                    'boolean') [[ "${1-}" =~ ^$|^true$|^false$ ]] || cli::assert \
                        "Failed to assign '${1-}' to ${TYPE} '${NAME}'." ;;

                    'integer') [[ "${1-}" =~ ^$|^[-]?[0-9]+$ ]] || cli::assert \
                        "Failed to assign '${1-}' to ${TYPE} '${NAME}'." ;;
                esac

                REF="$1" 

            # no scaler value supplied; default
            else
                ARG_TYPE="${TYPE}" \
                ARG_NAME="${NAME}" \
                    ::cli::core::variable::declare::inline
            fi

        # map
        elif [[ ${TYPE} == 'map' ]]; then

            (( $# < 3 )) || cli::assert \
                "Failed to assign value '${2-}' to key '${1-}' in map '${NAME}'." \
                "Expected a record with two or fewer fields, but got '$@'."

            # map key/value supplied
            if (( $# != 0 )); then
                local KEY="${1-}"
                shift

                local VALUE="$*"

                [[ "${KEY}" =~ . ]] || cli::assert \
                    "Failed to use empty key to assign '${VALUE}' to map '${NAME}'."
                REF+=( ["${KEY}"]="${VALUE}" )

            # no key/value; default
            else
                REF+=()
            fi

        # array
        else
            [[ ${TYPE} == 'array' ]] || cli::assert "Unknown type '${TYPE}'."

            # array element supplied
            if (( $# != 0 )); then
                REF+=( "$*" ) 

            # no array element; default
            else
                REF+=()
            fi

        fi

    # complex
    elif (( $# > 0 )); then
        local -a NEXT_TYPE=()
        local NEXT_NAME

        # anonymous
        if ::cli::core::type::is_modified::inline ${TYPE[@]}; then
            NEXT_TYPE=( ${TYPE[@]:1} )

            if [[ ${REF[$1]+set} ]]; then
                NEXT_NAME=${NAME}_${REF[$1]}
            else
                # update anonymous type
                REF+=( [$1]=${#REF[@]} )

                NEXT_NAME="${NAME}_${REF[$1]}"

                # declare variable
                ARG_TYPE="${NEXT_TYPE[@]}" \
                ARG_NAME="${NEXT_NAME}" \
                    ::cli::core::variable::declare::inline 
            fi

        # user defined
        else
            local -n FIELDS_REF=CLI_TYPE_${TYPE^^}

            if [[ ! "${FIELDS_REF[$1]+set}" == 'set' ]]; then
                cli::fail "Field '$1' not found in '${TYPE}' fields: { ${!FIELDS_REF[@]} }."
            fi

            NEXT_TYPE=( ${FIELDS_REF[$1]} )
            NEXT_NAME=${NAME}_${1^^}
        fi

        : ${NEXT_NAME:?}
        : ${NEXT_TYPE:?}

        # recurse
        ARG_TYPE="${NEXT_TYPE[@]}" \
        ARG_NAME="${NEXT_NAME}" \
            ::cli::core::variable::put::inline  "${@:2}"
    fi

    REPLY=${NAME}
    MAPFILE=( ${TYPE[@]} )
}

self_test() {

    escaping() {

        # string
        diff <( ${CLI_COMMAND[@]} -- string MY_STRING 'Hello world!' ) - \
            <<< 'declare -- MY_STRING="Hello world!"'

        # array
        diff <( ${CLI_COMMAND[@]} -- array MY_ARRAY a b c ) - \
            <<< 'declare -a MY_ARRAY=([0]="a b c")'

        # map
        declare -A MY_MAP
        diff <( declare -p MY_MAP | ${CLI_COMMAND[@]} ---source -- map MY_MAP a "b c" ) - \
            <<< 'declare -A MY_MAP=([a]="b c" )'
    }

    builtin() {

        # string
        diff <( ${CLI_COMMAND[@]} -- string MY_STRING 'Hello' ) - \
            <<< 'declare -- MY_STRING="Hello"'

        # boolean
        diff <( ${CLI_COMMAND[@]} -- boolean MY_BOOLEAN true ) - \
            <<< 'declare -- MY_BOOLEAN="true"'

        # integer
        local -i MY_INTEGER
        diff <( ${CLI_COMMAND[@]} --- integer MY_INTEGER 42 ) - \
            <<< 'declare -i MY_INTEGER="42"'

        # array
        diff <( ${CLI_COMMAND[@]} --- array MY_ARRAY a > /dev/null
                ${CLI_COMMAND[@]} --- array MY_ARRAY b; ) - \
            <<< 'declare -a MY_ARRAY=([0]="a" [1]="b")'

        # map
        local -A MY_MAP
        diff <( ${CLI_COMMAND[@]} --- map MY_MAP a 0 ) - \
            <<< 'declare -A MY_MAP=([a]="0" )'
    }

    builtin_default() {

        # string
        diff <( ${CLI_COMMAND[@]} -- string MY_STRING ) - \
            <<< 'declare -- MY_STRING=""'

        # boolean
        diff <( ${CLI_COMMAND[@]} -- boolean MY_BOOLEAN ) - \
            <<< 'declare -- MY_BOOLEAN="false"'

        # integer
        local -i MY_INTEGER
        diff <( ${CLI_COMMAND[@]} --- integer MY_INTEGER ) - \
            <<< 'declare -i MY_INTEGER="0"'

        # array
        diff <( ${CLI_COMMAND[@]} --- array MY_ARRAY ) - \
            <<< 'declare -a MY_ARRAY=()'

        MY_ARRAY=( a )
        diff <( ${CLI_COMMAND[@]} --- array MY_ARRAY ) - \
            <<< 'declare -a MY_ARRAY=([0]="a")'

        # map
        local -A MY_MAP
        diff <( ${CLI_COMMAND[@]} --- map MY_MAP) - \
            <<< 'declare -A MY_MAP=()'

        MY_MAP=( [a]=0 )
        diff <( ${CLI_COMMAND[@]} --- map MY_MAP) - \
            <<< 'declare -A MY_MAP=([a]="0" )'
    }

    double_indirect() {
  
        local -A MY_MAP_OF_MAP_OF_STRING=()
        diff <( ${CLI_COMMAND[@]} -- map_of map_of string MY_MAP_OF_MAP_OF_STRING x y Hello ) <(
            echo 'declare -A MY_MAP_OF_MAP_OF_STRING=([x]="0" )'
            echo 'declare -A MY_MAP_OF_MAP_OF_STRING_0=([y]="0" )'
            echo 'declare -- MY_MAP_OF_MAP_OF_STRING_0_0="Hello"'
        )
    }

    indirect() {

        # string
        local -A MY_MAP_OF_STRING=()
        diff <( ${CLI_COMMAND[@]} -- map_of string MY_MAP_OF_STRING x Hello ) <(
            echo 'declare -A MY_MAP_OF_STRING=([x]="0" )'
            echo 'declare -- MY_MAP_OF_STRING_0="Hello"'
        )

        # boolean
        local -A MY_MAP_OF_BOOLEAN=()
        diff <( ${CLI_COMMAND[@]} -- map_of boolean MY_MAP_OF_BOOLEAN x true ) <(
            echo 'declare -A MY_MAP_OF_BOOLEAN=([x]="0" )'
            echo 'declare -- MY_MAP_OF_BOOLEAN_0="true"'
        )

        # integer
        local -A MY_MAP_OF_INTEGER=()
        diff <( ${CLI_COMMAND[@]} -- map_of integer MY_MAP_OF_INTEGER x 42 ) <(
            echo 'declare -A MY_MAP_OF_INTEGER=([x]="0" )'
            echo 'declare -i MY_MAP_OF_INTEGER_0="42"'
        )

        # array
        local -A MY_MAP_OF_ARRAY=()
        diff <( 
            ${CLI_COMMAND[@]} --- map_of array MY_MAP_OF_ARRAY x a b > /dev/null
            ${CLI_COMMAND[@]} -- map_of array MY_MAP_OF_ARRAY x c 
        ) <(
            echo 'declare -A MY_MAP_OF_ARRAY=([x]="0" )'
            echo 'declare -a MY_MAP_OF_ARRAY_0=([0]="a b" [1]="c")'
        )

        # map
        local -A MY_MAP_OF_MAP=()
        diff <( 
            ${CLI_COMMAND[@]} --- map_of map MY_MAP_OF_MAP x a 0 > /dev/null
            ${CLI_COMMAND[@]} --- map_of map MY_MAP_OF_MAP x b 1 > /dev/null 
            ${CLI_COMMAND[@]} --- map_of map MY_MAP_OF_MAP y a 0 > /dev/null 
            ${CLI_COMMAND[@]} -- map_of map MY_MAP_OF_MAP y a 
        ) <(
            echo 'declare -A MY_MAP_OF_MAP=([y]="1" [x]="0" )'
            echo 'declare -A MY_MAP_OF_MAP_0=([b]="1" [a]="0" )'
            echo 'declare -A MY_MAP_OF_MAP_1=([a]="" )'
        )
    }

    indirect_default() {

        # string
        local -A MY_MAP_OF_STRING=()
        diff <( ${CLI_COMMAND[@]} -- map_of string MY_MAP_OF_STRING x ) <( \
            echo 'declare -A MY_MAP_OF_STRING=([x]="0" )'
            echo 'declare -- MY_MAP_OF_STRING_0=""'
        )

        # boolean
        local -A MY_MAP_OF_BOOLEAN=()
        diff <( ${CLI_COMMAND[@]} -- map_of boolean MY_MAP_OF_BOOLEAN x ) <( \
            echo 'declare -A MY_MAP_OF_BOOLEAN=([x]="0" )'
            echo 'declare -- MY_MAP_OF_BOOLEAN_0="false"'
        )

        # integer
        local -A MY_MAP_OF_INTEGER=()
        diff <( ${CLI_COMMAND[@]} -- map_of integer MY_MAP_OF_INTEGER x ) <( \
            echo 'declare -A MY_MAP_OF_INTEGER=([x]="0" )'
            echo 'declare -i MY_MAP_OF_INTEGER_0="0"'
        )

        # array
        local -A MY_MAP_OF_ARRAY=()
        diff <( 
            ${CLI_COMMAND[@]} -- map_of array MY_MAP_OF_ARRAY x
        ) <(
            echo 'declare -A MY_MAP_OF_ARRAY=([x]="0" )'
            echo 'declare -a MY_MAP_OF_ARRAY_0=()'
        )

        # map
        local -A MY_MAP_OF_MAP=()
        diff <( 
            ${CLI_COMMAND[@]} --- map_of map MY_MAP_OF_MAP x a > /dev/null
            ${CLI_COMMAND[@]} --- map_of map MY_MAP_OF_MAP x b > /dev/null 
            ${CLI_COMMAND[@]} -- map_of map MY_MAP_OF_MAP y a 
        ) <( \
            echo 'declare -A MY_MAP_OF_MAP=([y]="1" [x]="0" )'
            echo 'declare -A MY_MAP_OF_MAP_0=([b]="" [a]="" )'
            echo 'declare -A MY_MAP_OF_MAP_1=([a]="" )'
        )
    }

    udt() {

        declare -A CLI_TYPE_VERSION=(
            ['major']='integer' 
            ['minor']='integer'
        )

        # indirect
        diff <( 
            declare -A MY_MAP_OF_VERSION=()
            ${CLI_COMMAND[@]} --- map_of version MY_MAP_OF_VERSION x major 1 > /dev/null
            ${CLI_COMMAND[@]} -- map_of version MY_MAP_OF_VERSION x minor 2
        ) <(
            echo 'declare -A MY_MAP_OF_VERSION=([x]="0" )'
            echo 'declare -i MY_MAP_OF_VERSION_0_MAJOR="1"'
            echo 'declare -i MY_MAP_OF_VERSION_0_MINOR="2"'
        )

        # indirect no key
        diff <( 
            declare -A MY_MAP_OF_VERSION=()
            ${CLI_COMMAND[@]} -- map_of version MY_MAP_OF_VERSION
        ) <(
            echo 'declare -A MY_MAP_OF_VERSION=()'
        )

        # indirect key but no field
        diff <( 
            declare -A MY_MAP_OF_VERSION=()
            ${CLI_COMMAND[@]} -- map_of version MY_MAP_OF_VERSION x
        ) <(
            echo 'declare -A MY_MAP_OF_VERSION=([x]="0" )'
            echo 'declare -i MY_MAP_OF_VERSION_0_MAJOR="0"'
            echo 'declare -i MY_MAP_OF_VERSION_0_MINOR="0"'
        )

        # indirect default
        diff <( 
            declare -A MY_MAP_OF_VERSION=()
            ${CLI_COMMAND[@]} --- map_of version MY_MAP_OF_VERSION x major 1 > /dev/null
            ${CLI_COMMAND[@]} -- map_of version MY_MAP_OF_VERSION x major
        ) <(
            echo 'declare -A MY_MAP_OF_VERSION=([x]="0" )'
            echo 'declare -i MY_MAP_OF_VERSION_0_MAJOR="0"'
            echo 'declare -i MY_MAP_OF_VERSION_0_MINOR="0"'
        )

        # direct
        declare -A CLI_TYPE_UDT=(
            ['positional']='boolean' 
            ['allow']='map_of map' 
            ['version']='version'
        )
        diff <( 
            declare -- MY_UDT_POSITIONAL=false
            # TODO Remove MY_UDT_VERSION_MAJOR and assert that -i missing
            declare -i MY_UDT_VERSION_MAJOR=0
            declare -i MY_UDT_VERSION_MINOR=0
            declare -A MY_UDT_ALLOW=()
            ${CLI_COMMAND[@]} --- udt MY_UDT positional true > /dev/null
            ${CLI_COMMAND[@]} --- udt MY_UDT version minor 2 > /dev/null
            ${CLI_COMMAND[@]} --- udt MY_UDT version major 1 > /dev/null
            ${CLI_COMMAND[@]} --- udt MY_UDT allow color white > /dev/null
            ${CLI_COMMAND[@]} --- udt MY_UDT allow color black
        ) <(
            echo 'declare -A MY_UDT_ALLOW=([color]="0" )' 
            echo 'declare -A MY_UDT_ALLOW_0=([black]="" [white]="" )' 
            echo 'declare -- MY_UDT_POSITIONAL="true"' 
            echo 'declare -i MY_UDT_VERSION_MAJOR="1"' 
            echo 'declare -i MY_UDT_VERSION_MINOR="2"'
        )
    }

    missing_field() {

        # indirect
        set +e
        declare -A CLI_TYPE_VERSION=(['major']='integer' ['minor']='integer')
        declare -A MY_MAP_OF_VERSION=()
        declare -p \
            CLI_TYPE_VERSION \
            MY_MAP_OF_VERSION \
            | ${CLI_COMMAND[@]} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x major 1 \
            | ${CLI_COMMAND[@]} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x minor 2 \
            | ${CLI_COMMAND[@]} -s --name MY_MAP_OF_VERSION --type 'map_of version' -- x missing 3 \
              2>&1 >/dev/null \
            | assert::error_message "Field 'missing' not found in 'version' fields: { minor major }."
        assert::failed
        set -e
    }

    bad_value() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND[@]} -s --type boolean --name MY_BOOLEAN -- 'bad' \
              2>&1 >/dev/null \
            | assert::error_message "Failed to assign 'bad' to boolean 'MY_BOOLEAN'." \
                "'bad' does not match regex '^$|^true$|^false$'."
        assert::failed

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND[@]} -s --type integer --name MY_INTEGER -- 'bad' \
              2>&1 >/dev/null \
            | assert::error_message "Failed to assign 'bad' to integer 'MY_INTEGER'." \
                "'bad' does not match regex '^$|^[-]?[0-9]+$'."
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND[@]} -s --type map --name MY_MAP -- '' 'val' \
              2>&1 >/dev/null \
            | assert::error_message "Failed to use empty key to assign 'val' to map 'MY_MAP'." \
                "'' does not match regex '.'."
        assert::failed
        set -e
    }

    too_many_values() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND[@]} -s --type boolean --name MY_BOOLEAN -- 'true' 'bad' \
              2>&1 >/dev/null \
            | assert::error_message "Failed to assign 'true' to boolean 'MY_BOOLEAN'." \
                "Expected a record with one or no fields, but got 'true bad'."
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND[@]} -s --type map --name MY_MAP -- 'key' 'value' 'bad' \
              2>&1 >/dev/null \
            | assert::error_message "Failed to assign value 'value' to key 'key' in map 'MY_MAP'." \
                "Expected a record with two or fewer fields, but got 'key value bad'."
        assert::failed
        set -e
    }

    escaping
    builtin
    builtin_default

    indirect
    double_indirect
    indirect_default

    udt

    # bad_value
    # too_many_values
    # missing_field
}
