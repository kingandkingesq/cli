#!/usr/bin/env CLI_NAME=cli bash-cli-part
cli::import cli bash variable initialize
cli::import cli core type get
cli::import cli core type load
cli::import cli core variable resolve

help() {
    cat << EOF
Command
    ${CLI_COMMAND[@]}
    
Summary
    Declare and initialize a bash variable or variables for a given type.

Description
    Declares and initializes a global bash variable or variables depending on 
    the provided type.
EOF
}

cli::core::variable::declare::main() {
    cli::import cli core variable parse

    : ${ARG_SCOPE?}

    while (( $# > 0 )); do
        ::cli::core::variable::parse::inline "$@"
        shift $(( ${#MAPFILE[@]} + 1 ))

        ARG_TYPE="${MAPFILE[@]}" \
        ARG_NAME="${REPLY}" \
            ::cli::core::variable::declare::inline
    done
}

::cli::core::variable::declare::inline() {
    local TYPE=( ${ARG_TYPE} )
    local NAME="${ARG_NAME}"
    local -n SCOPE_REF="${ARG_SCOPE}"

    # assoicate variable with its type
    SCOPE_REF["${NAME}"]="${TYPE[*]}"

    ::cli::core::type::get::inline "${TYPE[@]}"

    # base case
    if ${REPLY_CLI_CORE_TYPE_IS_BUILTIN}; then
        ::cli::bash::variable::initialize::inline "${TYPE}" "${NAME}"

    # anonymous (same as map)
    elif ${REPLY_CLI_CORE_TYPE_IS_MODIFIED}; then
        ::cli::bash::variable::initialize::inline "map" "${NAME}"

    # user defined
    else
        ${REPLY_CLI_CORE_TYPE_IS_USER_DEFINED} || cli::assert
        local USER_DEFINED_TYPE=${REPLY}
       
        # bgen optimization
        # local bgen=${CLI_BGEN_DECLARE[CLI_TYPE_${TYPE^^}]-}
        # if [[ -n ${bgen} ]]; then
        #     ${bgen} ${NAME}
        #     return
        # fi
        # echo "--- MISSING BGEN FOR CLI_TYPE_${TYPE^^} ---" > /dev/stderr

        ::cli::core::type::load::inline ${USER_DEFINED_TYPE}
        local -n TYPE_REF=${REPLY}

        # layout fields
        local FIELD
        for FIELD in "${!TYPE_REF[@]}"; do

            # resolve bash variable for field
            ARG_TYPE="${USER_DEFINED_TYPE}" \
            ARG_NAME="${NAME}" \
                ::cli::core::variable::resolve::inline "${FIELD}"

            # recursively initialize bash variable for field
            ARG_TYPE="${MAPFILE[*]}" \
            ARG_NAME="${REPLY}" \
                ::cli::core::variable::declare::inline
        done
    fi
}

self_test() {
    cli::import cli core variable parse
    cli::import cli bash variable get-info

    test() {
        local -A SCOPE=()

        # declare the variable
        ARG_SCOPE=SCOPE \
            ${CLI_COMMAND[@]} --- "$@"

        test::verify() {
            local TYPE="$1"
            local NAME="$2"

            # the variable is registered in the scope
            [[ "${SCOPE[${NAME}]}" == "${TYPE}" ]] || cli::assert "${SCOPE[${NAME}]} != ${TYPE}"

            ::cli::core::type::get::inline ${TYPE}

            if ! ${REPLY_CLI_CORE_TYPE_IS_USER_DEFINED}; then
                local IS_BOOLEAN=${REPLY_CLI_CORE_TYPE_IS_BOOLEAN}
                local IS_MODIFIED=${REPLY_CLI_CORE_TYPE_IS_MODIFIED}
                local IS_BUILTIN=${REPLY_CLI_CORE_TYPE_IS_BUILTIN}

                # get info about the underlying bash variable
                ::cli::bash::variable::get_info::inline "${NAME}"
                local BASH_TYPE="${MAPFILE[*]}"

                # the bash variable should be initialized and mutable
                ! ${REPLY_CLI_BASH_VARIABLE_IS_UNINITIALIZED} || cli::assert
                ! ${REPLY_CLI_BASH_VARIABLE_IS_READONLY} || cli::assert

                # the bash variable type should correspond to the core type
                ::cli::core::type::get::inline ${TYPE}
                if ${REPLY_CLI_CORE_TYPE_IS_BOOLEAN}; then
                    [[ "${BASH_TYPE}" == 'string' ]] || cli::assert

                elif ${REPLY_CLI_CORE_TYPE_IS_BUILTIN}; then
                    [[ "${BASH_TYPE}" == ${TYPE} ]] || cli::assert

                else
                    ${REPLY_CLI_CORE_TYPE_IS_MODIFIED} || cli::assert
                    [[ "${BASH_TYPE}" == 'map' ]] || cli::assert
                fi

                return
            fi

            # no bash variable is declared for a UDT
            ! ::cli::bash::variable::get_info::inline "${NAME}" || cli::assert

            ::cli::core::type::load::inline "${TYPE}"
            local -n TYPE_REF="${REPLY}"

            local FIELD
            for FIELD in "${!TYPE_REF[@]}"; do
                
                ARG_NAME="${NAME}" \
                ARG_TYPE="${TYPE}" \
                    ::cli::core::variable::resolve::inline "${FIELD}"

                # recurse
                test::verify "${MAPFILE[*]}" "${REPLY}"
            done
        }

        # parse the declaration
        ::cli::core::variable::parse::inline "$@"
        test::verify "${MAPFILE[*]}" "${REPLY}"
    }

    test string MY_STRING
    test boolean MY_BOOLEAN
    test integer MY_INTEGER
    test array MY_ARRAY
    test map MY_MAP
    test map_of string MY_MODIFIED

    declare -A CLI_TYPE_VERSION=(
        [major]='integer'
        [minor]='integer'
    )
    test version MY_VERSION

    # kitchen sink
    declare -A CLI_TYPE_UDT=(
        [my_string]='string'
        [my_integer]='integer'
        [my_boolean]='boolean'
        [my_map]='map'
        [my_array]='array'
        [my_map_of_string]='map_of string'
        [my_version]='version'
        [my_map_of_version]='map_of version'
    )
    test udt MY_UDT

    diff <(cli::dump 'MY_*' | sort -k3) - <<-EOF
		declare -a MY_ARRAY=()
		declare -- MY_BOOLEAN="false"
		declare -i MY_INTEGER="0"
		declare -A MY_MAP=()
		declare -A MY_MODIFIED=()
		declare -- MY_STRING=""
		declare -a MY_UDT_MY_ARRAY=()
		declare -- MY_UDT_MY_BOOLEAN="false"
		declare -i MY_UDT_MY_INTEGER="0"
		declare -A MY_UDT_MY_MAP=()
		declare -A MY_UDT_MY_MAP_OF_STRING=()
		declare -A MY_UDT_MY_MAP_OF_VERSION=()
		declare -- MY_UDT_MY_STRING=""
		declare -i MY_UDT_MY_VERSION_MAJOR="0"
		declare -i MY_UDT_MY_VERSION_MINOR="0"
		declare -i MY_VERSION_MAJOR="0"
		declare -i MY_VERSION_MINOR="0"
		EOF
}
