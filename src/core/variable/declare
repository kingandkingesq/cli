#!/usr/bin/env bash
source $(cli loader ---exports)
cli::import_group
cli::import_inline cli bash initialize
cli::import_inline cli core type is-scaler
cli::import_inline cli core type is-builtin
cli::import_inline cli core type is-user-defined
cli::import cli-assert

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND}
    
Summary
    Declare and initialize a bash variable or variables for a given type.

Description
    Declares and initializes a global bash variable or variables depending on 
    the provided type.
EOF
}

cli::meta::declare() {
    cli::meta::allow_positional
}

main() {
    local ARG_NAME=${@: -1}
    local ARG_TYPE=${@:1:(($#-1))}

    ::cli::core::variable::declare::inline
        
    cli::dump "${ARG_NAME}" "${ARG_NAME}_*"
}

::cli::core::variable::declare::inline() {
    : ${ARG_TYPE:?}
    : ${ARG_NAME:?}

    local -a type=( ${ARG_TYPE} )

    # builtin type
    if arg_type=${ARG_TYPE} ::cli::core::type::is_builtin::inline; then
        ::cli::bash::initialize::inline ${type} ${ARG_NAME}

    # modified type (e.g. map_of)
    elif arg_type=${ARG_TYPE} ::cli::core::type::is_modified::inline; then
        ::cli::bash::initialize::inline 'map' ${ARG_NAME}

    # user defined type
    else

        # bgen optimization
        local bgen=${CLI_BGEN_DECLARE[CLI_TYPE_${ARG_TYPE^^}]-}
        if [[ -n ${bgen} ]]; then
            ${bgen} ${ARG_NAME}
            return
        fi
        # echo "--- MISSING BGEN FOR CLI_TYPE_${ARG_TYPE^^} ---" > /dev/stderr

        cli::assert arg_type=${ARG_TYPE} ::cli::core::type::is_user_defined::inline
  
        local -n type_ref=CLI_TYPE_${ARG_TYPE^^}

        # layout fields
        local field
        for field in ${!type_ref[@]}; do
            local field_type=${type_ref[$field]}

            # recursively declare fields
            ARG_NAME=${ARG_NAME}_${field^^} \
            ARG_TYPE=${field_type} \
                ::cli::core::variable::declare::inline 
        done
    fi
}

self_test() {

    # string
    ${CLI_COMMAND} -- string VAR \
        | assert::pipe_eq \
            'declare -- VAR=""'

    # integer
    ${CLI_COMMAND} -- integer VAR \
        | assert::pipe_eq \
            'declare -i VAR="0"'

    # boolean
    ${CLI_COMMAND} -- boolean VAR \
        | assert::pipe_eq \
            'declare -- VAR="false"'

    # array
    ${CLI_COMMAND} -- array VAR \
        | assert::pipe_eq \
            'declare -a VAR=()'

    # map
    ${CLI_COMMAND} -- map VAR \
        | assert::pipe_eq \
            'declare -A VAR=()'

    # map_of
    ${CLI_COMMAND} -- map_of integer VAR \
        | assert::pipe_eq \
            'declare -A VAR=()'

    # udt
    declare -A CLI_TYPE_VERSION=(
        [major]='integer'
        [minor]='integer'
    )

    # kitchen sink
    declare -A CLI_TYPE_UDT=(
        [my_string]='string'
        [my_integer]='integer'
        [my_boolean]='boolean'
        [my_map]='map'
        [my_array]='array'
        [my_map_of_string]='map_of string'
        [my_version]='version'
        [my_map_of_version]='map_of version'
    )

    ${CLI_COMMAND} ---source <( declare -p CLI_TYPE_VERSION CLI_TYPE_UDT ) \
        -- udt VAR \
        | assert::pipe_eq \
            'declare -a VAR_MY_ARRAY=()' \
            'declare -- VAR_MY_BOOLEAN="false"' \
            'declare -i VAR_MY_INTEGER="0"' \
            'declare -A VAR_MY_MAP=()' \
            'declare -A VAR_MY_MAP_OF_STRING=()' \
            'declare -A VAR_MY_MAP_OF_VERSION=()' \
            'declare -- VAR_MY_STRING=""' \
            'declare -i VAR_MY_VERSION_MAJOR="0"' \
            'declare -i VAR_MY_VERSION_MINOR="0"'
}

cli::main "$@"
