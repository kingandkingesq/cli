#!/usr/bin/env CLI_NAME=cli bash-cli-part
cli::import cli bash variable initialize
cli::import cli core variable parse
cli::import cli core variable print
cli::import cli core type is-scaler
cli::import cli core type is-builtin
cli::import cli core type is-modified
cli::import cli core type is-user-defined

help() {
    cat << EOF
Command
    ${CLI_COMMAND[@]}
    
Summary
    Declare and initialize a bash variable or variables for a given type.

Description
    Declares and initializes a global bash variable or variables depending on 
    the provided type.
EOF
}

cli::core::variable::declare::main() {
    cli::import cli bash literal

    local -a NAMES=()
    local -A SCOPE=()

    while (( $# > 0 )); do
        ::cli::core::variable::parse::inline "$@"
        shift $(( ${#MAPFILE[@]} + 1 ))

        ARG_SCOPE='SCOPE' \
        ARG_TYPE="${MAPFILE[@]}" \
        ARG_NAME="${REPLY}" \
            ::cli::core::variable::declare::inline
    done

    ARG_SCOPE='SCOPE' \
        ::cli::core::variable::print::inline
}

::cli::core::variable::declare::inline() {
    local TYPE=( ${ARG_TYPE} )
    local NAME="${ARG_NAME}"
    local -n SCOPE_REF="${ARG_SCOPE}"

    # assoicate variable with its type
    SCOPE_REF["${NAME}"]="${TYPE[*]}"

    # base case
    if ::cli::core::type::is_builtin::inline "${TYPE[@]}"; then
        ::cli::bash::variable::initialize::inline "${TYPE[@]}" "${NAME}"

    # anonymous
    elif ::cli::core::type::is_modified::inline "${TYPE[@]}"; then
        ::cli::bash::variable::initialize::inline "map" "${NAME}"

    # user defined
    else
        ::cli::core::type::is_user_defined::inline "${TYPE[@]}" || cli::assert
        # bgen optimization
        # local bgen=${CLI_BGEN_DECLARE[CLI_TYPE_${TYPE^^}]-}
        # if [[ -n ${bgen} ]]; then
        #     ${bgen} ${NAME}
        #     return
        # fi
        # echo "--- MISSING BGEN FOR CLI_TYPE_${TYPE^^} ---" > /dev/stderr

        local -n "TYPE_REF=CLI_TYPE_${TYPE[@]^^}"

        # layout fields
        local FIELD
        for FIELD in "${!TYPE_REF[@]}"; do
            local "FIELD_TYPE=${TYPE_REF[$FIELD]}"

            # recursively declare fields
            ARG_TYPE="${FIELD_TYPE}" \
            ARG_NAME="${NAME}_${FIELD^^}" \
                ::cli::core::variable::declare::inline
        done
    fi
}

self_test() {
    diff <(${CLI_COMMAND[@]} -- string VAR) - <<< 'cli::declare string VAR=""'
    diff <(${CLI_COMMAND[@]} -- integer VAR) - <<< 'cli::declare integer VAR="0"'
    diff <(${CLI_COMMAND[@]} -- boolean VAR) - <<< 'cli::declare boolean VAR="false"'
    diff <(${CLI_COMMAND[@]} -- array VAR) - <<< 'cli::declare array VAR=()'
    diff <(${CLI_COMMAND[@]} -- map VAR) - <<< 'cli::declare map VAR=()'
exit
    diff <(${CLI_COMMAND[@]} -- map_of integer VAR) - <<< 'cli::declare map_of integer VAR=()'

    # udt
    declare -A CLI_TYPE_VERSION=(
        [major]='integer'
        [minor]='integer'
    )

    # kitchen sink
    declare -A CLI_TYPE_UDT=(
        [my_string]='string'
        [my_integer]='integer'
        [my_boolean]='boolean'
        [my_map]='map'
        [my_array]='array'
        [my_map_of_string]='map_of string'
        [my_version]='version'
        [my_map_of_version]='map_of version'
    )

    ${CLI_COMMAND[@]} --- udt VAR \
        | sort -k3 # \
    #     | diff <(cat <<-EOF
	# 		declare -a VAR_MY_ARRAY=()
	# 		declare -- VAR_MY_BOOLEAN="false"
	# 		declare -i VAR_MY_INTEGER="0"
	# 		declare -A VAR_MY_MAP=()
	# 		declare -A VAR_MY_MAP_OF_STRING=()
	# 		declare -A VAR_MY_MAP_OF_VERSION=()
	# 		declare -- VAR_MY_STRING=""
	# 		declare -i VAR_MY_VERSION_MAJOR="0"
	# 		declare -i VAR_MY_VERSION_MINOR="0"
	# 		EOF
    #     ) -

    # ${CLI_COMMAND[@]} --- \
    #     string MY_STRING_0 \
    #     string MY_STRING_1 \
    #     | sort -k3 \
    #     | diff <(cat <<-EOF
	# 		declare -- MY_STRING_0=""
	# 		declare -- MY_STRING_1=""
	# 		EOF
    #     ) -
}
