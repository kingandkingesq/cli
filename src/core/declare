#!/usr/bin/env bash
source $(cli loader)
cli::import_group
cli::import_inline cli bash emit
cli::import_inline cli core type is-scaler
cli::import_inline cli core struct emit
cli::import_inline cli core variable declare
cli::import_inline cli core variable put
cli::import cli_assert

help() {
cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Declare a variable of a given type.

Description
        cli::define_type --name table  \\
            | cli::define_field --name allow --type Map --path A \\
            | cli::define_field --name require --type Map \\
            | cli::emit_type \\
            | source /dev/stdin
        # declare -A CLI_TYPE__TABLE=( [allow]='map_of Map' [require]=Map )

        cli type declare --prefix meta --name param --type table
        # declare -A CLI_PREFIX__META=( [param]=table )
        # declare -A META_PARAM_ALLOW=()
        # declare -A META_PARAM_REQUIRE=()
        # declare -A META_PARAM=( [allow]=META_PARAM_ALLOW [require]=META_PARAM_REQUIRE )

Redefinition
    Bash supports redefinition without clobbering existing values. For example:

        \$ declare -a my_array=( a )
        \$ declare -a my_array
        \$ echo \${my_array[@]}
        a

    Likewise, declare supports redefinition without clobbering existing values. 
    For example:

        \$ ${CLI_COMMAND} --name my_array --type array \\
            | ${CLI_COMMAND} --name my_array -- a \\
            | ${CLI_COMMAND} --name my_array --type array
        \$ echo \${my_array[@]}
        a

    Redefinition that changes type is sometimes allowed by bash, but disallowed
    in all cases by declare.

Arguments
    ${CLI_CORE_ARG_NAME}
    ${CLI_CORE_ARG_TYPE}
    --print -p       [Flag] : Emit the type, scope, and variable recursively so
                              that it might be sourced.
    --read -r        [Flag] : Read records from stdin into the variable.
    --                      : A record to put into the variable.

Debug Arguments
    --source -s      [Flag] : Source stdin.

Global Arguments
    ${CLI_GLOBAL_ARG_HELP}
    ${CLI_GLOBAL_ARG_SELF_TEST}
EOF
}

::cli::core::declare::inline() {
    inline "$@"
}

inline() {
    : ${arg_name:?}
    : ${arg_type=}
    : ${arg_read=false}
    : ${arg_print=false}

    # declare scope
    declare -gA CLI_SCOPE
    local current_type=${CLI_SCOPE[${arg_name}]-}

    # type specified
    if [[ -n ${arg_type} ]]; then

        # no previous declaration
        if [[ -z ${current_type} ]]; then

            # update current type
            CLI_SCOPE+=( [${arg_name}]=${arg_type} )
            current_type=${arg_type}

            # initialize variable 
            arg_name=${arg_name} \
            arg_type=${arg_type} \
                ::cli::core::variable::declare::inline
        fi

        cli::check::condition \
            "[[ \"${current_type}\" == \"${arg_type}\" ]]" \
            "Unexpected redeclaration of '${arg_name}'" \
            "type from '${current_type}' to '${arg_type}'."
    fi

    : ${current_type:?"Unexpected failure to find type for variable '${arg_name}'."}

    # read
    if ${arg_read}; then
        while read -a REPLY; do
            arg_type= \
            arg_read=false \
            arg_print=false \
            arg_name=${arg_name} \
                ::cli::core::declare::inline "${REPLY[@]}"
        done
    fi

    # put
    if (( $# > 0 )); then
        arg_name=${arg_name} \
        arg_type=${current_type} \
            ::cli::core::variable::put::inline "$@"
    fi

    # print
    if ${arg_print}; then
        local -A visited=()
        arg_type=${current_type} \
        arg_visited=visited \
            ::cli::core::struct::emit::inline
        echo "declare -A CLI_SCOPE+=([${arg_name}]=\"${current_type}\" )"
        ::cli::bash::emit::inline "${arg_name}" "${arg_name}_*"
    fi
}

main() {
    if ${arg_source}; then
        source /dev/stdin
    fi

    inline "$@"

    if ! ${arg_print}; then
        ::cli::bash::emit::inline 'CLI_TYPE__*' 'CLI_SCOPE' "${arg_name}" "${arg_name}_*"
    fi
}

self_test() {

    read_records() {

        # string
        echo 'hi' \
            | ${CLI_COMMAND} --read --name MY_STRING --type string --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_STRING]="string" )' \
                'declare -- MY_STRING="hi"'

        # string (from stdin and as positional args)
        echo 'hi' \
            | ${CLI_COMMAND} --read --name MY_STRING --type string --print -- 'there' \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_STRING]="string" )' \
                'declare -- MY_STRING="there"'

        # integer
        echo '42' \
            | ${CLI_COMMAND} --read --name MY_INTEGER --type integer --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_INTEGER]="integer" )' \
                'declare -i MY_INTEGER="42"'

        # boolean
        echo 'true' \
            | ${CLI_COMMAND} --read --name MY_BOOLEAN --type boolean --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_BOOLEAN]="boolean" )' \
                'declare -- MY_BOOLEAN="true"'

        # array
        printf '%s\n' a b c \
            | ${CLI_COMMAND} --read --name MY_ARRAY --type array --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_ARRAY]="array" )' \
                'declare -a MY_ARRAY=([0]="a" [1]="b" [2]="c")'

        # map
        echo 'k v' \
            | ${CLI_COMMAND} --read --name MY_MAP --type map --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_MAP]="map" )' \
                'declare -A MY_MAP=([k]="v" )'

        # map_of builtin
        echo 'n k v' \
            | ${CLI_COMMAND} --read --name MY_MAP_OF_MAP --type "map_of map" --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_MAP_OF_MAP]="map_of map" )' \
                'declare -A MY_MAP_OF_MAP=([n]="" )' \
                'declare -A MY_MAP_OF_MAP__N=([k]="v" )'

        # map_of map_of map
        printf '%s\n' \
            'default color black' \
            'allow color black' \
            'allow color white' \
            | ${CLI_COMMAND} --read --name MY_META --type "map_of map_of map" --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([MY_META]="map_of map_of map" )' \
                'declare -A MY_META=([default]="" [allow]="" )' \
                'declare -A MY_META__ALLOW=([color]="" )' \
                'declare -A MY_META__ALLOW__COLOR=([black]="" [white]="" )' \
                'declare -A MY_META__DEFAULT=([color]="" )' \
                'declare -A MY_META__DEFAULT__COLOR=([black]="" )'

        # name collision
        ${CLI_COMMAND} --name VAR --type 'map_of map_of string' \
            | ${CLI_COMMAND} --source --name VAR -- foo bar_baz x \
            | ${CLI_COMMAND} --source --name VAR -- foo_bar baz y \
            | ${CLI_COMMAND} --source --name VAR --print \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE+=([VAR]="map_of map_of string" )' \
                'declare -A VAR=([foo]="" [foo_bar]="" )' \
                'declare -A VAR__FOO=([bar_baz]="" )' \
                'declare -A VAR__FOO_BAR=([baz]="" )' \
                'declare -- VAR__FOO_BAR__BAZ="y"' \
                'declare -- VAR__FOO__BAR_BAZ="x"'
    }

    builtin_default() {

        # string
        ${CLI_COMMAND} --name MY_STRING --type string \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_STRING]="string" )' \
                'declare -- MY_STRING=""'

        # integer
        ${CLI_COMMAND} --name MY_INTEGER --type integer \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_INTEGER]="integer" )' \
                'declare -i MY_INTEGER="0"'

        # boolean
        ${CLI_COMMAND} --name MY_BOOLEAN --type boolean \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_BOOLEAN]="boolean" )' \
                'declare -- MY_BOOLEAN="false"'

        # array
        ${CLI_COMMAND} --name MY_ARRAY --type array \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_ARRAY]="array" )' \
                'declare -a MY_ARRAY=()'

        # map
        ${CLI_COMMAND} --name MY_MAP --type map \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_MAP]="map" )' \
                'declare -A MY_MAP=()'

        # map_of
        ${CLI_COMMAND} --name MY_MAP_OF_STRING --type "map_of string" \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_MAP_OF_STRING]="map_of string" )' \
                'declare -A MY_MAP_OF_STRING=()'
    }

    builtin_assign() {

        # string
        ${CLI_COMMAND} --name MY_STRING --type string -- hi \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_STRING]="string" )' \
                'declare -- MY_STRING="hi"'

        # integer
        ${CLI_COMMAND} --name MY_INTEGER --type integer -- 42 \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_INTEGER]="integer" )' \
                'declare -i MY_INTEGER="42"'

        # boolean
        ${CLI_COMMAND} --name MY_BOOLEAN --type boolean -- true \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_BOOLEAN]="boolean" )' \
                'declare -- MY_BOOLEAN="true"'

        # array
        ${CLI_COMMAND} --name MY_ARRAY --type array -- a b c \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_ARRAY]="array" )' \
                'declare -a MY_ARRAY=([0]="a" [1]="b" [2]="c")'

        # map
        ${CLI_COMMAND} --name MY_MAP --type map -- k v \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_MAP]="map" )' \
                'declare -A MY_MAP=([k]="v" )'

        # map_of builtin
        ${CLI_COMMAND} --name MY_MAP_OF_MAP --type "map_of map" -- n k v \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_MAP_OF_MAP]="map_of map" )' \
                'declare -A MY_MAP_OF_MAP=([n]="" )' \
                'declare -A MY_MAP_OF_MAP__N=([k]="v" )'

        # map_of map_of map
        ${CLI_COMMAND} --name MY_META --type "map_of map_of map" \
            | ${CLI_COMMAND} --source --name MY_META -- default color black \
            | ${CLI_COMMAND} --source --name MY_META -- allow color black \
            | ${CLI_COMMAND} --source --name MY_META -- allow color white \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_META]="map_of map_of map" )' \
                'declare -A MY_META=([default]="" [allow]="" )' \
                'declare -A MY_META__ALLOW=([color]="" )' \
                'declare -A MY_META__ALLOW__COLOR=([black]="" [white]="" )' \
                'declare -A MY_META__DEFAULT=([color]="" )' \
                'declare -A MY_META__DEFAULT__COLOR=([black]="" )'
    }

    user_defined() {

        # map_of udt
        declare -A CLI_TYPE__VERSION=(['major']='integer' ['minor']='integer')
        declare -p CLI_TYPE__VERSION \
            | ${CLI_COMMAND} --source \
                --name MY_MAP_OF_VERSION \
                --type "map_of version" \
                --print \
                -- alpha major 1 \
            | assert::pipe_eq \
                'declare -A CLI_TYPE__VERSION=([minor]="integer" [major]="integer" )' \
                'declare -A CLI_SCOPE+=([MY_MAP_OF_VERSION]="map_of version" )' \
                'declare -A MY_MAP_OF_VERSION=([alpha]="" )' \
                'declare -i MY_MAP_OF_VERSION__ALPHA__MAJOR="1"' \
                'declare -i MY_MAP_OF_VERSION__ALPHA__MINOR="0"'
        # defaults
        cli core struct define --name version \
            | cli core struct define-field --name major --type integer \
            | cli core struct define-field --name minor --type integer \
            | cli core struct define --source --name kitchen_sink_type \
            | cli core struct define-field --name version --type version \
            | cli core struct define-field --name integer --type integer \
            | cli core struct define-field --name map --type map \
            | cli core struct define-field --name array --type array \
            | cli core struct define-field --name boolean --type boolean \
            | cli core struct define-field --name string --type string \
            | cli core struct define-field --name map_of_map --type 'map_of map' \
            | ${CLI_COMMAND} --source --name KITCHEN_SINK --type kitchen_sink_type  \
            | ${CLI_COMMAND} --source --name KITCHEN_SINK --print \
            | assert::pipe_eq \
                'declare -A CLI_TYPE__KITCHEN_SINK_TYPE=([boolean]="boolean" [version]="version" [map]="map" [map_of_map]="map_of map" [string]="string" [array]="array" [integer]="integer" )' \
                'declare -A CLI_TYPE__VERSION=([minor]="integer" [major]="integer" )' \
                'declare -A CLI_SCOPE+=([KITCHEN_SINK]="kitchen_sink_type" )' \
                'declare -a KITCHEN_SINK__ARRAY=()' \
                'declare -- KITCHEN_SINK__BOOLEAN="false"' \
                'declare -i KITCHEN_SINK__INTEGER="0"' \
                'declare -A KITCHEN_SINK__MAP=()' \
                'declare -A KITCHEN_SINK__MAP_OF_MAP=()' \
                'declare -- KITCHEN_SINK__STRING=""' \
                'declare -i KITCHEN_SINK__VERSION__MAJOR="0"' \
                'declare -i KITCHEN_SINK__VERSION__MINOR="0"'

        # motiviating scenario -- representation of parameter metadata
        cli core struct define --name my_meta \
            | cli core struct define-field --name timeout --type integer \
            | cli core struct define-field --name require --type map \
            | cli core struct define-field --name default --type map \
            | cli core struct define-field --name alias --type map \
            | cli core struct define-field --name implicit_value --type map \
            | cli core struct define-field --name positional --type boolean \
            | cli core struct define-field --name allow --type 'map_of map' \
            | ${CLI_COMMAND} --source --name MY_META --type my_meta \
            | ${CLI_COMMAND} --source --name MY_META -- timeout 42 \
            | ${CLI_COMMAND} --source --name MY_META -- allow help true \
            | ${CLI_COMMAND} --source --name MY_META -- allow help false \
            | ${CLI_COMMAND} --source --name MY_META -- implicit_value help true \
            | ${CLI_COMMAND} --source --name MY_META -- default help false \
            | ${CLI_COMMAND} --source --name MY_META -- alias h help \
            | ${CLI_COMMAND} --source --name MY_META -- require name \
            | ${CLI_COMMAND} --source --name MY_META -- positional true \
            | ${CLI_COMMAND} --source --name MY_META --print \
            | assert::pipe_eq \
                'declare -A CLI_TYPE__MY_META=([require]="map" [default]="map" [timeout]="integer" [positional]="boolean" [implicit_value]="map" [alias]="map" [allow]="map_of map" )' \
                'declare -A CLI_SCOPE+=([MY_META]="my_meta" )' \
                'declare -A MY_META__ALIAS=([h]="help" )' \
                'declare -A MY_META__ALLOW=([help]="" )' \
                'declare -A MY_META__ALLOW__HELP=([false]="" [true]="" )' \
                'declare -A MY_META__DEFAULT=([help]="false" )' \
                'declare -A MY_META__IMPLICIT_VALUE=([help]="true" )' \
                'declare -- MY_META__POSITIONAL="true"' \
                'declare -A MY_META__REQUIRE=([name]="" )' \
                'declare -i MY_META__TIMEOUT="42"'
    }

    redeclare() {

        # array
        ${CLI_COMMAND} --name MY_ARRAY --type array \
            | ${CLI_COMMAND} --source --name MY_ARRAY -- a \
            | ${CLI_COMMAND} --source --name MY_ARRAY --type array \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_ARRAY]="array" )' \
                'declare -a MY_ARRAY=([0]="a")'

        # boolean
        ${CLI_COMMAND} --name MY_BOOLEAN --type boolean \
            | ${CLI_COMMAND} --source --name MY_BOOLEAN -- true \
            | ${CLI_COMMAND} --source --name MY_BOOLEAN --type boolean \
            | assert::pipe_eq \
                'declare -A CLI_SCOPE=([MY_BOOLEAN]="boolean" )' \
                'declare -- MY_BOOLEAN="true"'

        # switch
        assert::pipe_fails << EOF
            ${CLI_COMMAND} --name MY_VAR --type boolean \
                | ${CLI_COMMAND} --source --name MY_VAR --type boolean \
                | ${CLI_COMMAND} --source --name MY_VAR --type integer
EOF
    }

    read_records
    builtin_default
    builtin_assign
    redeclare
    user_defined
}

cli::load "$@"
