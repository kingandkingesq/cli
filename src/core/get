#!/usr/bin/env bash
source $(cli loader)
cli::import cli_assert

help() {
cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Get a field, map value, or test set membership.

Arguments
    --                      : Path to field plus key if type is map or set.

Debug Arguments
    --source -x      [Flag] : Source stdin.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.
EOF
}

declare_global_variable() {

    # map the variable type to a bash declare flag
    local declare_flag=g
    case $1 in
        'integer') declare_flag+=i ;;
        'array') declare_flag+=a ;;
        'string') ;&
        'boolean') ;;
        *) declare_flag+=A ;;
    esac

    # declare the bash type
    local -${declare_flag} ${arg_name}
}

main() {
    if (( $# < 2 )); then
        cli::fail "Unexpected lack of name and scope."
    fi

    # read variables, and metadata stored in CLI_SCOPE__*, CLI_TYPE__*
    if $arg_source; then
        source /dev/stdin
    fi

    # get variable type
    local -u scope=$1
    local -n scope_ref=CLI_SCOPE__${scope^^}
    local -a type=( ${scope_ref[$2]} )

    # get variable reference
    local -u variable=$1_$2
    local -n variable_ref=${variable}

    # shift scope and name
    shift 2

    while true; do

        case $type in

            # modifier
            'map_of')
                variable=${variable}_$1 
                variable_ref+=( [$1]=${variable} )
                shift

                arg_name=${variable} \
                    declare_global_variable ${type}
                type=( ${type[@]:1} )

                local -n variable_ref=${variable}
                ;;

            # builtin
            'boolean') ;&
            'integer') ;&
            'string') echo "$variable_ref"; break ;;
            'set') variable_ref+=( [$1]= ); break ;;
            'map') variable_ref+=( [$1]="${2-}" ); break ;;
            'array') variable_ref+=( "$1" ); break ;;

            # user defined
            *)
                local -u fields=CLI_TYPE__${type}
                local -n fields_ref=${fields}
                type=( ${fields_ref[$1]} )

                variable=${variable}_$1 
                shift

                arg_name=${variable} \
                    declare_global_variable ${type}

                local -n variable_ref=${variable}
                ;;
        esac
    done

    declare -p ${!CLI_TYPE__*} ${!CLI_SCOPE__*}
    eval "declare -p \${!${scope^^}_*}"
}

self_test() {
    cli type declare --scope my --name string -- string \
        | cli type set -x -- my string "Hello World" \
        | cli type get -x -- my string
}

cli::load "$@"