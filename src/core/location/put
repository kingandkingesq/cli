#!/usr/bin/env bash
source $(cli loader)
cli::import_inline cli bash emit
cli::import_inline cli core location put-builtin
cli::import_inline cli core location allocate
cli::import_inline cli core type is-builtin
cli::import_inline cli core type is-modified
cli::import cli_assert

help() {
cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Put a record.

Description

Arguments
    --name -n     [Require] : Variable name.
    --type -t     [Require] : Type of variable.
    --                      : Record to put.

Debug Arguments
    --source -s      [Flag] : Source stdin to provide 'CLI_TYPE__*' metadata.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.
EOF
}

::cli::core::location::put::inline() {
    inline "$@"
}

inline() {
    : ${arg_name?"Unexpected lack of 'name' in call to 'put'."}
    : ${arg_type?"Unexpected lack of 'type' in call to 'put'."}

    local variable=${arg_name^^}
    local -n variable_ref=${variable}

    local -a type=( ${arg_type} )

    # builtin
    if arg_type=${arg_type} ::cli::core::type::is_builtin::inline; then
        arg_type=${arg_type} \
        arg_name=${variable} \
            ::cli::core::location::put_builtin::inline "$@"

    else
        local next_type
        local next_name=${arg_name}_$1

        # anonymous
        if arg_type=${arg_type} ::cli::core::type::is_modified::inline; then
            next_type=${type[@]:1}

            if [[ ! -n ${variable_ref[$1]+set} ]]; then

                # update anonymous type
                variable_ref+=( [$1]= )

                # allocate variable
                arg_name=${next_name} \
                arg_type=${next_type} \
                    ::cli::core::location::allocate::inline
            fi

        # user defined
        else
            local -n fields_ref=CLI_TYPE__${type^^}
            next_type=${fields_ref[$1]}
        fi

        # recurse
        arg_name=${next_name} \
        arg_type=${next_type} \
            ::cli::core::location::put::inline "${@:2}"
    fi
}

main() {
    if $arg_source; then
        source /dev/stdin
    fi

    arg_name=${arg_name} \
    arg_type="${arg_type}"
        inline "$@"

    ::cli::bash::emit::inline 'CLI_TYPE__*' "${arg_name^^}" "${arg_name^^}_*"
}

self_test() {

    set_builtin() {

        # string
        declare MY_STRING=""
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --name my_string --type string -- 'Hello world!' \
            | assert::pipe_eq \
                'declare -- MY_STRING="Hello world!"'

        # boolean
        declare MY_BOOLEAN=false
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --name my_boolean --type boolean -- true \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="true"'

        # integer
        declare -i MY_INTEGER=0
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --name my_integer --type integer -- 42 \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="42"'

        # array
        declare -a MY_ARRAY
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --name my_array --type array -- a \
            | ${CLI_COMMAND} -s --name my_array --type array -- b \
            | ${CLI_COMMAND} -s --name my_array --type array -- c \
            | assert::pipe_eq \
                'declare -a MY_ARRAY=([0]="a" [1]="b" [2]="c")'

        # map
        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --name my_map --type map -- a 0 \
            | ${CLI_COMMAND} -s --name my_map --type map -- b 1 \
            | ${CLI_COMMAND} -s --name my_map --type map -- c 2 \
            | assert::pipe_eq \
                'declare -A MY_MAP=([c]="2" [b]="1" [a]="0" )'
    }

    set_builtin_default() {

        # string
        declare MY_STRING=""
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --name my_string --type string -- 'Hello world!' \
            | ${CLI_COMMAND} -s --name my_string --type string \
            | assert::pipe_eq \
                "declare -- MY_STRING=\"\""


        # boolean
        declare MY_BOOLEAN=false
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --name my_boolean --type boolean -- true \
            | ${CLI_COMMAND} -s --name my_boolean --type boolean \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="false"'

        # integer
        declare -i MY_INTEGER=0
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --name my_integer --type integer -- 42 \
            | ${CLI_COMMAND} -s --name my_integer --type integer \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="0"'

        # array
        declare -a MY_ARRAY=()
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --name my_array --type array \
            | assert::pipe_eq \
                'declare -a MY_ARRAY=()'

        # map
        declare -A MY_MAP=()
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --name my_map --type map \
            | assert::pipe_eq \
                'declare -A MY_MAP=()'
    }

    set_indirect() {

        # string
        declare -A MY_MAP_OF_STRING=()
        declare -p MY_MAP_OF_STRING \
            | ${CLI_COMMAND} -s --name my_map_of_string --type 'map_of string' -- x 'Hello World' \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_STRING=([x]=\"\" )" \
                "declare -- MY_MAP_OF_STRING_X=\"Hello World\""

        # boolean
        declare -A MY_MAP_OF_BOOLEAN=()
        declare -p MY_MAP_OF_BOOLEAN \
            | ${CLI_COMMAND} -s --name my_map_of_boolean --type 'map_of boolean' -- x true \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_BOOLEAN=([x]=\"\" )" \
                "declare -- MY_MAP_OF_BOOLEAN_X=\"true\""

        # integer
        declare -A MY_MAP_OF_INTEGER=()
        declare -p MY_MAP_OF_INTEGER \
            | ${CLI_COMMAND} -s --name my_map_of_integer --type 'map_of integer' -- x 42 \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_INTEGER=([x]=\"\" )" \
                "declare -i MY_MAP_OF_INTEGER_X=\"42\""

        # array
        declare -A MY_MAP_OF_ARRAY=()
        declare -p MY_MAP_OF_ARRAY \
            | ${CLI_COMMAND} -s --name my_map_of_array --type 'map_of array' -- x a b c \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_ARRAY=([x]=\"\" )" \
                "declare -a MY_MAP_OF_ARRAY_X=([0]=\"a\" [1]=\"b\" [2]=\"c\")"

        # map
        declare -A MY_MAP_OF_MAP=()
        declare -p MY_MAP_OF_MAP \
            | ${CLI_COMMAND} -s --name my_map_of_map --type 'map_of map' -- x a 0 \
            | ${CLI_COMMAND} -s --name my_map_of_map --type 'map_of map' -- x b 1 \
            | ${CLI_COMMAND} -s --name my_map_of_map --type 'map_of map' -- y a 0 \
            | ${CLI_COMMAND} -s --name my_map_of_map --type 'map_of map' -- y a \
            | assert::pipe_eq \
                'declare -A MY_MAP_OF_MAP=([y]="" [x]="" )' \
                'declare -A MY_MAP_OF_MAP_X=([b]="1" [a]="0" )' \
                "declare -A MY_MAP_OF_MAP_Y=([a]=\"\" )"
    }

    set_indirect_default() {

        # string
        declare -A MY_MAP_OF_STRING=()
        declare -p MY_MAP_OF_STRING \
            | ${CLI_COMMAND} -s --name my_map_of_string --type 'map_of string' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_STRING=([x]=\"\" )" \
                "declare -- MY_MAP_OF_STRING_X=\"\""

        # boolean
        declare -A MY_MAP_OF_BOOLEAN=()
        declare -p MY_MAP_OF_BOOLEAN \
            | ${CLI_COMMAND} -s --name my_map_of_boolean --type 'map_of boolean' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_BOOLEAN=([x]=\"\" )" \
                "declare -- MY_MAP_OF_BOOLEAN_X=\"false\""

        # integer
        declare -A MY_MAP_OF_INTEGER=()
        declare -p MY_MAP_OF_INTEGER \
            | ${CLI_COMMAND} -s --name my_map_of_integer --type 'map_of integer' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_INTEGER=([x]=\"\" )" \
                "declare -i MY_MAP_OF_INTEGER_X=\"0\""

        # array
        declare -A MY_MAP_OF_ARRAY=()
        declare -p MY_MAP_OF_ARRAY \
            | ${CLI_COMMAND} -s --name my_map_of_array --type 'map_of array' -- x \
            | assert::pipe_eq \
                "declare -A MY_MAP_OF_ARRAY=([x]=\"\" )" \
                "declare -a MY_MAP_OF_ARRAY_X=()"

        # map
        declare -A MY_MAP_OF_MAP=()
        declare -p MY_MAP_OF_MAP \
            | ${CLI_COMMAND} -s --name my_map_of_map --type 'map_of map' -- x \
            | assert::pipe_eq \
                'declare -A MY_MAP_OF_MAP=([x]="" )' \
                'declare -A MY_MAP_OF_MAP_X=()'
    }

    set_udt() {

        # indirect
        declare -A CLI_TYPE__VERSION=(['major']='integer' ['minor']='integer')
        declare -A MY_MAP_OF_VERSION=()
        declare -p \
            CLI_TYPE__VERSION \
            MY_MAP_OF_VERSION \
            | ${CLI_COMMAND} -s --name my_map_of_version --type 'map_of version' -- x major 1 \
            | ${CLI_COMMAND} -s --name my_map_of_version --type 'map_of version' -- x minor 2 \
            | assert::pipe_eq \
                "declare -A CLI_TYPE__VERSION=([minor]=\"integer\" [major]=\"integer\" )" \
                "declare -A MY_MAP_OF_VERSION=([x]=\"\" )" \
                "declare -i MY_MAP_OF_VERSION_X_MAJOR=\"1\"" \
                "declare -i MY_MAP_OF_VERSION_X_MINOR=\"2\""

        # indirect default
        declare -A CLI_TYPE__VERSION=(['major']='integer' ['minor']='integer')
        declare -A MY_MAP_OF_VERSION=()
        declare -p \
            CLI_TYPE__VERSION \
            MY_MAP_OF_VERSION \
            | ${CLI_COMMAND} -s --name my_map_of_version --type 'map_of version' -- x major 1 \
            | ${CLI_COMMAND} -s --name my_map_of_version --type 'map_of version' -- x major \
            | assert::pipe_eq \
                "declare -A CLI_TYPE__VERSION=([minor]=\"integer\" [major]=\"integer\" )" \
                "declare -A MY_MAP_OF_VERSION=([x]=\"\" )" \
                "declare -i MY_MAP_OF_VERSION_X_MAJOR=\"0\"" \
                "declare -i MY_MAP_OF_VERSION_X_MINOR=\"0\""

        # direct
        declare -A CLI_TYPE__UDT=(['positional']='boolean' ['allow']='map_of map' ['version']='version')
        declare -- MY_UDT_POSITIONAL=false
        declare -i MY_UDT_VERSION_MAJOR=0
        declare -i MY_UDT_VERSION_MINOR=0
        declare -A MY_UDT_ALLOW=()
        declare -p \
            CLI_TYPE__UDT \
            CLI_TYPE__VERSION \
            MY_UDT_POSITIONAL \
            MY_UDT_VERSION_MAJOR \
            MY_UDT_VERSION_MINOR \
            MY_UDT_ALLOW \
            | ${CLI_COMMAND} -s --name my_udt --type udt -- positional true \
            | ${CLI_COMMAND} -s --name my_udt --type udt -- version minor 2 \
            | ${CLI_COMMAND} -s --name my_udt --type udt -- version major 1 \
            | ${CLI_COMMAND} -s --name my_udt --type udt -- allow color white \
            | ${CLI_COMMAND} -s --name my_udt --type udt -- allow color black \
            | assert::pipe_eq \
                'declare -A CLI_TYPE__UDT=([positional]="boolean" [version]="version" [allow]="map_of map" )' \
                'declare -A CLI_TYPE__VERSION=([minor]="integer" [major]="integer" )' \
                'declare -A MY_UDT_ALLOW=([color]="" )' \
                'declare -A MY_UDT_ALLOW_COLOR=([black]="" [white]="" )' \
                'declare -- MY_UDT_POSITIONAL="true"' \
                'declare -i MY_UDT_VERSION_MAJOR="1"' \
                'declare -i MY_UDT_VERSION_MINOR="2"'    
}

    set_builtin
    set_builtin_default

    set_indirect
    set_indirect_default

    set_udt
}

cli::load "$@"
