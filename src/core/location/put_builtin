#!/usr/bin/env bash
source $(cli loader)
cli::import cli_assert
cli::import_inline cli core location initialize
cli::import_inline cli core type is-scaler

help() {
cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Put a value into a scaler, values into an array, or a key value pair into a map.

Description
    If no value(s) is(are) specified, then a default is assigned:

        boolean     false
        integer     0
        string      ""
        map         ()
        array       ()

    Boolean values must be 'true' or 'false'. 
    
    Integer values be an integer value.

    Map keys cannot be the empty string.

    For reasons of performance, no check is done to test if the bash variable type
    matches the type specified.

Arguments
    --name -n     [Require] : Variable name.
    --type -t     [Require] : Variable type.
    --                      : Value to assign, or key/value if a map.

Debug Arguments
    --source -s      [Flag] : Source stdin to provide variable to initialize.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.
EOF
}

inline() {
    local -n ref=${arg_name^^}
    local -a type=( ${arg_type} )

    if arg_type=${arg_type} ::cli::core::type::is_scaler::inline; then
        cli::check::condition "(( $# < 2 ))" "Unexpected excess value '${@:2}'."

        if (( $# != 0 )); then
            case ${type} in
                'boolean') cli::check::regex "$1" '^$|^true$|^false$' ;;
                'integer') cli::check::regex "$1" '^$|^[-]?[0-9]+$' ;;
            esac

            ref="$1" 

        else
            arg_type=${arg_type} \
            arg_name=${arg_name} \
                ::cli::core::location::initialize::inline
        fi

    elif [[ ${type} == 'map' ]]; then
        cli::check::condition "(( $# < 3 ))" "Unexpected excess value '${@:3}'."

        if (( $# != 0 )); then
            cli::check::regex "${1-}" '.'
            ref+=( [$1]="${2:-}" )
        else
            ref+=()
        fi

    elif [[ ${type} == 'array' ]]; then
        ref+=( "$@" ) 

    else 
        cli::fail "Unexpected call to 'put-builtin' on non-builtin type '${type[@]}'."
    fi
}

main() {
    if $arg_source; then
        source /dev/stdin
    fi

    arg_type=${arg_type} \
    arg_name=${arg_name} \
        inline "$@"

    ::cli::bash::emit::inline "${arg_name^^}"
}

self_test() {

    test_value() {
        declare MY_STRING
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --type string --name my_string -- 'Hi' \
            | assert::pipe_eq \
                "declare -- MY_STRING=\"Hi\""

        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name my_boolean -- true \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="true"'

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --type integer --name my_integer -- 42 \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="42"'

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --type integer --name my_integer -- -42 \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="-42"'

        declare -a MY_ARRAY
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --type array --name my_array -- a b c \
            | assert::pipe_eq \
                "declare -a MY_ARRAY=([0]=\"a\" [1]=\"b\" [2]=\"c\")"
    }

    test_no_value() {

        declare MY_STRING
        declare -p MY_STRING \
            | ${CLI_COMMAND} -s --type string --name my_string \
            | assert::pipe_eq \
                "declare -- MY_STRING=\"\""

        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name my_boolean \
            | assert::pipe_eq \
                'declare -- MY_BOOLEAN="false"'

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --type integer --name my_integer \
            | assert::pipe_eq \
                'declare -i MY_INTEGER="0"'

        declare -a MY_ARRAY
        declare -p MY_ARRAY \
            | ${CLI_COMMAND} -s --type array --name my_array \
            | assert::pipe_eq \
                "declare -a MY_ARRAY=()"

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --type map --name my_map \
            | assert::pipe_eq \
                "declare -A MY_MAP=()"
    }

    test_bad_value() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name my_boolean -- 'bad' \
            2> /dev/null
        assert::failed

        declare -i MY_INTEGER
        declare -p MY_INTEGER \
            | ${CLI_COMMAND} -s --type integer --name my_integer -- 'bad' \
            2> /dev/null
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --type map --name my_map -- '' \
            2> /dev/null
        assert::failed
        set -e
    }

    test_too_many_values() {
        set +e
        declare MY_BOOLEAN
        declare -p MY_BOOLEAN \
            | ${CLI_COMMAND} -s --type boolean --name my_boolean -- 'true' 'bad' \
            2> /dev/null
        assert::failed

        declare -A MY_MAP
        declare -p MY_MAP \
            | ${CLI_COMMAND} -s --type map --name my_map -- 'key' 'value' 'bad' \
            2> /dev/null
        assert::failed
        set -e
    }

    test_value
    test_no_value
    test_bad_value
    test_too_many_values
}

cli::load "$@"
