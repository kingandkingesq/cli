#!/usr/bin/env bash
source $(cli loader ---exports)
cli::import_group
cli::import_inline cli lock
cli::import_inline cli subshell temp file
cli::import_inline cli subshell signal-group

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND}
    
Summary
    Aquire exclusive stderr lock, copy stdin to stderr, and exit.

Description
    Stdin is copied to a temporary log file then the lock is taken and the file is
    copied to stderr. If the lock were taken and then stdin were copied to stdout a
    deadlock would happen if the generator of stdin aquired the lock. Copying the
    content to the temp file prevents that deadlock.  
EOF
}

cli::meta::declare() {
    cli::meta::allow_positional
}

main() {
    ::cli::subshell::dump::inline "$@"
}

::cli::subshell::dump::inline() {

    # create a temporary file
    ::cli::subshell::temp::file::inline

    # write to dump file instead of stderr so generator can take lock
    cat > "${REPLY}"

    # lock and copy dump to stderr
    cat "${REPLY}" \
        | ::cli::lock::inline "$0" >&2 

    # cleanup
    rm "${REPLY}"

    # terminate parent subshells (ie to prevent parents generating
    # noisy debug spew due to their dumping in response to this dump.)
    # if ::cli::subshell::parent::inline; then
    #     kill -SIGTERM ${BASHPPID}
    # fi

    # exit
    exit 1
}

self_test() {
    local CHAR_COUNT=1024

    # a pipeline stage that emits a dump larger than the pipe buffer
    segment() {

        local CHARS=$(
            for ((i=0; i<${CHAR_COUNT}; i++)); do 
                printf $1
            done
        )

        for ((i=0; i<${CHAR_COUNT}; i++)); do {
            printf ${CHARS}
        } done \
            | ::cli::subshell::dump::inline
    }

    local DUMPS=$( 
        # simulate a mulit stage pipeline failure 
        ! ( segment 'a' | segment 'b' ) 2>&1 || cli::assert 
    )

    # assert the dumps from the two pipeline stages do not inerleave
    [[ "${DUMPS}" =~ ^(a+b+|b+a+)$ ]] || cli::assert
}

cli::main "$@"