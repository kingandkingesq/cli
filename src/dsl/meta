#!/usr/bin/env bash
source $(cli loader)
cli::import_group

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND}

    Given a stream of command line productions produce a stream of
    the following form:

        struct meta {
            map default
            array require
            map_of map allow
            map alias
            map implicit_value
            boolean positional
        }

    'required' is an array of required options

    'default' is an associative array of default values which are
    assigned when the option is not present on the command line. All known
    options must have a default.

    'implicit_value' is an associatie array of implicit values which
    are assigned when the option is present on the command line but no value
    is supplied or the value is the empty string.

    'alias' is an assoicative array of aliases, typically a single 
    letter. 

    'allow' is an associative array of space delimited allowed 
    values for a given option. 

    'positional' is a boolean and specifies if positional arguments 
    are accepted.

Arguments
    --print -p       [Flag] : Print the meta tables.
EOF
}

import() {
    cli::meta::add_flag 'print'
}

main() {
    cli::define
    cli::define_field 'map_of map' default
    cli::define_field 'map_of array' require
    cli::define_field 'map_of map_of map' allow
    cli::define_field 'map_of map' alias
    cli::define_field 'map_of map' implicit_value
    cli::define_field 'map_of map' regex
    cli::define_field 'map_of boolean' positional

    cli::declare

    local group
    local name

    # productions are sorted by group + key
    while read group key production production_name identifier; do

        # argument group
        if (( production == CLI_DSL_PRODUCTION_ARGUMENTS )); then
            name=
            group="${identifier}"

        # arguments
        elif (( production == CLI_DSL_PRODUCTION_NAME )); then
            name="${identifier}"
            cli::put STRUCT default "${group}" "${name}"

        # anyargs
        elif (( production == CLI_DSL_PRODUCTION_ANYARGS )); then
            cli::put STRUCT positional "${group}" true

        # alias
        elif (( production == CLI_DSL_PRODUCTION_ALIAS )); then
            cli::put STRUCT alias "${group}" "${identifier}" "${name}"

        # default
        elif (( production == CLI_DSL_PRODUCTION_DEFAULT )); then
            cli::put STRUCT default "${group}" "${name}" "${identifier}"

        # regex
        elif (( production == CLI_DSL_PRODUCTION_REGEX )); then
            cli::put STRUCT regex "${group}" "${name}" "${identifier}"

        # require
        elif (( production == CLI_DSL_PRODUCTION_REQUIRED )); then
            cli::put STRUCT require "${group}" "${name}"

        # flag
        elif (( production == CLI_DSL_PRODUCTION_FLAG )); then
            cli::put STRUCT default "${group}" "${name}" false
            cli::put STRUCT implicit_value "${group}" "${name}" true
            cli::put STRUCT allow "${group}" "${name}" true
            cli::put STRUCT allow "${group}" "${name}" false

        # allow
        elif (( production == CLI_DSL_PRODUCTION_ALLOWED_VALUE )); then
            cli::put STRUCT allow "${group}" "${name}" "${identifier}"
        fi

    done

    if ${arg_print}; then  
        cli::print
    else
        cli::write
    fi
}

self_test() (
    cli dsl sample -h \
        | cli dsl tokenize \
        | cli dsl parse \
        | cli dsl meta -p 
        # \
        # | sort -k1 
        # \
        # | cli core save --dir /tmp/meta
)

cli::main "$@"