#!/usr/bin/env bash
source $(cli loader)
cli::import_group
cli::import cli_assert

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND}
    
Summary
    Tokenizes command line arguments.

Description
    Tokenizes command line arguments. Theoretically, a command line could be 
    matched by a regular expression. This command effectively does that match
    and emits 
    
        an array of paths
        an associative array of named arguments (aka options), and 
        an array of positional arguments (aka arguments)

    For example, 
    
        ${CLI_COMMAND} -- bin sequence --name even -v -- two four six 
        
    produces:

        path bin
        path sequence
        option name even
        option v true
        argument two
        argument four
        argument six

    The command line syntax is based off the Azure az tool with the additon that:
    
        1. multipule single character options can be included behind the 
           same single dash with the last option optionally having a value.
        2. arguments following '--' are positional arguments. 
        
    For example, 

       '-gh v' 
        
    produces: 
    
        option g true
        option h v

    Options proceeded by a double dash must be composed of lowercase letters, numbers, 
    or dash, and must start with a letter. 
    
    Options behind a single dash must be a lowercase letter.

    If an internal flag (e.g. '---which') appears before the first option, then
    parsing ends with success.

Arguments
    --                      : Command line arguments.
EOF
    cat << EOF

Examples
    Tokenize 'bin cli --k0 v0 --flag -xyz v1 -- a0 a1'.
        ${CLI_COMMAND} -- bin cli --k0 v0 --flag -xyz v1 -- a0 a1
EOF
}

import() {
    cli::meta::allow_positional
}

inline() {
    local DASH_DASH='--'
    local DASH_ARG_REGEX="^-([^-].*)$"
    local DASH_DASH_ARG_REGEX="^--([^-].*)$"
    local DASH_DASH_DASH_ARG_REGEX="^---([^-].*)$"

    : ${arg_args:=${CLI_STRUCT_DEFAULT_VARIABLE}}

    # path
    while (( $# > 0 )); do
        if [[ ! "$1" =~ ${CLI_REGEX_NAME} ]]; then
            break;
        fi

        cli::put "${arg_args}" 'path' "$1"
        shift
    done

    # terminate parsing if internal flag follows name (e.g. '---which')
    if (( $# > 0 )) && [[ "$1" =~ ${DASH_DASH_DASH_ARG_REGEX} ]]; then
        return
    fi

    local key
    local value
    local flags
    local -A named=()

    # optional
    while (( $# > 0 )); do

        # --
        if [[ "$1" == ${DASH_DASH} ]]; then
            break
        fi

        # aliases
        if [[ "$1" =~ ${DASH_ARG_REGEX} ]]; then
            flags="${BASH_REMATCH[1]}"
            shift

            if [[ ! "${flags}" =~ ${CLI_REGEX_FLAGS} ]]; then
                cli::fail "Unexpected argument \"-${flags}\" does not match regex ${CLI_REGEX_FLAGS}."
            fi

            for (( i=${#flags} - 1; i>=0; i-- )); do
                key=${flags:${i}:1}

                # substitute
                set -- "${DASH_DASH}${key}" "$@"
            done
            continue
        fi

        # option 
        if [[ "$1" =~ ${DASH_DASH_ARG_REGEX} ]]; then
            key="${BASH_REMATCH[1]}"
            shift

            if [[ ! "${key}" =~ ${CLI_REGEX_NAME} ]]; then
                cli::fail "Unexpected argument \"--${key}\" does not match regex ${CLI_REGEX_NAME}."
            fi

            if (( $# == 0 )) \
                || [[ "$1" =~ ${DASH_ARG_REGEX} ]] \
                || [[ "$1" =~ ${DASH_DASH_ARG_REGEX} ]] \
                || [[ "$1" == ${DASH_DASH} ]]; then

                # implicit value
                value=""
            else
                # explicit value
                value="$1"
                shift
            fi

            # trap duplicates
            if [[ -n ${named[$key]+set} ]]; then
                cli::fail "Unexpected duplicate argument \"--${key}\"."
            fi

            # publish
            cli::put "${arg_args}" 'named' "${key}" "${value}"
            named[${key}]=
            continue
        fi

        cli::fail "Unexpected unlexable argument \"$1\"."
    done

    # positional
    if [[ "${1-}" == "${DASH_DASH}" ]]; then
        shift

        while (( $# > 0 )); do
            cli::put "${arg_args}" 'positional' "$1"
            shift
        done
    fi
}

main() {    
    cli::declare cli_args STRUCT

    arg_args=STRUCT \
        inline "$@"

    cli::write STRUCT
}

self_test() {
    ${CLI_COMMAND} \
    | assert::pipe_eq

    # positional argument delimiter (e.g. --)
    ${CLI_COMMAND} -- \
    | assert::pipe_eq

    # basic
    ${CLI_COMMAND} -- c --k v -- a0 \
    | sort \
    | assert::pipe_records_eq \
        'named k v' \
        'path c' \
        'positional a0'

    # escape
    ${CLI_COMMAND} -- --k 'v v' -- 'a a' \
    | sort \
    | assert::pipe_records_eq \
        'named k v\ v' \
        'positional a\ a'

    # named argument default aliasing (e.g. '-k' -> '--k' )
    ${CLI_COMMAND} -- -k v \
    | assert::pipe_records_eq \
        'named k v' 

    # named argument packed (e.g. '-mn' -> '--m --n' )
    ${CLI_COMMAND} -- -mn \
    | sort \
    | assert::pipe_records_eq \
        "named m" \
        "named n"

    # named argument implicit value (e.g. '' )
    ${CLI_COMMAND} -- --m -n \
    | sort \
    | assert::pipe_records_eq \
        "named m" \
        "named n"

    # path
    ${CLI_COMMAND} -- g0 g1 cmd \
    | assert::pipe_records_eq \
        'path g0' \
        'path g1' \
        'path cmd'

    # positional
    ${CLI_COMMAND} -- -- a0 a1 \
    | sort \
    | assert::pipe_records_eq \
        'positional a0' \
        'positional a1'

exit
    # bad names
    assert::fails "${CLI_COMMAND} -- -!"
    assert::fails "${CLI_COMMAND} -- --!"

    # duplicate named arguments    
    assert::fails "${CLI_COMMAND} -- -f -f"
    assert::fails "${CLI_COMMAND} -- --f --f"
    assert::fails "${CLI_COMMAND} -- --f -f"

    # invalid option (e.g. missing dash before 'k1') 
    assert::fails "${CLI_COMMAND} -- --k0 v0 k1"
}

cli::main "$@"