#!/usr/bin/env bash
source $(cli loader)
cli::import_group
cli::import cli_assert
cli::import cli util deserialize
cli::import cli util serialize
cli::import cli util readset

help() {
    cat << EOF
Command
    ${CLI_COMMAND}
    
Summary
    Parse a command line.

Description
    Consume a stream of tokenized command line arguments and parsed help
    metadata of the form:

        struct {
            args args
            map_of meta meta
        }

        args {
            map named
            array positional
        }

        meta {
            map default
            array require
            map_of map allow
            map alias
            map implicit_value
            boolean positional
        }

    See 'cli dsl meta' for 'meta' field definitions.

    See 'cli args tokenize' for 'args' field definitions.

    'STRUCT_META' either has a single key '*' in which case there is only a single
    valid set of 'meta' to be used to parse a command line, or it has many keys
    each of which is a discriminating option name which determines the 'meta' to be
    used to parse all remaining arguments. For example, many CLI accept two ways of
    identifying a target resource: 'id' and 'name' + 'namespace'. In that case, 'id'
    and 'name' could be used as discriminating options, and only when 'name' is
    specified is 'namespace' allowed.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.

Examples
    Parse 'grp cmd --option value -hg -- a0 a1'.
        cli args tokenize -- --header foo \
        | ${CLI_COMMAND}
EOF
}

inline() {

    : ${arg_args:='ARGS'}
    local -n POSITIONAL_ARGS=${arg_args}_POSITIONAL
    local -n OPTIONAL_ARGS=${arg_args}_NAMED

    : ${arg_meta:='META'}
    
    local group=0

    local -n ALIAS=${arg_meta}_ALIAS
    local -n DEFAULT=${arg_meta}_DEFAULT
    local -n IMPLICT_VALUE=${arg_meta}_IMPLICIT_VALUE
    local -n REQUIRE=${arg_meta}_REQUIRE
    local -n ALLOW=${arg_meta}_ALLOW
    local -n POSITIONAL=${arg_meta}_POSITIONAL

    # options
    for option in "${!OPTIONAL_ARGS[@]}"; do
        local value="${OPTIONAL_ARGS[$option]}"
        local alias=${ALIAS[$option]-}

        # resolve aliases
        if [[ -n ${alias} ]]; then
            unset 'OPTIONAL_ARGS[$option]'
            option=${alias}
            OPTIONAL_ARGS[$option]="${value}"
        fi

        # trap for unknown arguments
        if [[ -z ${DEFAULT[$option]+set} ]]; then
            cli::fail "Unexpected unknown argument '--${option}'."
        fi

        # trap for empty value and assign implicit value
        if [[ -z "${value}" && -n ${IMPLICT_VALUE[$option]+set} ]]; then
            OPTIONAL_ARGS+=( [$option]="${IMPLICT_VALUE[$option]}" )
        fi
    done
    unset alias
    unset value

    # default values
    for option in ${!DEFAULT[@]}; do
        # assign defaults to options not supplied on the command line
        if [[ -z ${OPTIONAL_ARGS[$option]+set} ]]; then
            OPTIONAL_ARGS+=( [$option]="${DEFAULT[$option]}" )
        fi
    done

    # required
    for option in "${REQUIRE[@]}"; do
        if [[ -z "${OPTIONAL_ARGS[$option]-}" ]]; then
            cli::fail "Missing required argument '--${option}'."
        fi
    done

    # allowed values
    for option in "${!ALLOW[@]}"; do

        # args with restricted values must have been assigned an explicit or default value 
        local value=${OPTIONAL_ARGS[$option]?Option \"${option}\" missing valid default value.}

        # resolve name of set of allowed values
        local -n allow=${arg_meta}_ALLOW_${ALLOW[${option}]}

        # test set for allowed value
        if ! ${allow[$value]-false}; then
            cli::fail "Unexpected value '${value}' for argument '--${option}'." \
                "Expected a value in the set { "${!allow[@]}" }."
        fi
    done
    unset value 
    unset -n allow

    # positional
    if ! ${POSITIONAL} && (( ${#POSITIONAL_ARGS[@]} > 0 )); then
        cli::fail "Expected no positional arguments," \
            "but got ${#POSITIONAL_ARGS[@]}: '${POSITIONAL_ARGS[@]}'."
    fi
}

main() {

    cli::define args
    cli::define_field 'map' named args
    cli::define_field 'array' positional args

    cli::define meta
    cli::define_field 'map' default meta
    cli::define_field 'array' require meta
    cli::define_field 'map_of map' allow meta
    cli::define_field 'map' alias meta
    cli::define_field 'map' implicit_value meta
    cli::define_field 'boolean' positional meta

    cli::define
    cli::define_field 'args' args
    cli::define_field 'map_of meta' meta

    cli::declare
    cli::read

    arg_args=STRUCT_ARGS \
    arg_meta=STRUCT_META_0 \
        inline "$@"

    cli::write STRUCT_ARGS args
}

self_test() {

    cat <(cli dsl sample -h \
        | cli dsl tokenize \
        | cli dsl parse \
        | cli dsl meta \
        | cli dsl bgen \
        | sed s/^/meta\ /) \
        <(cli args tokenize -- --f banana -h --header foo -- a0 a1 \
        | sed s/^/args\ /) \
    | cli args parse \
    | sort \
    | assert::pipe_records_eq \
        'named display-args false' \
        'named fruit banana' \
        'named header foo' \
        'named help true' \
        'named id ' \
        'named run-as ' \
        'named self-test false' \
        'positional a0' \
        'positional a1'

    args() {
        cli args tokenize -- "$@" \
            | sed s/^/'args '/
    }

    test() {
        local -a expected=()
        while read; do expected+=( "${REPLY}" ); done

        cat <(meta) <(args "$@") \
            | ${CLI_COMMAND} \
            | assert::pipe_records_eq \
                "${expected[@]}"
    }

    test_fails() {
        cat <(meta) <(args $1) \
            | assert::fails "${CLI_COMMAND}" \
                "${*:2}"
    }

    allow() {
        meta() {
            cat << EOF
            meta * default color black
            meta * require color
            meta * alias c color
            meta * allow color black
            meta * allow color white
EOF
        }

        # default value (e.g. no --color)
        test <<< 'named color black'

        # override default value (e.g. --color white)
        test --color white <<< 'named color white'

        # override default value with alias (e.g. -c white)
        test -c white <<< 'named color white'

        # set disallowed value
        test_fails '--color green' \
            "Unexpected value 'green' for argument '--color'." \
            "Expected a value in the set { black white }."
    }

    flag() {
        meta() {
            cat << EOF
            meta * default help false
            meta * implicit_value help true
            meta * alias h help
            meta * allow help true
            meta * allow help false
EOF
        }

        # add flag (e.g. help is 'false')
        test <<< 'named help false'

        # set flag (e.g. '--help' -> help is 'true')
        test --help <<< 'named help true'

        # set flag with explicit value (e.g. '--help false' -> help is 'false')
        test --help false <<< 'named help false'

        # set flag via alias (e.g. '-h' -> help is 'true')
        test -h <<< 'named help true'

        # flag is boolean (e.g. '--help maybe' disallowed)
        test_fails '--help maybe' \
            "Unexpected value 'maybe' for argument '--help'." \
            "Expected a value in the set { false true }."
    }

    default() {
        meta() {
            cat << EOF
            meta * default name
            meta * require name
EOF
        }

        # provide required named argument (e.g. '--name Bob')
        test --name Bob <<< 'named name Bob'

        # missing required named argument (e.g. missing '--name')
        test_fails '' \
            "Missing required argument '--name'."
    }

    positional() {
        # positional argument allowed
        cat <(echo 'meta * positional true') <(args -- a0 a1) \
            | ${CLI_COMMAND} \
            | assert::pipe_records_eq \
            'positional a0' \
            'positional a1'

        # positional arguments disallowed (e.g. '-- a0')
        cat <(echo 'meta * positional false') <(args -- a0) \
            | assert::fails "${CLI_COMMAND}" \
                "Expected no positional arguments, but got 1: 'a0'."
    }

    unknown() {
        # no default values implies option is unknown (e.g. '--unknown')
        cat <(echo 'meta * ') <(args --unknown) \
            | assert::fails "${CLI_COMMAND}" \
                "Unexpected unknown argument '--unknown'."
    }

    allow
    flag
    default
    positional
    unknown
}

cli::main "$@"