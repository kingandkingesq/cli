#!/usr/bin/env bash
source $(cli loader ---exports)
cli::import_group
cli::import cli-assert
cli::import cli args check

help() {
    cat << EOF | cli::help::global
Command
    ${CLI_COMMAND}
    
Summary
    Check command line arguments against constraints declared in help.

Description
    Consume a stream of 'cli_args' from stdin as would be generated by 'cli args parse'
    and a stream of 'map_of cli_meta_group' as would be generated by 'cli dsl load' as a fd 
    passed as the first positional argument, and ensure the former conforms to constraints 
    specified in the latter.

    'STRUCT_META' either has a single key '*' in which case there is only a single
    valid set of 'meta' to be used to parse a command line, or it has many keys
    each of which is a discriminating option name which determines the 'meta' to be
    used to parse all remaining arguments. For example, many CLI accept two ways of
    identifying a target resource: 'id' and 'name' + 'namespace'. In that case, 'id'
    and 'name' could be used as discriminating options, and only when 'name' is
    specified is 'namespace' allowed.

Arguments
    --                      : Metadata stream.

EOF
    cat << EOF

Examples
    cli args tokenize -- --header foo --help \\
        | cli args parse \\
        | cli args check -- \\
            <( cli dsl sample ---load )
EOF
}

main() {

    cli::declare 'cli_args' ARGS
    cli::read ARGS

    cli::declare 'cli_meta_group' META
    cli::read META < "${1-/dev/null}"

    # cli::print ARGS
    # cli::print META

    ARG_META='META' \
    ARG_ARGS='ARGS' \
        ::cli::args::initialize::inline

    cli::write ARGS
}

::cli::args::initialize::inline() {

    : ${ARG_ARGS:='ARGS'}
    local -n ARGS_POSITIONAL_REF=${ARG_ARGS}_POSITIONAL
    local -n ARGS_NAMED_REF=${ARG_ARGS}_NAMED

    : ${ARG_META:='META'}
    local -n TYPE=${ARG_META}_TYPE
    local -n DEFAULT=${ARG_META}_DEFAULT
    local -n REQUIRE=${ARG_META}_REQUIRE
    local -n REGEX=${ARG_META}_REGEX
    local -n ALLOW=${ARG_META}_ALLOW
    local -n POSITIONAL=${ARG_META}_POSITIONAL

    local option

    # trap for unknown named arguments
    for option in "${!ARGS_NAMED_REF[@]}"; do
        if [[ -z ${TYPE[${option}]+set} ]]; then
            cli::fail "Unexpected unknown argument '--${option}'" \
                "passed to command '${CLI_COMMAND}'."
        fi
    done

    # initialize name arguments
    for option in ${!TYPE[@]}; do

        # type
        local type="${TYPE[${option}]}"

        # declare variable if not specified on command line
        if [[ -z "${ARGS_NAMED_REF[${option}]+set}" ]]; then
            local default=

            # fail if required and missing
            if [[ -n ${REQUIRE[$option]+set} ]]; then
                cli::fail "Missing required argument '--${option}'" \
                    "in call to command '${CLI_COMMAND}'."

            # switch has an explict default
            elif [[ -n "${DEFAULT[${option}]+set}" ]] ; then
                default=${DEFAULT[${option}]}

            # switch has an implicit default; i.e. booleans
            elif [[ "${type}" == 'boolean' ]] ; then
                default=false

            # continue if switch is optional
            else
                continue
            fi

            # assign default if missing
            cli::put ${ARG_ARGS} named "${option}" "${default}"
        fi

        local -n ARGS_NAMED_N_REF="${ARG_ARGS}_NAMED_${ARGS_NAMED_REF[$option]}"

        # declared but empty
        if [[ -z "${ARGS_NAMED_N_REF-}" ]]; then

            # fail if required and empty
            if [[ -n ${REQUIRE[$option]+set} ]]; then
                cli::fail "Required argument '--${option}'" \
                    "passed to command '${CLI_COMMAND}' has empty value."
            fi
        fi

        # allow ref
        local allow=''
        if [[ -n ${ALLOW[$option]+set} ]]; then 
            local -n allow_ref=${ARG_META}_ALLOW_${ALLOW[${option}]}
            allow="${!allow_ref[@]}"
        fi

        # element type & values
        local -a values=()
        local element_type
        local value
        case "${type}" in
            'array') 
                element_type='string' 
                values=( "${ARGS_NAMED_N_REF[@]}" )
                ;;
            'map') 
                element_type='string'
                for value in "${ARGS_NAMED_N_REF[@]}"; do
                    if [[ ! "${value}" =~ ${CLI_REGEX_PROPERTY_ARG} ]]; then
                        cli::fail "Unexpected value '${value}' for argument '--${option}'" \
                            "passed to command '${CLI_COMMAND}'." \
                            "Expected a value that matches regex '${CLI_REGEX_PROPERTY_ARG}'."
                    fi
                    values+=( ${BASH_REMATCH[2]} )
                done
                ;;
            *) 
                element_type="${type}"
                values=( "${ARGS_NAMED_N_REF[@]}" ) 
                ;;
        esac

        # check values
        for value in "${values[@]}"; do
            ::cli::args::check::inline \
                "${option}" \
                "${value}" \
                "${element_type}" \
                "${REGEX[${option}]-}" \
                "${allow}"
        done
    done

    # positional
    if ! ${POSITIONAL} && (( ${#ARGS_POSITIONAL_REF[@]} > 0 )); then
        cli::fail "Expected no positional arguments passed to command '${CLI_COMMAND}'," \
            "but got ${#ARGS_POSITIONAL_REF[@]}: '${ARGS_POSITIONAL_REF[@]}'."
    fi
}

self_test() {

    # cli dsl sample
    cli args tokenize -- --id 42 -f banana -h --header Foo -- a0 a1 \
        | cli args parse -- <( \
            cli dsl sample ---load \
                | awk '$1 == "alias" { $1=""; print }' \
            ) \
        | ${CLI_COMMAND} -- <( \
            cli dsl sample ---load \
                | awk '$1 == "group" && $2 == "id" { $1=""; $2=""; print }' \
            ) \
        | assert::pipe_records_eq \
            'first_named id' \
            'positional a0' \
            'positional a1' \
            'named fruit banana' \
            'named id 42' \
            'named help' \
            'named header Foo'

    meta() {
        echo 'type props map'
        echo 'regex props ^[0-9]$'
    }
    
    # supply list (e.g. '--props a=0 b=1')
    cli args tokenize -- --props a=0 b=1 \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named props' \
            'named props a=0' \
            'named props b=1'

    meta() {
        echo 'type name array'
        echo 'regex name ^[a-z]$'
    }

    # supply list (e.g. '--name a b')
    cli args tokenize -- --name a b \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named name' \
            'named name a' \
            'named name b'

    # supply list with regex mismatch (e.g. '--name 0')
    cli args tokenize -- --name a b 0 \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Unexpected value '0' for argument '--name' passed to command 'cli args initialize'." \
            "Expected a value that matches regex '^[a-z]$'."
                
    meta() {
        echo 'type name array'
        echo 'allow name a'
        echo 'allow name b'
    }

    # supply list with allow mismatch (e.g. '--name 0')
    cli args tokenize -- --name a b 0 \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Unexpected value '0' for argument '--name' passed to command 'cli args initialize'." \
            "Expected a value in the set { b a }."

    meta() {
        echo 'type name string'
        echo 'require name'
    }

    # fail to supply required named argument (e.g. no '--name')
    cli args tokenize \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Missing required argument '--name' in call to command '${CLI_COMMAND}'."

    # empty string for required named argument (e.g. '--name ""')
    cli args tokenize -- --name \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Required argument '--name' passed to command 'cli args initialize' has empty value."

    # provide unknown named argument (e.g. '--bad')
    cli args tokenize -- --name foo --bad \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Unexpected unknown argument '--bad' passed to command '${CLI_COMMAND}'."

    # provide required named argument (e.g. '--name bar')
    cli args tokenize -- --name foo \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named name' \
            'named name foo' 

    meta() {
        echo 'type value string'
        echo 'regex value ^[0-9]+$'
    }

    # fail regex (e.g. '--value 1a')
    cli args tokenize -- --value 1a \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Unexpected value '1a' for argument '--value' passed to command 'cli args initialize'." \
            "Expected a value that matches regex '^[0-9]+$'."

    # provide required named argument (e.g. '--value 42')
    cli args tokenize -- --value 42 \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named value' \
            'named value 42' 

    meta() {
        echo 'type color string'
        echo 'default color black'
    }

    #  default (e.g. '--color black')
    cli args tokenize \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named' \
            'named color black' 

    # override default value (e.g. --color white)
    cli args tokenize -- --color white \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named color' \
            'named color white'

    # override default value with alias (e.g. -c white)
    cli args tokenize -- -c white \
        | cli args parse -- <( echo 'c color' ) \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named color' \
            'named color white'

    meta() {
        echo 'type help boolean'
    }

    # default boolean
    cli args tokenize \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named'

    # implicit boolean (e.g. '--help')
    cli args tokenize -- --help \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named help' \
            'named help'

    # bad allowed value (e.g. '--help bad')
    cli args tokenize -- --help bad \
        | cli args parse \
        | assert::fails "${CLI_COMMAND} -- <( meta )" \
            "Unexpected value 'bad' for argument '--help'" \
            "passed to command 'cli args initialize'." \
            "Expected a value that matches regex '^true$|^false$|^$'."

    meta() {
        echo 'positional true'
    }

    # positional argument allowed
    cli args tokenize -- -- a0 a1 \
        | cli args parse \
        | ${CLI_COMMAND} -- <( meta ) \
        | assert::pipe_records_eq \
            'first_named' \
            'positional a0' \
            'positional a1'
}

cli::main "$@"