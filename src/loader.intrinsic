cli::bash::array::pop () 
{ 
    (( $# > 0 )) || cli::assert 'Stack empty.';
    MAPFILE=(${@:1:$((${#@}-1))})
}
cli::bash::function::is_declared () 
{ 
    declare -F "${1-}" > /dev/null
}
cli::bash::function::list () 
{ 
    declare -F | awk '{ print $3 }' | cli::bash::filter::glob "$@"
}
cli::bash::printf () 
{ 
    local FORMAT=${1-};
    [[ -n "{FORMAT}" ]] || cli::assert 'Missing format.';
    shift;
    if (( $# == 0 )); then
        return;
    fi;
    printf "${FORMAT}" "$@"
}
cli::bash::variable::emit () 
{ 
    cli::bash::variable::list "$@" | while read; do
        declare -p ${REPLY};
    done
}
cli::cache::path () 
{ 
    cli::path::name "$1";
    local NAME="${REPLY}";
    cli::path::dir "$1";
    local DIR="${REPLY}";
    REPLY="${DIR}/.cli/${NAME}"
}
cli::cache::put () 
{ 
    local CACHE="$1";
    cli::path::dir "${CACHE}";
    local DIR="${REPLY}";
    mkdir -p "${DIR}";
    cli::temp::file;
    local TEMP="${REPLY}";
    cat > "${TEMP}";
    mv "${TEMP}" "${CACHE}";
    REPLY="${CACHE}"
}
cli::cache::test () 
{ 
    local CACHE="$1";
    shift;
    if [[ ! -f "${CACHE}" ]]; then
        return 1;
    fi;
    while (( $# > 0 )); do
        local SOURCE="$1";
        shift;
        if [[ ! "${SOURCE}" -ot "${CACHE}" ]]; then
            return 1;
        fi;
    done
}
cli::name::parse () 
{ 
    MAPFILE=();
    while [[ "${1-}" =~ ${CLI_REGEX_NAME} ]]; do
        MAPFILE+=("$1");
        shift;
    done
}
cli::name::to_function () 
{ 
    cli::name::to_bash "$@";
    cli::bash::join "::" "${MAPFILE[@]}"
}
cli::name::to_inline () 
{ 
    cli::name::to_bash "$@";
    cli::bash::join '::' "${MAPFILE[@]}"
}
cli::name::to_symbol () 
{ 
    cli::name::to_bash "$@";
    cli::bash::join '_' "${MAPFILE[@]^^}"
}
cli::path::dir () 
{ 
    REPLY="$(dirname $1)"
}
cli::run_as () 
{ 
    local -a args=($(printf %q "${arg_command}"));
    for i in "$@";
    do
        args+=($(printf %q "${i}"));
    done;
    sudo su "${arg_user}" -c "${args[*]}"
}
cli::set::deflower () 
{ 
    local -n SET_REF=${1?'Missing set'};
    local KEY=${2?'Missing element value'};
    if cli::set::test "$@"; then
        return 1;
    fi;
    SET_REF[${KEY}]=true
}
cli::set::test () 
{ 
    local -n SET_REF=${1:?'Missing set'};
    shift;
    local KEY="$*";
    [[ -n "${KEY}" ]] || cli::assert 'Missing key';
    [[ ${SET_REF[${KEY}]+hit} == 'hit' ]]
}
cli::shim::shebang () 
{ 
    local SOURCE_PATH_RELATIVE="${1-}";
    shift;
    cli::path::make_absolute "${SOURCE_PATH_RELATIVE}";
    local SOURCE_PATH="${REPLY}";
    [[ -n "${CLI_TOOL}" ]] || cli::assert "Shebang failed to declare 'CLI_TOOL'.";
    cli::shim::source "${CLI_TOOL}" || cli::assert "Shebang failed to find shim for cli '${CLI_TOOL}'.";
    local ROOT_DIR=$("${CLI_TOOL}" ---root);
    local REL_PATH="${SOURCE_PATH##"${ROOT_DIR}/"}";
    (( ${#REL_PATH} < ${#SOURCE_PATH} )) || cli::assert "Source path '${SOURCE_PATH}' is not a subpath of '${ROOT_DIR}'.";
    local IFS=/;
    local -a COMMAND=(${CLI_TOOL} ${REL_PATH});
    IFS=${CLI_IFS};
    set "${COMMAND[@]}" "$@";
    unset SOURCE_PATH_RELATIVE;
    unset SOURCE_PATH;
    unset REL_PATH;
    unset COMMAND;
    unset ROOT_DIR;
    [[ -v CLI_TOOL ]] || cli::assert;
    "$@"
}
cli::shim::source () 
{ 
    local NAME="${1-}";
    shift;
    [[ -n ${NAME} ]] || cli::assert 'Missing shim name.';
    if declare -F "${NAME}" > /dev/null; then
        return;
    fi;
    cli::bash::which "${NAME}" || cli::assert "Failed to find shim '${NAME}' on the path.";
    source "${REPLY}";
    cli::bash::function::is_declared "${NAME}" || cli::assert "Shim '${NAME}' failed to define function ${NAME}."
}
cli::shim::which () 
{ 
    local SHIM="${1-}";
    shift;
    cli::shim::source "${SHIM}" || return 1;
    local ROOT_DIR=$( ${SHIM} ---root );
    [[ -d "${ROOT_DIR}" ]] || cli::assert "Shim '${SHIM} ---root' returned '${ROOT_DIR}' which is not a directory.";
    MAPFILE=();
    local IFS=/;
    REPLY="${ROOT_DIR}/$*";
    MAPFILE+=("${REPLY}");
    if [[ ! -f "${REPLY}" ]]; then
        REPLY+='.sh';
        MAPFILE+=("${REPLY}");
    fi;
    [[ -f "${REPLY}" ]]
}
cli::stderr::assert () 
{ 
    if (( $# == 0 )); then
        set 'Condition failed';
    fi;
    { 
        echo "ASSERT FAILED:" "$*";
        cli::bash::stack::trace | sed 's/^/  /'
    } | cli::stderr::dump
}
cli::stderr::fail () 
{ 
    echo "$*" | cli::stderr::dump
}
cli::stderr::on_err () 
{ 
    local -a CLI_PIPESTATUS=("${PIPESTATUS[@]}");
    local CLI_TRAP_EXIT_CODE=${1-'?'};
    local BPID="${BASHPID}";
    if [[ ! $- =~ e ]]; then
        return;
    fi;
    { 
        echo -n "TRAP ERR: exit=${CLI_TRAP_EXIT_CODE}";
        if (( ${#CLI_PIPESTATUS[@]} > 1 )); then
            echo -n ", pipe=[$(cli::bash::join ',' "${CLI_PIPESTATUS[@]}")]";
        fi;
        echo ", bpid=${BPID}, pid=$$";
        echo "BASH_COMMAND ERR: ${BASH_COMMAND}";
        cli::bash::stack::trace | sed 's/^/  /'
    } | cli::stderr::dump
}
cli::bash::filter::glob () 
{ 
    while read -r; do
        local FILTER;
        for FILTER in "$@";
        do
            if [[ "${REPLY}" == ${FILTER} ]]; then
                echo "${REPLY}";
                break;
            fi;
        done;
    done
}
cli::bash::variable::list () 
{ 
    local NAME;
    for NAME in "$@";
    do
        if [[ ! -n "${NAME}" ]]; then
            continue;
        else
            if [[ "${NAME}" =~ ^.*[*]$ ]]; then
                local MATCH;
                for MATCH in $(eval "echo \${!${NAME}}");
                do
                    echo "${MATCH}";
                done;
            else
                if [[ -v "${NAME}" ]]; then
                    echo "${NAME}";
                else
                    local MATCH;
                    for MATCH in $(eval "echo \${!${NAME}*}");
                    do
                        if [[ "${MATCH}" == "${NAME}" ]]; then
                            echo "${NAME}";
                        fi;
                    done;
                fi;
            fi;
        fi;
    done | sort
}
cli::path::name () 
{ 
    REPLY="${1##*/}"
}
cli::temp::file () 
{ 
    local TEMP_FILE=$(mktemp "${1-"${TMPDIR:-/tmp/}"}cli-XXXXXXXX");
    declare -gA "CLI_SUBSHELL_TEMP_FILE_${BASHPID}+=()";
    local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID};
    if (( ${#CLI_SUBSHELL_TEMP_FILE_BASHPID[@]} == 0 )); then
        function cli::temp::file::on_exit () 
        { 
            local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID};
            cli::temp::remove "${!CLI_SUBSHELL_TEMP_FILE_BASHPID[@]}"
        };
        cli::subshell::on_exit cli::temp::file::on_exit;
    fi;
    CLI_SUBSHELL_TEMP_FILE_BASHPID+=(["${TEMP_FILE}"]='true');
    REPLY="${TEMP_FILE}"
}
cli::bash::join () 
{ 
    local DELIMITER=${1?'Missing delimiter'};
    shift;
    REPLY="";
    while (( $# > 0 )); do
        REPLY+="$1";
        shift;
        if (( $# > 0 )); then
            REPLY+="${DELIMITER}";
        fi;
    done
}
cli::name::to_bash () 
{ 
    MAPFILE=();
    while (( $# > 0 )); do
        [[ "$1" =~ ${CLI_REGEX_NAME} ]] || cli::assert "Unexpected cli name \"$1\" does not match regex ${CLI_REGEX_NAME}.";
        MAPFILE+=("${1//[-.]/_}");
        shift;
    done;
    REPLY=${MAPFILE[0]}
}
cli::path::make_absolute () 
{ 
    if [[ ! -n "${1-}" ]]; then
        REPLY="${PWD}";
    else
        if [[ ! "$1" =~ ^/ ]]; then
            REPLY="${PWD}/${1##./}";
        else
            REPLY="$1";
        fi;
    fi
}
cli::bash::which () 
{ 
    MAPFILE=();
    local NAME="$1";
    shift;
    local IFS=:;
    local -a DIRS=(${PATH});
    for dir in "${DIRS[@]}";
    do
        local PROBE="${dir}/${NAME}";
        MAPFILE+=("${PROBE}");
        cli::path::get_info "${PROBE}";
        if ${REPLY_CLI_PATH_IS_EXECUTABLE}; then
            REPLY="${PROBE}";
            return 0;
        fi;
    done;
    return 1
}
cli::bash::stack::trace () 
{ 
    cli::bash::stack::call;
    if [[ -n "${CLI_STACK_SHOW_PROCESS-}" ]]; then
        cli::bash::stack::process;
    fi
}
cli::stderr::dump () 
{ 
    cli::stderr::cat;
    cli::process::signal
}
cli::subshell::on_exit () 
{ 
    local -ga "CLI_SUBSHELL_ON_EXIT_${BASHPID}+=()";
    local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID};
    if (( ${#CLI_SUBSHELL_ON_EXIT[@]} == 0 )); then
        function cli::subshell::on_exit::trap () 
        { 
            local -n CLI_SUBSHELL_ON_EXIT=CLI_SUBSHELL_ON_EXIT_${BASHPID};
            local DELEGATE;
            for DELEGATE in ${CLI_SUBSHELL_ON_EXIT[@]};
            do
                ${DELEGATE};
            done
        };
        trap cli::subshell::on_exit::trap EXIT;
    fi;
    CLI_SUBSHELL_ON_EXIT+=("$@")
}
cli::temp::remove () 
{ 
    local -n CLI_SUBSHELL_TEMP_FILE_BASHPID=CLI_SUBSHELL_TEMP_FILE_${BASHPID};
    for FILE in "$@";
    do
        if ! ${CLI_SUBSHELL_TEMP_FILE_BASHPID[${FILE}]-}; then
            continue;
        fi;
        unset "CLI_SUBSHELL_TEMP_FILE_BASHPID[${FILE}]";
        if [[ ! -a "${FILE}" ]]; then
            :;
        else
            if [[ -d "${FILE}" ]]; then
                rm -f -r "${FILE}";
                rm -f -r "${FILE}";
            else
                rm -f "${FILE}";
            fi;
        fi;
    done
}
cli::path::get_info () 
{ 
    REPLY_CLI_PATH_EXISTS=false;
    REPLY_CLI_PATH_IS_FILE=false;
    REPLY_CLI_PATH_IS_DIRECTORY=false;
    REPLY_CLI_PATH_IS_EXECUTABLE=false;
    REPLY_CLI_PATH_IS_WRITABLE=false;
    REPLY_CLI_PATH_IS_SYMBOLIC_LINK=false;
    if [[ ! -n "${1-}" || ! -e "${1}" ]]; then
        return;
    fi;
    REPLY_CLI_PATH_EXISTS=true;
    if [[ -f "${1}" ]]; then
        REPLY_CLI_PATH_IS_FILE=true;
    else
        if [[ -d "${1}" ]]; then
            REPLY_CLI_PATH_IS_DIRECTORY=true;
        else
            if [[ -L "${1}" ]]; then
                REPLY_CLI_PATH_IS_SYMBOLIC_LINK=true;
            fi;
        fi;
    fi;
    if [[ -w "${1}" ]]; then
        REPLY_CLI_PATH_IS_WRITABLE=true;
    fi;
    if [[ -x "${1}" ]]; then
        REPLY_CLI_PATH_IS_EXECUTABLE=true;
    fi
}
cli::bash::stack::call () 
{ 
    set -- ${BASH_ARGV[@]};
    local -i argc=0;
    for ((i=0; i<${#FUNCNAME[@]}; i++ ))
    do
        local -a args=();
        local inline_args='';
        local funcname="${FUNCNAME[$i]}";
        if (( i == ${#FUNCNAME[@]}-1 )); then
            funcname='bash::main';
        fi;
        for ((j=${BASH_ARGC[$i]}-1; j>=0; j-- ))
        do
            args+=("$(cli::bash::literal "${BASH_ARGV[${j}+${argc}]}")");
        done;
        argc+=${BASH_ARGC[$i]};
        if [[ ! -n "${CLI_STACK_SHOW_HIDDEN-}" ]] && cli::attribute::is_defined 'METHOD' "${funcname}" 'cli_bash_stack_hidden_attribute'; then
            continue;
        fi;
        inline_args="${args[@]}";
        if (( ${#inline_args} > 80 )); then
            inline_args=;
        else
            args=();
        fi;
        printf '%-50s %s:%s\n' "${funcname} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-};
        for arg in "${args[@]}";
        do
            echo "${arg}";
        done | sed 's/^/  /';
    done
}
cli::bash::stack::process () 
{ 
    local ARG_START_PID=${1-$$};
    local ARG_END_PID=${2-${CLI_PID-}};
    local -a pid_parent=();
    local -a pid_cmd=();
    while read pid ppid cmd; do
        pid_parent[${pid}]=${ppid};
        pid_cmd[${pid}]="${cmd}";
    done < <(ps -o pid=,ppid=,args=);
    local pid=${BASHPID};
    local -a subshell=(${BASHPID});
    while (( $pid != $$ )); do
        echo "(${pid}) subshell";
        pid=${pid_parent[${pid}]};
    done;
    local pid=${ARG_START_PID};
    for ((i=0; ${pid} > 0; i++ ))
    do
        echo -n "(${pid}) ";
        local inline_args=${pid_cmd[${pid}]};
        if (( ${#inline_args} < 80 )); then
            echo "${inline_args}";
        else
            echo "${inline_args}" | sed -e 's/--/\
  --/g';
        fi;
        if (( ${pid} == ${ARG_END_PID-0} )); then
            break;
        fi;
        pid=${pid_parent[${pid}]-0};
    done
}
cli::stderr::cat () 
{ 
    cli::temp::file;
    local SCRATCH="${REPLY}";
    cat > "${SCRATCH}";
    cat "${SCRATCH}" | cli::stderr::lock 1>&2;
    rm "${SCRATCH}"
}
cli::process::signal () 
{ 
    local SIGNAL=${1-SIGINT};
    cli::process::get_info;
    kill "-${SIGNAL}" "-${REPLY_CLI_PROCESS_GROUP_ID}"
}
cli::attribute::is_defined () 
{ 
    local target_type=${1-};
    shift;
    local target=${1-};
    shift;
    local type=${1-};
    shift;
    [[ ${target_type} == 'METHOD' ]] || cli::assert;
    [[ ${target} != 'METHOD' ]] || [[ ${target} =~ ${CLI_REGEX_BASH_NAME} ]] || cli::assert;
    local -n targets="CLI_META_ATTRIBUTES_${target_type}";
    local index=${targets[${target}]:-};
    local -n ref="CLI_META_ATTRIBUTES_${target_type}_${index}_TYPE";
    for attribute in "${ref[@]}";
    do
        if [[ "${attribute}" == "${type}" ]]; then
            return 0;
        fi;
    done;
    return 1
}
cli::bash::literal () 
{ 
    local literal="$*";
    if [[ "${literal}" =~ ^[a-zA-Z0-9_-]*$ ]]; then
        echo "${literal}";
        return 0;
    fi;
    local ARRAY=("$*");
    literal=$(declare -p ARRAY);
    literal="${literal:22}";
    literal="${literal:0: -1}";
    echo "${literal}"
}
cli::stderr::lock () 
{ 
    flock -x "${CLI_LOADER_LOCK}" cat
}
cli::process::get_info () 
{ 
    local PID="${1-${BASHPID}}";
    REPLY_CLI_PROCESS_ID=;
    REPLY_CLI_PROCESS_PARENT_ID=;
    REPLY_CLI_PROCESS_GROUP_ID=;
    REPLY_CLI_PROCESS_TERMINAL_ID=;
    REPLY_CLI_PROCESS_USER_ID=;
    REPLY_CLI_PROCESS_UTILIZATION=;
    REPLY_CLI_PROCESS_COMMAND=;
    REPLY_CLI_PROCESS_ARGS=;
    read REPLY_CLI_PROCESS_ID REPLY_CLI_PROCESS_PARENT_ID REPLY_CLI_PROCESS_GROUP_ID REPLY_CLI_PROCESS_TERMINAL_ID REPLY_CLI_PROCESS_USER_ID REPLY_CLI_PROCESS_UTILIZATION REPLY_CLI_PROCESS_COMMAND REPLY_CLI_PROCESS_ARGS < <(ps -p "${PID}" -o pid=,ppid=,pgid=,tname=,euid=,pcpu=,ucmd=,args=)
}
