#!/usr/bin/env bash
source $(cli loader ---exports)
cli::import_parent_group
cli::source cli bash literal
cli::source cli-assert

help() {
    cat << EOF
Command
    ${CLI_COMMAND[@]}
    
Summary
    Print the callstack.

Description
    Print the callstack where each record is composed of:

        frame file line
EOF
}

my_trap() {
    cli::bash::callstack::inline2 $1 1
}

# see https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html
#cli::bash::callstack() {
cli::bash::callstack() {
    local -r EXIT=$1
    local -r ARG_SKIP=${2-0}
    
    echo ---
    echo "$BASH_COMMAND -> $EXIT"

    # argument counts by frame
    set ${BASH_ARGV[@]}

    # debugging aid; FUNCNAME[0] is this frame
    # declare -p FUNCNAME BASH_ARGC BASH_ARGV BASH_LINENO

    # bash stack
    local -i argc=0
    for (( i=0, f=0-1-${ARG_SKIP}; i<${#FUNCNAME[@]}; i++, f++ )); do
        local -a args=()
        local inline_args=''

        # reverse argv for i-th frame
        for (( j=${BASH_ARGC[$i]}-1; j>=0; j-- )); do
            args+=( "$(cli::bash::literal "${BASH_ARGV[${j}+${argc}]}")" )
        done

        # pop argc stack for i-th frame
        argc+=${BASH_ARGC[$i]}

        # skip trap frames
        if (( f < 0 )); then continue; fi

        # inline args when they won't disturb formatting
        inline_args="${args[@]}"
        if (( ${#inline_args} > 45 )); then
            inline_args=
        else
            args=()
        fi

        printf '{%s} %-50s %s:%s\n' \
            ${f} "${FUNCNAME[$i]} ${inline_args}" "${BASH_SOURCE[$i]}" ${BASH_LINENO[$i-1]-}

        for arg in "${args[@]}"; do
            echo "${arg}"
        done | sed 's/^/  /'
    done | sed 's/^/  /'

    if [[ -z "${CLI_BASH_CALLSTACK_PROCESS_STACK-}" ]]; then
        return
    fi

    # load process poset and associated command lines
    local -a pid_parent=()
    local -a pid_cmd=()
    while read pid ppid cmd; do
        pid_parent[${pid}]=${ppid}
        pid_cmd[${pid}]="${cmd}"
    done < <(ps -o pid=,ppid=,args=)

    # subprocess stack
    local pid=$BASHPID
    local -a subshell=( $BASHPID )
    while (( $pid != $$ )); do
        echo "(${pid}) subshell"
        pid=${pid_parent[${pid}]}
    done | sed 's/^/  /'

    # process stack
    local pid=$$
    for (( i=0; ${pid} > 0; i++ )); do
        echo "(${pid}) ${pid_cmd[${pid}]}"
        if (( ${pid} == ${CLI_PID-} )); then break; fi
        pid=${pid_parent[${pid}]-0}
    done | sed 's/^/  /'
}

self_test() {
    # trap 'my_trap $?' ERR

    subpipe() {
        local pid=$BASHPID
        printf '%s %s:%s %s\n' "$1" "$pid" "$BASH_SUBSHELL" $$ > /dev/stderr
        printf '%s\n' "$1" "$(lsof -a -p "$pid" -d 0,1,2)" > /dev/stderr
        cat
        echo hello | grep bar
    }

    pipe() {
        cat | subpipe "${1}${1}" | cat
    }

    echo hi | pipe a | pipe b | pipe c | pipe d
}

cli::main "$@"